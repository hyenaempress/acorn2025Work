# 🔍 탐색 대서사시: 숨겨진 보물을 찾아서

## 📜 서막: 탐색 왕국의 전설

*정렬 왕국의 평화가 찾아온 지 얼마 지나지 않아, 새로운 모험이 시작되었다...*

```
📚 고대 서적에 기록된 예언:

"데이터의 바다에서 특정한 보물을 찾는 자들이 나타날 것이다.
어떤 이는 하나씩 뒤지며 찾고,
어떤 이는 절반씩 나누어 찾으며,
어떤 이는 마법의 주소로 바로 찾아낼 것이다.

하지만 진정한 보물 사냥꾼은
상황에 맞는 최적의 방법을 선택하는 지혜를 가진 자이리라."
```

---

## 🏛️ 전체 등장인물 소개

| 탐색자 | ⏰ 시간복잡도 | 💾 공간복잡도 | 소속 | 역할 | 특징 |
|--------|-------------|-------------|------|------|------|
| 🚶 **린어** | **O(n)** | **O(1)** | **기본 탐색단** | **정찰병** | **착실한 순차 탐색** |
| 🏹 **바이너** | **O(log n)** | **O(1)** | **기본 탐색단** | **궁수** | **정확한 이분 탐색** |
| 🌳 **트리맨** | **O(log n)** | **O(n)** | **자료구조 길드** | **수호자** | **균형잡힌 BST** |
| 🔥 **해셔** | **O(1)** | **O(n)** | **마법 협회** | **마법사** | **순간이동 해시** |
| ⭐ **B-스타** | **O(log n)** | **O(n)** | **데이터베이스 제국** | **황제** | **대용량 B-트리** |
| 🕷️ **그래퍼** | **O(V+E)** | **O(V+E)** | **네트워크 연합** | **거미** | **그래프 탐색의 달인** |
| 🧠 **A-아이** | **O(b^d)** | **O(b^d)** | **AI 연구소** | **천재** | **최적 경로 탐색** |
| 💎 **트라이어** | **O(m)** | **O(n×m)** | **문자열 왕국** | **언어학자** | **문자열 패턴 마스터** |
| 🌀 **블룸** | **O(1)** | **O(m)** | **확률론 마을** | **예언자** | **확률적 존재 판단** |
| 🎯 **스킵퍼** | **O(log n)** | **O(n)** | **확률론 마을** | **도박꾼** | **확률적 빠른 탐색** |

---

## 🌟 제1막: 기본 탐색단의 모험

### 🚶 린어 (Linear Search) - "착실한 정찰병"

#### 캐릭터 설정 👥
- **클래스**: 정찰병 (Scout)
- **정체**: 모든 것을 빠짐없이 확인하는 성실한 탐색자
- **별명**: "한 걸음씩 나아가는 자"
- **성격**: 성실하고 끈기있음, 절대 포기하지 않는 성격
- **특기**: 어떤 상황에서도 반드시 찾아냄 (정렬 여부 무관)
- **철학**: "천천히라도 확실하게, 모든 곳을 다 뒤져본다"
- **말버릇**: "하나씩 차근차근!"
- **무기**: 정찰 돋보기 (모든 데이터를 순서대로 확인)

#### 순차 탐색 모험 🔍
```python
def 린어의_끈질긴_순차탐색(보물창고, 찾는보물):
    """착실한 정찰병 린어의 순차 탐색 모험"""
    
    print(f"🚶 린어: '좋아! {찾는보물}를 찾아보자!'")
    print(f"📦 보물창고: {보물창고}")
    print(f"🎯 목표: {찾는보물}")
    
    print(f"\n🔍 '하나씩 차근차근 확인해보겠어!'")
    
    for 위치, 보물 in enumerate(보물창고):
        print(f"   👀 위치 {위치}: {보물} 확인중...")
        
        if 보물 == 찾는보물:
            print(f"🎉 '찾았다! {찾는보물}가 위치 {위치}에 있어!'")
            return 위치
        else:
            print(f"   ❌ '{보물}은 내가 찾는 게 아니야.'")
    
    print(f"😞 '아쉽지만 {찾는보물}는 여기에 없는 것 같아...'")
    return -1

# 실전 예시
보물창고 = [3, 7, 1, 9, 4, 6, 2, 8, 5]
찾는보물 = 4

print("🚶 린어의 순차 탐색 모험:")
결과 = 린어의_끈질긴_순차탐색(보물창고, 찾는보물)

if 결과 != -1:
    print(f"✅ 성공! 위치: {결과}")
else:
    print("❌ 실패!")
```

**⏰ 시간복잡도**: O(n) - "모든 원소를 확인할 수도 있어!"
**💾 공간복잡도**: O(1) - "추가 공간 필요 없어!"
**🎯 장점**: 정렬되지 않은 데이터도 OK, 100% 신뢰성
**⚠️ 단점**: 느림, 비효율적

---

### 🏹 바이너 (Binary Search) - "정확한 이분 궁수"

#### 캐릭터 설정 🏹
- **클래스**: 궁수 (Archer)
- **정체**: 중간을 노려 절반씩 제거하는 전략적 탐색자
- **별명**: "반으로 나누는 자"
- **성격**: 논리적이고 효율적, 전략적 사고
- **특기**: 정렬된 데이터에서 빛나는 빠른 탐색
- **조건**: 데이터가 정렬되어 있어야만 힘을 발휘
- **철학**: "절반씩 제거하면 빠르게 찾을 수 있다"
- **말버릇**: "중간을 노려보자!"
- **무기**: 이분 활 (정확히 중간을 겨냥)

#### 이분 탐색 모험 🎯
```python
def 바이너의_정밀_이분탐색(정렬된_보물창고, 찾는보물):
    """정확한 이분 궁수 바이너의 이분 탐색 모험"""
    
    print(f"🏹 바이너: '좋아! 이분 탐색으로 {찾는보물}를 찾아보자!'")
    print(f"📦 정렬된 보물창고: {정렬된_보물창고}")
    print(f"🎯 목표: {찾는보물}")
    
    # 정렬 확인
    if 정렬된_보물창고 != sorted(정렬된_보물창고):
        print("⚠️ '어? 정렬이 안 되어 있네! 내 힘을 발휘할 수 없어!'")
        return -1
    
    왼쪽 = 0
    오른쪽 = len(정렬된_보물창고) - 1
    단계 = 1
    
    print(f"\n🏹 '정렬되어 있으니 완벽해! 이분 탐색 시작!'")
    
    while 왼쪽 <= 오른쪽:
        중간 = (왼쪽 + 오른쪽) // 2
        중간값 = 정렬된_보물창고[중간]
        
        print(f"\n📏 단계 {단계}: 범위 [{왼쪽}, {오른쪽}]")
        print(f"   🎯 중간 위치 {중간}: {중간값}")
        
        if 중간값 == 찾는보물:
            print(f"🎉 '정확히 맞췄어! {찾는보물}가 위치 {중간}에 있어!'")
            return 중간
        elif 중간값 < 찾는보물:
            print(f"   ⬆️ '{중간값} < {찾는보물}이니까 오른쪽으로!'")
            왼쪽 = 중간 + 1
        else:
            print(f"   ⬇️ '{중간값} > {찾는보물}이니까 왼쪽으로!'")
            오른쪽 = 중간 - 1
        
        단계 += 1
    
    print(f"😞 '범위를 다 좁혔는데도 없네... {찾는보물}는 여기에 없어!'")
    return -1

# 실전 예시
정렬된_보물창고 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
찾는보물 = 6

print("🏹 바이너의 이분 탐색 모험:")
결과 = 바이너의_정밀_이분탐색(정렬된_보물창고, 찾는보물)

if 결과 != -1:
    print(f"✅ 성공! 위치: {결과}")
else:
    print("❌ 실패!")
```

**⏰ 시간복잡도**: O(log n) - "절반씩 제거하니까 빨라!"
**💾 공간복잡도**: O(1) - "추가 공간 필요 없어!"
**🎯 장점**: 매우 빠름, 효율적
**⚠️ 단점**: 정렬된 데이터에서만 사용 가능

---

## 🌟 제2막: 자료구조 길드의 등장

### 🌳 트리맨 (Binary Search Tree) - "균형잡힌 수호자"

#### 캐릭터 설정 🌳
- **클래스**: 수호자 (Guardian)
- **정체**: 스스로 구조를 만들어 효율적인 탐색을 제공하는 현자
- **별명**: "자라나는 지혜의 나무"
- **성격**: 체계적이고 조직적, 균형을 추구
- **특기**: 삽입하면서 동시에 탐색 구조 구축
- **철학**: "좋은 구조가 빠른 탐색을 만든다"
- **말버릇**: "균형이 중요해!"
- **무기**: 이진 나무 지팡이 (자동으로 구조 생성)

#### BST 탐색 모험 🌲
```python
class 트리노드:
    def __init__(self, 보물):
        self.보물 = 보물
        self.왼쪽 = None
        self.오른쪽 = None

class 트리맨의_BST:
    def __init__(self):
        self.뿌리 = None
        print("🌳 트리맨: '새로운 지혜의 나무를 키워보자!'")
    
    def 보물_심기(self, 보물):
        """새로운 보물을 적절한 위치에 심기"""
        print(f"🌱 '{보물}를 적절한 자리에 심어보겠어!'")
        self.뿌리 = self._심기_도우미(self.뿌리, 보물)
    
    def _심기_도우미(self, 노드, 보물):
        if 노드 is None:
            print(f"   📍 '{보물}를 새로운 자리에 심었어!'")
            return 트리노드(보물)
        
        if 보물 < 노드.보물:
            print(f"   ⬅️ '{보물} < {노드.보물}이니까 왼쪽으로!'")
            노드.왼쪽 = self._심기_도우미(노드.왼쪽, 보물)
        elif 보물 > 노드.보물:
            print(f"   ➡️ '{보물} > {노드.보물}이니까 오른쪽으로!'")
            노드.오른쪽 = self._심기_도우미(노드.오른쪽, 보물)
        else:
            print(f"   🔄 '{보물}는 이미 있네! 그냥 두자.'")
        
        return 노드
    
    def 보물_찾기(self, 찾는보물):
        """지혜의 나무에서 보물 찾기"""
        print(f"🔍 트리맨: '{찾는보물}를 지혜의 나무에서 찾아보자!'")
        return self._찾기_도우미(self.뿌리, 찾는보물, 1)
    
    def _찾기_도우미(self, 노드, 찾는보물, 깊이):
        if 노드 is None:
            print(f"   🚫 깊이 {깊이}: 여기엔 아무것도 없어!")
            return False
        
        print(f"   🌿 깊이 {깊이}: {노드.보물} 확인")
        
        if 찾는보물 == 노드.보물:
            print(f"🎉 '찾았다! {찾는보물}를 깊이 {깊이}에서 발견!'")
            return True
        elif 찾는보물 < 노드.보물:
            print(f"   ⬅️ '{찾는보물} < {노드.보물}이니까 왼쪽으로!'")
            return self._찾기_도우미(노드.왼쪽, 찾는보물, 깊이 + 1)
        else:
            print(f"   ➡️ '{찾는보물} > {노드.보물}이니까g 오른쪽으로!'")
            return self._찾기_도우미(노드.오른쪽, 찾는보물, 깊이 + 1)

# 실전 예시
print("🌳 트리맨의 BST 탐색 모험:")
트리 = 트리맨의_BST()

보물들 = [5, 3, 7, 2, 4, 6, 8]
print(f"\n🌱 보물들을 심어보자: {보물들}")

for 보물 in 보물들:
    트리.보물_심기(보물)

print(f"\n🔍 이제 보물 4를 찾아보자!")
결과 = 트리.보물_찾기(4)

if 결과:
    print(f"✅ 성공!")
else:
    print("❌ 실패!")
```

**⏰ 시간복잡도**: 평균 O(log n), 최악 O(n)
**💾 공간복잡도**: O(n) - "나무 구조 저장 공간 필요!"
**🎯 장점**: 삽입과 탐색이 동시에 효율적
**⚠️ 단점**: 불균형해지면 성능 저하

---

## 🌟 제3막: 마법 협회의 신비

### 🔥 해셔 (Hash Table) - "순간이동 마법사"

#### 캐릭터 설정 ✨
- **클래스**: 마법사 (Wizard)
- **정체**: 마법의 주소 계산으로 순간이동하는 탐색 마법사
- **별명**: "순간이동의 달인"
- **성격**: 천재적이지만 가끔 실수함, 혁신적 사고
- **특기**: O(1) 순간이동 탐색 (충돌이 없을 때)
- **약점**: 해시 충돌이 발생하면 성능 저하
- **철학**: "좋은 해시 함수가 모든 것을 결정한다"
- **말버릇**: "주소 계산 완료! 순간이동!"
- **무기**: 해시 함수 지팡이 (마법의 주소 계산)

#### 해시 테이블 마법 🎩
```python
class 해셔의_마법테이블:
    def __init__(self, 크기=10):
        self.크기 = 크기
        self.마법창고 = [[] for _ in range(크기)]  # 체이닝으로 충돌 해결
        print(f"🔥 해셔: '크기 {크기}의 마법 테이블을 만들었어!'")
    
    def _해시함수(self, 키):
        """마법의 주소 계산 함수"""
        마법주소 = hash(키) % self.크기
        print(f"   🧙 '{키}'의 마법 주소 계산: {마법주소}")
        return 마법주소
    
    def 보물_저장(self, 키, 보물):
        """마법 테이블에 보물 저장"""
        print(f"💎 해셔: '{키}: {보물}'를 저장해보자!'")
        주소 = self._해시함수(키)
        
        # 기존에 같은 키가 있는지 확인
        for i, (기존키, 기존보물) in enumerate(self.마법창고[주소]):
            if 기존키 == 키:
                print(f"   🔄 '{키}'가 이미 있네! 보물을 교체할게!'")
                self.마법창고[주소][i] = (키, 보물)
                return
        
        # 새로운 키-보물 쌍 추가
        self.마법창고[주소].append((키, 보물))
        if len(self.마법창고[주소]) > 1:
            print(f"   ⚠️ '충돌 발생! 주소 {주소}에 {len(self.마법창고[주소])}개 보물이 있어!'")
        else:
            print(f"   ✅ '완벽한 저장! 주소 {주소}에 저장 완료!'")
    
    def 보물_찾기(self, 키):
        """마법의 순간이동으로 보물 찾기"""
        print(f"🔍 해셔: '{키}'를 순간이동으로 찾아보자!'")
        주소 = self._해시함수(키)
        
        print(f"   🚀 '순간이동! 주소 {주소}로 이동!'")
        
        창고 = self.마법창고[주소]
        if not 창고:
            print(f"   🚫 '어? 주소 {주소}가 비어있어! {키}는 없는 것 같아!'")
            return None
        
        print(f"   📦 '주소 {주소}의 창고 내용: {창고}'")
        
        for 저장키, 보물 in 창고:
            print(f"   🔍 '{저장키}' 확인중...")
            if 저장키 == 키:
                print(f"   🎉 '찾았다! {키}: {보물}'")
                return 보물
        
        print(f"   😞 '{키}는 이 주소에 없네...'")
        return None
    
    def 상태_확인(self):
        """마법 테이블 상태 확인"""
        print(f"\n📊 해셔의 마법 테이블 상태:")
        for i, 창고 in enumerate(self.마법창고):
            if 창고:
                print(f"   주소 {i}: {창고}")
            else:
                print(f"   주소 {i}: 비어있음")

# 실전 예시
print("🔥 해셔의 해시 테이블 마법:")
해시테이블 = 해셔의_마법테이블(7)

보물데이터 = [
    ("금반지", "황금빛 반지"),
    ("은목걸이", "은빛 목걸이"), 
    ("다이아몬드", "반짝이는 보석"),
    ("루비", "빨간 보석"),
    ("에메랄드", "초록 보석")
]

print(f"\n💎 보물들을 저장해보자!")
for 키, 보물 in 보물데이터:
    해시테이블.보물_저장(키, 보물)

해시테이블.상태_확인()

print(f"\n🔍 '다이아몬드'를 찾아보자!")
결과 = 해시테이블.보물_찾기("다이아몬드")

if 결과:
    print(f"✅ 성공! 발견한 보물: {결과}")
else:
    print("❌ 실패!")
```

**⏰ 시간복잡도**: 평균 O(1), 최악 O(n)
**💾 공간복잡도**: O(n) - "해시 테이블 공간 필요!"
**🎯 장점**: 최고 속도 (충돌 없을 때)
**⚠️ 단점**: 해시 충돌시 성능 저하, 메모리 사용량 큼

---

## 🌟 제4막: 특수 임무단의 활약

### ⭐ B-스타 (B-Tree) - "데이터베이스 황제"

#### 캐릭터 설정 👑
- **클래스**: 황제 (Emperor)
- **정체**: 대용량 데이터베이스의 절대 강자
- **별명**: "디스크의 지배자"
- **성격**: 위엄있고 체계적, 대용량 처리의 달인
- **특기**: 디스크 I/O 최적화, 대용량 데이터 처리
- **철학**: "많은 자식을 두어 깊이를 줄인다"
- **말버릇**: "대용량이야말로 내 전문 분야!"
- **무기**: B-트리 왕홀 (다중 분기 구조)

#### B-트리 탐색 👑
```python
class B트리노드:
    def __init__(self, 차수):
        self.차수 = 차수
        self.키들 = []
        self.자식들 = []
        self.잎노드인가 = True

class B스타의_B트리:
    def __init__(self, 차수=3):
        self.뿌리 = B트리노드(차수)
        self.차수 = 차수
        print(f"⭐ B-스타: '차수 {차수}의 B-트리 제국을 건설하겠다!'")
    
    def 보물_찾기(self, 키):
        """B-트리에서 보물 찾기 (단순화된 버전)"""
        print(f"🔍 B-스타: '{키}를 제국에서 찾아보자!'")
        return self._찾기_도우미(self.뿌리, 키, 1)
    
    def _찾기_도우미(self, 노드, 키, 레벨):
        print(f"   📚 레벨 {레벨}: 키들 {노드.키들} 확인")
        
        # 현재 노드에서 키 찾기
        for i, 현재키 in enumerate(노드.키들):
            if 키 == 현재키:
                print(f"   🎉 '찾았다! {키}를 레벨 {레벨}에서 발견!'")
                return True
            elif 키 < 현재키:
                if 노드.잎노드인가:
                    print(f"   🚫 '잎 노드에 도달했지만 {키}가 없어!'")
                    return False
                else:
                    print(f"   ⬇️ '{키} < {현재키}이니까 {i}번째 자식으로!'")
                    return self._찾기_도우미(노드.자식들[i], 키, 레벨 + 1)
        
        # 모든 키보다 큰 경우
        if 노드.잎노드인가:
            print(f"   🚫 '잎 노드 끝까지 왔지만 {키}가 없어!'")
            return False
        else:
            print(f"   ⬇️ '{키}가 모든 키보다 크니까 마지막 자식으로!'")
            return self._찾기_도우미(노드.자식들[-1], 키, 레벨 + 1)

# 실전 예시 (단순화된 버전)
print("⭐ B-스타의 B-트리 탐색:")

# 수동으로 B-트리 구조 생성 (예시용)
btree = B스타의_B트리(3)
btree.뿌리.키들 = [10, 20, 30]
btree.뿌리.잎노드인가 = False

# 자식 노드들 생성
자식1 = B트리노드(3)
자식1.키들 = [5, 8]

자식2 = B트리노드(3)  
자식2.키들 = [15, 18]

자식3 = B트리노드(3)
자식3.키들 = [25, 28]

자식4 = B트리노드(3)
자식4.키들 = [35, 38]

btree.뿌리.자식들 = [자식1, 자식2, 자식3, 자식4]

print(f"\n🔍 보물 '18'을 찾아보자!")
결과 = btree.보물_찾기(18)

if 결과:
    print(f"✅ 성공!")
else:
    print("❌ 실패!")
```

**⏰ 시간복잡도**: O(log n) - "하지만 디스크 I/O 최적화!"
**💾 공간복잡도**: O(n) - "대용량 저장 구조!"
**🎯 장점**: 디스크 I/O 최적화, 대용량 데이터 처리
**⚠️ 단점**: 복잡한 구현, 메모리 오버헤드

---

### 🕷️ 그래퍼 (Graph Search) - "네트워크의 거미"

#### 캐릭터 설정 🕸️
- **클래스**: 거미 (Spider)
- **정체**: 복잡한 관계망을 탐색하는 네트워크 전문가
- **별명**: "연결의 탐험가"
- **성격**: 호기심 많고 모험적, 모든 연결을 탐험하고 싶어함
- **특기**: DFS/BFS로 그래프의 모든 경로 탐색
- **철학**: "모든 것은 연결되어 있다"
- **말버릇**: "길이 있는 곳에 내가 있다!"
- **무기**: 거미줄 지도 (그래프 네트워크)

#### 그래프 탐색 모험 🗺️
```python
from collections import deque, defaultdict

class 그래퍼의_네트워크:
    def __init__(self):
        self.그래프 = defaultdict(list)
        print("🕷️ 그래퍼: '새로운 네트워크를 구축해보자!'")
    
    def 길_만들기(self, 시작지, 목적지):
        """두 지점 사이에 길 만들기"""
        self.그래프[시작지].append(목적지)
        self.그래프[목적지].append(시작지)  # 양방향
        print(f"🛤️ '{시작지} ↔ {목적지}' 길을 만들었어!'")
    
    def DFS_깊이우선탐색(self, 시작지, 목적지):
        """깊이 우선 탐색으로 목적지 찾기"""
        print(f"🕷️ 그래퍼: 'DFS로 {시작지}에서 {목적지}까지 가는 길을 찾아보자!'")
        
        방문기록 = set()
        경로스택 = [(시작지, [시작지])]  # (현재위치, 지금까지경로)
        
        while 경로스택:
            현재위치, 지금까지경로 = 경로스택.pop()
            
            print(f"   🔍 현재 위치: {현재위치}, 경로: {' → '.join(지금까지경로)}")
            
            if 현재위치 == 목적지:
                print(f"   🎉 '목적지 발견! 경로: {' → '.join(지금까지경로)}'")
                return 지금까지경로
            
            if 현재위치 in 방문기록:
                print(f"   🔄 '{현재위치}는 이미 방문했어! 건너뛰자.'")
                continue
            
            방문기록.add(현재위치)
            print(f"   📝 '{현재위치}' 방문 기록!'")
            
            # 연결된 모든 곳을 스택에 추가 (역순으로 하여 사전순 탐색)
            for 다음지점 in reversed(self.그래프[현재위치]):
                if 다음지점 not in 방문기록:
                    새경로 = 지금까지경로 + [다음지점]
                    경로스택.append((다음지점, 새경로))
                    print(f"   📋 '{다음지점}' 탐색 예정 추가!")
        
        print(f"   😞 '{목적지}에 갈 수 있는 길이 없어!'")
        return None
    
    def BFS_너비우선탐색(self, 시작지, 목적지):
        """너비 우선 탐색으로 최단 경로 찾기"""
        print(f"🕷️ 그래퍼: 'BFS로 {시작지}에서 {목적지}까지 최단경로를 찾아보자!'")
        
        방문기록 = set()
        경로큐 = deque([(시작지, [시작지])])  # (현재위치, 지금까지경로)
        
        while 경로큐:
            현재위치, 지금까지경로 = 경로큐.popleft()
            
            print(f"   🔍 현재 위치: {현재위치}, 경로: {' → '.join(지금까지경로)}")
            
            if 현재위치 == 목적지:
                print(f"   🎉 '최단경로 발견! 경로: {' → '.join(지금까지경로)}'")
                return 지금까지경로
            
            if 현재위치 in 방문기록:
                print(f"   🔄 '{현재위치}는 이미 방문했어! 건너뛰자.'")
                continue
            
            방문기록.add(현재위치)
            print(f"   📝 '{현재위치}' 방문 기록!'")
            
            # 연결된 모든 곳을 큐에 추가
            for 다음지점 in self.그래프[현재위치]:
                if 다음지점 not in 방문기록:
                    새경로 = 지금까지경로 + [다음지점]
                    경로큐.append((다음지점, 새경로))
                    print(f"   📋 '{다음지점}' 탐색 예정 추가!")
        
        print(f"   😞 '{목적지}에 갈 수 있는 길이 없어!'")
        return None

# 실전 예시
print("🕷️ 그래퍼의 그래프 탐색 모험:")
네트워크 = 그래퍼의_네트워크()

# 네트워크 구축
연결정보 = [
    ("A", "B"), ("A", "C"), ("B", "D"), 
    ("C", "D"), ("C", "E"), ("D", "F"), ("E", "F")
]

print(f"\n🛤️ 네트워크를 구축해보자!")
for 시작, 끝 in 연결정보:
    네트워크.길_만들기(시작, 끝)

print(f"\n📊 네트워크 상태:")
for 지점, 연결지점들 in 네트워크.그래프.items():
    print(f"   {지점}: {연결지점들}")

print(f"\n🔍 DFS로 A에서 F까지 가는 길 찾기:")
dfs_결과 = 네트워크.DFS_깊이우선탐색("A", "F")

print(f"\n🔍 BFS로 A에서 F까지 최단경로 찾기:")
bfs_결과 = 네트워크.BFS_너비우선탐색("A", "F")

print(f"\n📋 결과 비교:")
print(f"   DFS 경로: {' → '.join(dfs_결과) if dfs_결과 else '경로 없음'}")
print(f"   BFS 경로: {' → '.join(bfs_결과) if bfs_결과 else '경로 없음'}")
```

**⏰ 시간복잡도**: O(V + E) - "V: 정점 수, E: 간선 수"
**💾 공간복잡도**: O(V + E) - "그래프 저장 공간!"
**🎯 장점**: 복잡한 관계 탐색, 경로 발견
**⚠️ 단점**: 큰 그래프에서 메모리 사용량 많음

---

### 🧠 A-아이 (A* Search) - "최적 경로의 천재"

#### 캐릭터 설정 🎯
- **클래스**: 천재 (Genius)
- **정체**: 휴리스틱을 활용한 최적 경로 탐색의 대가
- **별명**: "최적해의 예언자"
- **성격**: 똑똑하고 효율적, 항상 최선의 길을 찾고자 함
- **특기**: 목적지까지의 예상 거리를 계산하여 최적 경로 탐색
- **철학**: "과거의 비용과 미래의 예측을 모두 고려한다"
- **말버릇**: "f(n) = g(n) + h(n)!"
- **무기**: 휴리스틱 나침반 (목적지까지의 거리 예측)

#### A* 탐색 모험 🌟
```python
import heapq
import math

class A아이의_최적경로탐색:
    def __init__(self):
        self.그래프 = {}
        self.좌표 = {}
        print("🧠 A-아이: '최적 경로 탐색 시스템을 가동하겠다!'")
    
    def 지점_추가(self, 지점명, x, y):
        """지점과 좌표 정보 추가"""
        self.좌표[지점명] = (x, y)
        self.그래프[지점명] = []
        print(f"📍 '{지점명}' 지점을 ({x}, {y})에 추가!")
    
    def 길_추가(self, 시작지, 목적지, 비용):
        """두 지점 사이 길과 비용 추가"""
        self.그래프[시작지].append((목적지, 비용))  
        self.그래프[목적지].append((시작지, 비용))  # 양방향
        print(f"🛤️ '{시작지} ↔ {목적지}' (비용: {비용}) 길 추가!")
    
    def 휴리스틱_거리(self, 현재지점, 목적지):
        """휴리스틱 함수: 유클리드 거리 계산"""
        x1, y1 = self.좌표[현재지점]
        x2, y2 = self.좌표[목적지]
        거리 = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        return 거리
    
    def A스타_탐색(self, 시작지, 목적지):
        """A* 알고리즘으로 최적 경로 탐색"""
        print(f"🧠 A-아이: 'A* 알고리즘으로 {시작지}에서 {목적지}까지 최적 경로를 찾겠다!'")
        
        # 우선순위 큐: (f값, g값, 현재지점, 경로)
        열린목록 = [(0, 0, 시작지, [시작지])]
        닫힌목록 = set()
        
        while 열린목록:
            f값, g값, 현재지점, 경로 = heapq.heappop(열린목록)
            
            print(f"   🔍 현재: {현재지점}, g={g값:.1f}, h={f값-g값:.1f}, f={f값:.1f}")
            print(f"      경로: {' → '.join(경로)}")
            
            if 현재지점 == 목적지:
                print(f"   🎉 '최적 경로 발견! 총 비용: {g값:.1f}'")
                print(f"      최종 경로: {' → '.join(경로)}")
                return 경로, g값
            
            if 현재지점 in 닫힌목록:
                print(f"   🔄 '{현재지점}' 이미 처리됨, 건너뛰기")
                continue
            
            닫힌목록.add(현재지점)
            
            # 인접 지점들 탐색
            for 다음지점, 이동비용 in self.그래프[현재지점]:
                if 다음지점 in 닫힌목록:
                    continue
                
                새_g값 = g값 + 이동비용
                h값 = self.휴리스틱_거리(다음지점, 목적지)
                새_f값 = 새_g값 + h값
                
                새_경로 = 경로 + [다음지점]
                
                print(f"   📋 '{다음지점}' 검토: g={새_g값:.1f}, h={h값:.1f}, f={새_f값:.1f}")
                
                heapq.heappush(열린목록, (새_f값, 새_g값, 다음지점, 새_경로))
        
        print(f"   😞 '{목적지}에 도달할 수 있는 경로가 없어!'")
        return None, float('inf')

# 실전 예시
print("🧠 A-아이의 A* 탐색 모험:")
astar = A아이의_최적경로탐색()

# 지점들 추가 (좌표 포함)
지점정보 = [
    ("A", 0, 0), ("B", 1, 1), ("C", 0, 2), 
    ("D", 2, 1), ("E", 1, 3), ("F", 3, 3)
]

print(f"\n📍 지점들을 추가해보자!")
for 지점, x, y in 지점정보:
    astar.지점_추가(지점, x, y)

# 길과 비용 추가
길정보 = [
    ("A", "B", 1.4), ("A", "C", 2.0), ("B", "D", 1.0),
    ("C", "E", 1.4), ("D", "F", 2.2), ("E", "F", 2.0)
]

print(f"\n🛤️ 길들을 추가해보자!")
for 시작, 끝, 비용 in 길정보:
    astar.길_추가(시작, 끝, 비용)

print(f"\n🔍 A*로 A에서 F까지 최적 경로 찾기:")
경로, 비용 = astar.A스타_탐색("A", "F")

if 경로:
    print(f"✅ 성공! 최적 경로: {' → '.join(경로)}, 총 비용: {비용:.1f}")
else:
    print("❌ 실패!")
```

**⏰ 시간복잡도**: O(b^d) - "b: 분기계수, d: 깊이"
**💾 공간복잡도**: O(b^d) - "열린목록 저장 공간!"
**🎯 장점**: 최적 경로 보장 (좋은 휴리스틱 함수 사용시)
**⚠️ 단점**: 메모리 사용량 많음, 휴리스틱 함수 설계 중요

---

### 💎 트라이어 (Trie) - "문자열 왕국의 언어학자"

#### 캐릭터 설정 📚
- **클래스**: 언어학자 (Linguist)
- **정체**: 문자열 패턴을 효율적으로 저장하고 탐색하는 전문가
- **별명**: "접두사의 마법사"
- **성격**: 체계적이고 논리적, 언어의 구조를 사랑함
- **특기**: 접두사를 활용한 빠른 문자열 탐색
- **철학**: "모든 단어는 접두사부터 시작된다"
- **말버릇**: "접두사가 같으면 길을 공유한다!"
- **무기**: 트라이 트리 (문자별 분기 구조)

#### 트라이 탐색 모험 🌳
```python
class 트라이노드:
    def __init__(self):
        self.자식들 = {}
        self.단어끝인가 = False

class 트라이어의_문자열왕국:
    def __init__(self):
        self.뿌리 = 트라이노드()
        print("💎 트라이어: '문자열 왕국의 트라이 트리를 건설하겠다!'")
    
    def 단어_추가(self, 단어):
        """트라이에 단어 추가"""
        print(f"📝 '{단어}'를 트라이에 추가해보자!")
        현재노드 = self.뿌리
        
        for i, 문자 in enumerate(단어):
            if 문자 not in 현재노드.자식들:
                현재노드.자식들[문자] = 트라이노드()
                print(f"   🆕 '{문자}' 노드 생성! (깊이: {i+1})")
            else:
                print(f"   ✅ '{문자}' 노드 이미 존재 (깊이: {i+1})")
            
            현재노드 = 현재노드.자식들[문자]
        
        현재노드.단어끝인가 = True
        print(f"   🏁 '{단어}' 추가 완료!")
    
    def 단어_찾기(self, 단어):
        """트라이에서 완전한 단어 찾기"""
        print(f"🔍 트라이어: '트라이에서 {단어}를 찾아보자!'")
        현재노드 = self.뿌리
        
        for i, 문자 in enumerate(단어):
            print(f"   📍 깊이 {i+1}: '{문자}' 확인")
            
            if 문자 not in 현재노드.자식들:
                print(f"   🚫 '{문자}' 경로가 없어! {단어}는 존재하지 않아!")
                return False
            
            현재노드 = 현재노드.자식들[문자]
            print(f"   ✅ '{문자}' 경로 발견, 다음으로 이동!")
        
        if 현재노드.단어끝인가:
            print(f"   🎉 '{단어}' 완전한 단어로 발견!")
            return True
        else:
            print(f"   🔸 '{단어}'는 접두사로만 존재해!")
            return False
    
    def 접두사_찾기(self, 접두사):
        """주어진 접두사로 시작하는 모든 단어 찾기"""
        print(f"🔍 트라이어: '접두사 {접두사}로 시작하는 단어들을 찾아보자!'")
        
        # 접두사까지 이동
        현재노드 = self.뿌리
        for 문자 in 접두사:
            if 문자 not in 현재노드.자식들:
                print(f"   🚫 '{접두사}' 접두사가 존재하지 않아!")
                return []
            현재노드 = 현재노드.자식들[문자]
        
        print(f"   ✅ 접두사 '{접두사}' 위치 도달!")
        
        # 해당 위치부터 모든 단어 수집
        결과단어들 = []
        self._모든단어수집(현재노드, 접두사, 결과단어들)
        
        print(f"   🎯 발견된 단어들: {결과단어들}")
        return 결과단어들
    
    def _모든단어수집(self, 노드, 현재단어, 결과목록):
        """재귀적으로 모든 단어 수집"""
        if 노드.단어끝인가:
            결과목록.append(현재단어)
            print(f"     📝 '{현재단어}' 수집!")
        
        for 문자, 자식노드 in 노드.자식들.items():
            self._모든단어수집(자식노드, 현재단어 + 문자, 결과목록)

# 실전 예시
print("💎 트라이어의 문자열 탐색 모험:")
트라이 = 트라이어의_문자열왕국()

단어목록 = ["cat", "cats", "car", "card", "care", "careful", "dog", "dodge"]

print(f"\n📝 단어들을 트라이에 추가해보자!")
for 단어 in 단어목록:
    트라이.단어_추가(단어)

print(f"\n🔍 'car'를 찾아보자!")
결과1 = 트라이.단어_찾기("car")

print(f"\n🔍 'ca'로 시작하는 모든 단어를 찾아보자!")
결과2 = 트라이.접두사_찾기("ca")

print(f"\n📋 결과 요약:")
print(f"   'car' 존재: {결과1}")
print(f"   'ca'로 시작하는 단어들: {결과2}")
```

**⏰ 시간복잡도**: O(m) - "m: 문자열 길이"
**💾 공간복잡도**: O(n × m) - "n: 단어 수, m: 평균 길이"
**🎯 장점**: 접두사 검색 매우 빠름, 자동완성에 최적
**⚠️ 단점**: 메모리 사용량 많음

---

## 🌟 제5막: 확률론 마을의 등장

### 🌀 블룸 (Bloom Filter) - "확률적 예언자"

#### 캐릭터 설정 🔮
- **클래스**: 예언자 (Oracle)
- **정체**: 확률을 이용해 빠르게 존재 여부를 판단하는 마법사
- **별명**: "거짓음성의 예언자"
- **성격**: 신비롭고 확률적, 100% 확신하지 않지만 매우 빠름
- **특기**: "없다"는 확실히 알지만 "있다"는 불확실
- **철학**: "완벽하지 않아도 빠르면 된다"
- **말버릇**: "아마도... 95% 확률로!"
- **무기**: 확률 크리스탈 (비트 배열과 해시 함수들)

#### 블룸 필터 마법 🎲
```python
import hashlib

class 블룸의_확률예언:
    def __init__(self, 크기=100, 해시개수=3):
        self.크기 = 크기
        self.해시개수 = 해시개수
        self.비트배열 = [False] * 크기
        print(f"🌀 블룸: '크기 {크기}, 해시 {해시개수}개의 확률 크리스탈을 만들었어!'")
    
    def _해시함수들(self, 항목):
        """여러 해시 함수로 위치들 계산"""
        해시값들 = []
        
        for i in range(self.해시개수):
            # 다른 시드를 사용하여 다른 해시값 생성
            해시_입력 = f"{항목}_{i}".encode()
            해시값 = int(hashlib.md5(해시_입력).hexdigest(), 16)
            위치 = 해시값 % self.크기
            해시값들.append(위치)
            print(f"   🎲 해시{i+1}({항목}) = {위치}")
        
        return 해시값들
    
    def 항목_추가(self, 항목):
        """블룸 필터에 항목 추가"""
        print(f"✨ 블룸: '{항목}'를 확률 크리스탈에 추가해보자!'")
        
        위치들 = self._해시함수들(항목)
        
        for 위치 in 위치들:
            if self.비트배열[위치]:
                print(f"   ✅ 위치 {위치}는 이미 True")
            else:
                print(f"   🆕 위치 {위치}를 True로 설정")
                self.비트배열[위치] = True
        
        print(f"   🌟 '{항목}' 추가 완료!")
    
    def 항목_확인(self, 항목):
        """블룸 필터로 항목 존재 가능성 확인"""
        print(f"🔮 블룸: '{항목}'의 존재를 예언해보자!'")
        
        위치들 = self._해시함수들(항목)
        
        모든_위치가_True = True
        for 위치 in 위치들:
            if self.비트배열[위치]:
                print(f"   ✅ 위치 {위치}: True")
            else:
                print(f"   ❌ 위치 {위치}: False")
                모든_위치가_True = False
        
        if 모든_위치가_True:
            print(f"   🔮 '아마도... {항목}이 있을 것 같아! (확률적 판단)'")
            return "아마도 존재"
        else:
            print(f"   🚫 '확실히 {항목}은 없어! (100% 확신)'")
            return "확실히 없음"
    
    def 상태_확인(self):
        """현재 비트 배열 상태 확인"""
        print(f"\n📊 블룸의 확률 크리스탈 상태:")
        print(f"   비트 배열: {self.비트배열}")
        설정된_비트 = sum(self.비트배열)
        사용률 = (설정된_비트 / self.크기) * 100
        print(f"   사용률: {설정된_비트}/{self.크기} ({사용률:.1f}%)")

# 실전 예시
print("🌀 블룸의 확률적 존재 예언:")
블룸필터 = 블룸의_확률예언(20, 3)

저장항목들 = ["apple", "banana", "cherry"]

print(f"\n✨ 항목들을 추가해보자!")
for 항목 in 저장항목들:
    블룸필터.항목_추가(항목)

블룸필터.상태_확인()

테스트항목들 = ["apple", "grape", "banana", "kiwi"]

print(f"\n🔮 존재 여부를 예언해보자!")
for 항목 in 테스트항목들:
    결과 = 블룸필터.항목_확인(항목)
    실제존재 = 항목 in 저장항목들
    print(f"   📋 '{항목}': 예언={결과}, 실제={'존재' if 실제존재 else '없음'}")
```

**⏰ 시간복잡도**: O(k) - "k: 해시 함수 개수"
**💾 공간복잡도**: O(m) - "m: 비트 배열 크기"
**🎯 장점**: 매우 빠름, 메모리 효율적
