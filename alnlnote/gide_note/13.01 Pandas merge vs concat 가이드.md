# Pandas merge vs concat 완전 가이드

## 🎯 핵심 요약

| 구분 | **merge** | **concat** |
|------|-----------|------------|
| **결합 방식** | 키 컬럼 기준 조인 (SQL 스타일) | 물리적 붙이기 (Union 스타일) |
| **용도** | 관계형 데이터 결합 | 데이터 추가/확장 |
| **조인 종류** | inner, outer, left, right | - |
| **중복 처리** | 자동 처리 | 그대로 유지 |
| **성능** | 상대적으로 느림 | 빠름 |
| **인덱스** | 키 컬럼 기준 재구성 | 기존 인덱스 유지 가능 |

---

## 🔗 **merge: 관계형 데이터베이스 스타일 조인**

### 기본 개념
```python
import pandas as pd

# 학생 정보 테이블
students = pd.DataFrame({
    'student_id': [1, 2, 3],
    'name': ['김철수', '이영희', '박민수']
})

# 성적 정보 테이블  
scores = pd.DataFrame({
    'student_id': [1, 2, 4],  # 3번은 없고 4번이 있음
    'score': [85, 92, 78]
})

print("학생 정보:")
print(students)
print("\n성적 정보:")
print(scores)
```

### merge의 4가지 조인 방식

#### 1️⃣ Inner Join (교집합)
```python
inner_result = pd.merge(students, scores, on='student_id', how='inner')
print("Inner Join 결과:")
print(inner_result)
```
**결과**: 양쪽에 모두 있는 학생만 (김철수, 이영희)

#### 2️⃣ Left Join (왼쪽 기준)
```python
left_result = pd.merge(students, scores, on='student_id', how='left')
print("Left Join 결과:")
print(left_result)
```
**결과**: 모든 학생 정보 유지, 성적 없으면 NaN

#### 3️⃣ Right Join (오른쪽 기준)
```python
right_result = pd.merge(students, scores, on='student_id', how='right')
print("Right Join 결과:")
print(right_result)
```
**결과**: 모든 성적 정보 유지, 학생 정보 없으면 NaN

#### 4️⃣ Outer Join (합집합)
```python
outer_result = pd.merge(students, scores, on='student_id', how='outer')
print("Outer Join 결과:")
print(outer_result)
```
**결과**: 모든 데이터 포함, 없는 부분은 NaN

### merge 고급 활용

#### 다른 컬럼명으로 조인
```python
# 컬럼명이 다를 때
df1 = pd.DataFrame({'id': [1, 2], 'data1': ['A', 'B']})
df2 = pd.DataFrame({'student_id': [1, 2], 'data2': ['X', 'Y']})

result = pd.merge(df1, df2, left_on='id', right_on='student_id')
```

#### 여러 컬럼으로 조인
```python
result = pd.merge(df1, df2, on=['id', 'category'], how='inner')
```

#### 접미사 지정
```python
result = pd.merge(df1, df2, on='id', suffixes=('_left', '_right'))
```

---

## 📚 **concat: 데이터프레임 물리적 연결**

### 기본 개념
```python
# 1월 매출 데이터
jan_sales = pd.DataFrame({
    'product': ['A', 'B'],
    'sales': [100, 150]
})

# 2월 매출 데이터
feb_sales = pd.DataFrame({
    'product': ['A', 'B'], 
    'sales': [120, 180]
})

print("1월 매출:")
print(jan_sales)
print("\n2월 매출:")
print(feb_sales)
```

### concat의 2가지 연결 방향

#### 1️⃣ 세로 연결 (axis=0, 기본값)
```python
vertical_concat = pd.concat([jan_sales, feb_sales], ignore_index=True)
print("세로 연결 결과:")
print(vertical_concat)
```
**결과**: 행이 아래로 추가됨 (4행 2열)

#### 2️⃣ 가로 연결 (axis=1)
```python
horizontal_concat = pd.concat([jan_sales, feb_sales], axis=1)
print("가로 연결 결과:")
print(horizontal_concat)
```
**결과**: 컬럼이 옆으로 추가됨 (2행 4열)

### concat 고급 옵션

#### 키(계층) 추가
```python
result = pd.concat([jan_sales, feb_sales], keys=['1월', '2월'])
print("계층 인덱스로 연결:")
print(result)
```

#### 교집합/합집합 설정
```python
# 공통 컬럼만 (교집합)
result = pd.concat([df1, df2], join='inner')

# 모든 컬럼 포함 (합집합, 기본값)
result = pd.concat([df1, df2], join='outer')
```

#### 인덱스 무시
```python
result = pd.concat([df1, df2], ignore_index=True)  # 0, 1, 2, 3... 새로 생성
```

---

## 💡 **언제 뭘 써야 할까?**

### ✅ **merge를 써야 할 때**

#### 1. 관계형 데이터 조인
```python
# 고객정보 + 주문정보
customers = pd.DataFrame({
    'customer_id': [1, 2, 3],
    'name': ['홍길동', '김영희', '박철수']
})

orders = pd.DataFrame({
    'customer_id': [1, 1, 2],
    'product': ['노트북', '마우스', '키보드'],
    'amount': [1200000, 30000, 80000]
})

# 고객별 주문 내역 조인
customer_orders = pd.merge(customers, orders, on='customer_id')
```

#### 2. 마스터-상세 데이터 결합
```python
# 제품마스터 + 가격정보
products = pd.DataFrame({
    'product_code': ['P001', 'P002'],
    'product_name': ['노트북', '키보드']
})

prices = pd.DataFrame({
    'product_code': ['P001', 'P002'],
    'price': [1200000, 80000]
})

product_info = pd.merge(products, prices, on='product_code')
```

### ✅ **concat을 써야 할 때**

#### 1. 같은 구조 데이터 합치기
```python
# 여러 지점 매출 데이터 합치기
seoul_sales = pd.DataFrame({'product': ['A', 'B'], 'sales': [100, 150]})
busan_sales = pd.DataFrame({'product': ['A', 'B'], 'sales': [80, 120]})

total_sales = pd.concat([seoul_sales, busan_sales], ignore_index=True)
```

#### 2. 시계열 데이터 결합
```python
# 월별 데이터를 연간 데이터로
monthly_data = []
for month in range(1, 13):
    month_df = pd.read_csv(f'sales_{month:02d}.csv')
    monthly_data.append(month_df)

yearly_data = pd.concat(monthly_data, ignore_index=True)
```

#### 3. 컬럼 확장
```python
# 기존 데이터에 새로운 특성 추가
original_data = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
new_features = pd.DataFrame({'C': [5, 6], 'D': [7, 8]})

expanded_data = pd.concat([original_data, new_features], axis=1)
```

---

## 🚨 **주의사항 및 흔한 실수**

### ❌ merge 실수들

#### 1. 키 컬럼 없이 merge
```python
# 에러 발생!
# pd.merge(df1, df2)  # on 파라미터 없음
```

#### 2. 키 컬럼 이름 다름
```python
# 해결책: left_on, right_on 사용
result = pd.merge(df1, df2, left_on='id', right_on='student_id')
```

#### 3. 중복 키로 인한 데이터 폭증
```python
# 일대다 관계에서 예상보다 많은 행 생성
# 결과 확인 필수: print(f"원본: {len(df1)} 행, 결과: {len(result)} 행")
```

### ❌ concat 실수들

#### 1. 구조가 다른 데이터 concat
```python
# 문제 상황
df1 = pd.DataFrame({'A': [1, 2]})
df2 = pd.DataFrame({'B': [3, 4]})  # 컬럼명 다름

# 결과: NaN이 많이 생김
result = pd.concat([df1, df2])  # A컬럼에 NaN, B컬럼에 NaN

# 해결책: 컬럼명 통일
df2.columns = ['A']
result = pd.concat([df1, df2])
```

#### 2. 인덱스 중복
```python
# 인덱스가 겹침
df1 = pd.DataFrame({'A': [1, 2]}, index=[0, 1])
df2 = pd.DataFrame({'A': [3, 4]}, index=[0, 1])

# 해결책: ignore_index=True
result = pd.concat([df1, df2], ignore_index=True)
```

---

## 🎯 **실전 예제: 완전한 데이터 파이프라인**

### 시나리오: 온라인 쇼핑몰 분석

```python
# 1. 기본 데이터 로드
customers = pd.DataFrame({
    'customer_id': [1, 2, 3, 4],
    'name': ['김철수', '이영희', '박민수', '정지원'],
    'city': ['서울', '부산', '서울', '대구']
})

orders = pd.DataFrame({
    'order_id': [101, 102, 103, 104, 105],
    'customer_id': [1, 1, 2, 3, 5],  # 5번 고객은 customers에 없음
    'product': ['노트북', '마우스', '키보드', '모니터', '헤드셋'],
    'amount': [1200000, 30000, 80000, 300000, 150000]
})

products = pd.DataFrame({
    'product': ['노트북', '마우스', '키보드', '모니터'],
    'category': ['전자기기', '주변기기', '주변기기', '전자기기'],
    'cost': [900000, 15000, 40000, 200000]
})

# 2. merge로 관계형 조인
# 고객-주문 조인 (고객 정보가 있는 주문만)
customer_orders = pd.merge(customers, orders, on='customer_id', how='inner')
print("고객-주문 조인 결과:")
print(customer_orders)

# 주문-상품 조인 (모든 주문 유지, 상품 정보 추가)
order_details = pd.merge(orders, products, on='product', how='left')
print("\n주문-상품 조인 결과:")
print(order_details)

# 3. concat으로 월별 데이터 합치기
jan_orders = orders[:2]  # 1월 주문
feb_orders = orders[2:]  # 2월 주문

# 월별 라벨 추가하고 합치기
jan_orders_labeled = jan_orders.copy()
jan_orders_labeled['month'] = '1월'

feb_orders_labeled = feb_orders.copy()
feb_orders_labeled['month'] = '2월'

all_orders = pd.concat([jan_orders_labeled, feb_orders_labeled], 
                      ignore_index=True)
print("\n월별 주문 합치기:")
print(all_orders)

# 4. 최종 분석용 데이터 생성
final_analysis = pd.merge(
    pd.merge(customers, orders, on='customer_id', how='inner'),
    products, 
    on='product', 
    how='left'
)

print("\n최종 분석 데이터:")
print(final_analysis)

# 이익률 계산
final_analysis['profit'] = final_analysis['amount'] - final_analysis['cost']
final_analysis['profit_rate'] = (final_analysis['profit'] / 
                                final_analysis['amount'] * 100).round(2)

print("\n이익 분석 추가:")
print(final_analysis[['name', 'product', 'amount', 'profit', 'profit_rate']])
```

---

## 📊 **성능 비교 및 최적화 팁**

### 성능 특성

```python
import time
import pandas as pd
import numpy as np

def performance_test():
    # 큰 데이터셋 생성
    n = 100000
    
    df1 = pd.DataFrame({
        'key': np.random.randint(0, n//10, n),
        'value1': np.random.randn(n)
    })
    
    df2 = pd.DataFrame({
        'key': np.random.randint(0, n//10, n),
        'value2': np.random.randn(n)
    })
    
    # merge 성능 측정
    start = time.time()
    merged = pd.merge(df1, df2, on='key')
    merge_time = time.time() - start
    
    # concat 성능 측정 (세로)
    start = time.time()
    concatenated = pd.concat([df1, df2], ignore_index=True)
    concat_time = time.time() - start
    
    print(f"Merge 시간: {merge_time:.4f}초")
    print(f"Concat 시간: {concat_time:.4f}초")
    print(f"Merge가 {merge_time/concat_time:.2f}배 느림")

# performance_test()
```

### 최적화 팁

#### 1. merge 최적화
```python
# ✅ 인덱스 설정으로 빠르게
df1_indexed = df1.set_index('key')
df2_indexed = df2.set_index('key')
result = pd.merge(df1_indexed, df2_indexed, left_index=True, right_index=True)

# ✅ 정렬된 데이터는 더 빠름
df1_sorted = df1.sort_values('key')
df2_sorted = df2.sort_values('key')
```

#### 2. concat 최적화
```python
# ✅ 리스트로 한 번에
dfs = [df1, df2, df3, df4]
result = pd.concat(dfs, ignore_index=True)

# ❌ 루프에서 반복적으로 concat (매우 느림)
# result = df1
# for df in [df2, df3, df4]:
#     result = pd.concat([result, df])
```

---

## 🎯 **요약: 선택 가이드**

### 🔍 **언제 merge?**
- 📊 **관계형 데이터베이스** 스타일 조인이 필요할 때
- 🔑 **키 컬럼 기준**으로 데이터를 연결해야 할 때  
- 📈 **고객-주문**, **상품-가격** 같은 마스터-상세 관계
- 🎯 **특정 조건**으로 데이터를 필터링하면서 조인

### 📚 **언제 concat?**
- 📁 **같은 구조**의 데이터를 단순히 합칠 때
- 📅 **시계열 데이터** 연결 (월별→연간)
- 📋 **여러 파일**을 하나로 통합
- ➡️ **컬럼 확장** (새로운 특성 추가)

### 🚀 **빠른 결정 체크리스트**
1. **데이터에 공통 키가 있나?** → merge 고려
2. **SQL의 JOIN과 같은 작업?** → merge
3. **단순히 데이터를 쌓거나 옆으로 붙이기?** → concat  
4. **구조가 동일한 여러 데이터?** → concat

---

**🎉 이제 merge와 concat을 완벽하게 구분해서 사용할 수 있습니다!**