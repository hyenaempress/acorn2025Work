# 19.03 마리아DB 연결과 데이터프레임 분석 (실제 코드 버전)

> **강사님**: "마리아 디비를 쓰는 이유는 마리아 디비가 SQL 표준을 따르고 있기 때문입니다!"

## 📋 목차
1. [마리아DB 선택 이유](#마리아db-선택-이유)
2. [실제 연결 및 출력 코드](#실제-연결-및-출력-코드)
3. [세 가지 출력 방법 완전 분석](#세-가지-출력-방법-완전-분석)
4. [CSV 파일 처리](#csv-파일-처리)
5. [pandas 기능 활용](#pandas-기능-활용)
6. [교차표와 시각화](#교차표와-시각화)
7. [실제 코드 전체](#실제-코드-전체)

---

## 마리아DB 선택 이유

**강사님**: "마리아 디비를 쓰는 이유는 마리아 디비가 SQL 표준을 따르고 있기 때문입니다"

### 🎯 핵심 포인트
- **SQL 표준 준수**: 표준 SQL을 완벽하게 지원
- **관계형 데이터베이스**: 모든 관계형 DB의 특징을 갖춤
- **PostgreSQL 비교**: "Postgres 디비도 많이 쓰입니다. 나중에 그것도 설치해서 연결해보는것도 좋습니다"
- **공통점**: "모두 관계형 데이터 베이스입니다"

### 설치 과정
```bash
# 아나콘다 프롬프트에서 실행
pip install MySQLClient

# 강사님: "이후엔 두개의 폴더가 생깁니다"
```

---

## 실제 연결 및 출력 코드

### 기본 설정 및 연결
```python
import MySQLdb
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sys
import pickle
import csv

# 한글 폰트 설정
plt.rc('font', family='malgun gothic')
plt.rcParams['axes.unicode_minus'] = False

# 설정 파일 읽기
try:
    with open('./01_big_data_machine_learning/data/mymaria.dat', 'rb') as obj:
        config = pickle.load(obj)
except Exception as e:
    print("읽기 오류:", e)
    sys.exit()

# 데이터베이스 연결
try:
    conn = MySQLdb.connect(**config)
    cursor = conn.cursor()
    
    # SQL 쿼리 (JOIN 사용)
    sql = """
    select jikwonno, jikwonname, busername, jikwonjik, jikwongen, jikwonpay 
    from jikwon 
    inner join buser on jikwon.busernum=buser.buserno
    """
    
    cursor.execute(sql)
```

---

## 세 가지 출력 방법 완전 분석

### 출력 1: 커서 직접 순회 (콘솔 출력)
```python
print("=== 출력 1: 커서 직접 순회 ===")

# 강사님 코드: 변수명을 의미있게 작성
for(jikwonno, jikwonname, busername, jikwonjik, jikwongen, jikwonpay) in cursor:
    print(jikwonno, jikwonname, busername, jikwonjik, jikwongen, jikwonpay)

# 참고: 간단한 방법도 있음
# for (a, b, c, d, e, f) in cursor:
#     print(a, b, c, d, e, f)
```

**💡 특징**: 
- 메모리 효율적
- 한 번에 하나씩 처리
- 대용량 데이터에 적합

### 출력 2: DataFrame 생성 (수동)
```python
print("\n=== 출력 2: DataFrame 생성 ===")

# ⚠️ 문제: 커서가 이미 소모됨!
# 해결: fetchall() 사용 전에 커서 재실행 필요
cursor.execute(sql)  # 다시 실행

df1 = pd.DataFrame(cursor.fetchall(),
                   columns=['jikwonno', 'jikwonname', 'busername', 'jikwonjik', 'jikwongen', 'jikwonpay'])
print(df1.head(3))
```

**💡 특징**:
- 수동으로 컬럼명 지정
- fetchall()로 모든 데이터 한 번에 가져옴
- pandas 기능 활용 가능

### 출력 3: pandas.read_sql (최고 권장!)
```python
print("\n=== 출력 3: pandas.read_sql (최고!) ===")

df12 = pd.read_sql(sql, conn)
print(df12.head(3))

# 강사님 코멘트: "DB의 자료를 pandas의 sql 처리 기능으로 읽기"
```

**💡 특징**:
- 가장 간편하고 효율적
- 컬럼명 자동 설정
- 한 줄로 완료

---

## CSV 파일 처리

### 1. DataFrame → CSV 저장
```python
print("\n=== CSV 파일 처리 ===")

# 방법 1: csv 모듈 사용
print("강사님: 'with문 써야 close를 안합니다'")
with open('./01_big_data_machine_learning/data/jik_data.csv', mode='w', encoding='utf-8') as fobj:
    writer = csv.writer(fobj)
    
    # 데이터 재조회 (커서 재사용)
    cursor.execute(sql)
    for r in cursor:
        writer.writerow(r)

# 방법 2: DataFrame 직접 저장
df1.to_csv('./01_big_data_machine_learning/data/jikwon.csv', encoding='utf-8', index=False)
print("✅ CSV 파일 저장 완료")
```

### 2. CSV → DataFrame 읽기
```python
# CSV 파일을 DataFrame으로 읽기 (컬럼명 지정)
df2 = pd.read_csv('./01_big_data_machine_learning/data/jik_data.csv', 
                  encoding='utf-8',
                  names=['번호', '이름', '부서', '직급', '성별', '연봉'])
print("CSV에서 읽은 DataFrame:")
print(df2.head(3))
```

---

## pandas 기능 활용

### 최종 DataFrame 준비
```python
print('\n=== DB에 자료를 pandas의 sql 처리 기능으로 읽기 ===')
df = pd.read_sql(sql, conn)
df.columns = ['번호', '이름', '부서', '직급', '성별', '연봉']  # 한글 컬럼명
print(df.head(3))

print("\n강사님: 'DB의 자료를 DataFrame으로 읽었으므로 pandas의 기능을 적용 가능!'")
```

### 기본 통계 분석
```python
print("\n=== pandas 기능 몇개만 적용해봅시다 ===")

# 건수 (두 가지 방법)
print('건수: ', len(df))
print('건수: ', df['이름'].count())

# 연봉 통계
print('연봉 평균: ', df.loc[:, '연봉'].mean())
print('최고 연봉: ', df['연봉'].max())
print('최저 연봉: ', df['연봉'].min())

# 고급 통계 (분산, 표준편차)
print('분산: ', df['연봉'].var())
print('표준편차: ', df['연봉'].std())
```

### 그룹별 분석 (value_counts)
```python
print("\n=== 그룹별 인원 분석 ===")

# 직급별 인원수
print('직급별 인원수:')
print(df['직급'].value_counts())

# 부서별 인원수  
print('\n부서별 인원수:')
print(df['부서'].value_counts())

# 성별 인원수
print('\n성별 인원수:')
print(df['성별'].value_counts())
```

---

## 교차표와 시각화

### 교차표 (crosstab)
```python
print("\n=== 교차표 분석 ===")

# 성별 직급별 건수
ctab = pd.crosstab(df['성별'], df['직급'], margins=True)
print("성별-직급 교차표:")
print(ctab)

# HTML 출력 (웹용)
print("\n강사님: '웹으로 출력하려면 Django를 사용해야 합니다'")
# print(ctab.to_html())  # HTML로 변환 가능
```

### 히스토그램
```python
print("\n=== 연봉 히스토그램 ===")
print("강사님: '연봉이 있으면 히스토그램 그려보죠'")

plt.figure(figsize=(10, 6))
plt.hist(df['연봉'], bins=10, color='green', alpha=0.5)
plt.title('연봉 분포 히스토그램')
plt.xlabel('연봉')
plt.ylabel('빈도')
plt.show()
```

### 막대그래프 시각화
```python
print("\n=== 막대그래프 시각화 ===")

# 직급별 연봉 평균
print("강사님: '시각화 - 직급별 연봉 평균'")
plt.figure(figsize=(10, 6))
df.groupby('직급')['연봉'].mean().plot(kind='bar', rot=0)
plt.title('직급별 연봉 평균')
plt.ylabel('평균 연봉')
plt.show()

# 부서별 연봉 평균
print("강사님: '시각화 - 부서별 연봉 평균'")
plt.figure(figsize=(10, 6))
df.groupby('부서')['연봉'].mean().plot(kind='bar', rot=0)
plt.title('부서별 연봉 평균')
plt.ylabel('평균 연봉')
plt.show()
```

### 파이차트 시각화
```python
print("\n=== 파이차트 시각화 ===")

# 부서별 연봉 평균 파이차트
print("강사님: '시각화 - 부서별 연봉 평균 pie 그래프'")
plt.figure(figsize=(8, 8))
df.groupby('부서')['연봉'].mean().plot(kind='pie', autopct='%.1f%%')
plt.title('부서별 연봉 평균 비율')
plt.ylabel('')
plt.show()

# 고급 파이차트 (직급별 연봉)
print("\n=== 고급 파이차트 (강사님 스타일) ===")
jik_ypay = df.groupby(['직급'])['연봉'].mean()
print('직급별 연봉 평균:\n', jik_ypay)
print('인덱스:', jik_ypay.index)
print('값들:', jik_ypay.values)

plt.figure(figsize=(10, 8))
plt.pie(jik_ypay.values, 
        explode=(0.2, 0, 0, 0.3, 0),    # 조각 분리 효과
        labels=jik_ypay.index,          # 직급명
        shadow=True,                    # 그림자
        labeldistance=0.7,             # 레이블 거리
        counterclock=False)            # 시계 방향
plt.title('직급별 연봉 평균 (고급 스타일)')
plt.show()

# 강사님: "시계 방향으로 그려보죠"
```

---

## 실제 코드 전체

### 🔧 완전한 실행 코드
```python
import MySQLdb
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sys
import pickle
import csv

plt.rc('font', family='malgun gothic')
plt.rcParams['axes.unicode_minus'] = False

try:
    with open('./01_big_data_machine_learning/data/mymaria.dat', 'rb') as obj:
        config = pickle.load(obj)
except Exception as e:
    print("읽기 오류:", e)
    sys.exit()

try:
    conn = MySQLdb.connect(**config)
    cursor = conn.cursor()
    
    sql = """
    select jikwonno, jikwonname, busername, jikwonjik, jikwongen, jikwonpay 
    from jikwon 
    inner join buser on jikwon.busernum=buser.buserno
    """
    
    cursor.execute(sql)
    
    # 출력 1: 커서 직접 순회
    print("=== 출력 1: 콘솔 출력 ===")
    for(jikwonno, jikwonname, busername, jikwonjik, jikwongen, jikwonpay) in cursor:
        print(jikwonno, jikwonname, busername, jikwonjik, jikwongen, jikwonpay)
    
    # 출력 2: DataFrame 생성 (수동)
    cursor.execute(sql)  # 커서 재실행
    df1 = pd.DataFrame(cursor.fetchall(),
                       columns=['jikwonno', 'jikwonname', 'busername', 
                               'jikwonjik', 'jikwongen', 'jikwonpay'])
    print("\n=== 출력 2: DataFrame ===")
    print(df1.head(3))
    
    # 출력 3: pandas.read_sql (최고 권장)
    df12 = pd.read_sql(sql, conn)
    print("\n=== 출력 3: pandas.read_sql ===")
    print(df12.head(3))
    
    # CSV 파일 저장
    with open('./01_big_data_machine_learning/data/jik_data.csv', mode='w', encoding='utf-8') as fobj:
        writer = csv.writer(fobj)
        cursor.execute(sql)
        for r in cursor:
            writer.writerow(r)
    
    df1.to_csv('./01_big_data_machine_learning/data/jikwon.csv', encoding='utf-8', index=False)
    
    # CSV 파일 읽기
    df2 = pd.read_csv('./01_big_data_machine_learning/data/jik_data.csv', 
                      encoding='utf-8', 
                      names=['번호', '이름', '부서', '직급', '성별', '연봉'])
    print("\n=== CSV에서 읽은 데이터 ===")
    print(df2.head(3))
    
    # 최종 분석용 DataFrame
    print('\n=== DB의 자료를 pandas의 sql 처리 기능으로 읽기 ===')
    df = pd.read_sql(sql, conn)
    df.columns = ['번호', '이름', '부서', '직급', '성별', '연봉']
    print(df.head(3))
    
    print("\n=== pandas 기능 적용 ===")
    print('건수: ', len(df))
    print('건수: ', df['이름'].count())
    print('직급별 인원수:', df['직급'].value_counts())
    print('연봉 평균: ', df.loc[:, '연봉'].mean())
    print('분산: ', df['연봉'].var())
    print('표준편차: ', df['연봉'].std())
    
    # 교차표
    ctab = pd.crosstab(df['성별'], df['직급'], margins=True)
    print("\n=== 성별-직급 교차표 ===")
    print(ctab)
    
    # 시각화
    print("\n=== 시각화 시작 ===")
    
    # 히스토그램
    plt.figure(figsize=(12, 8))
    plt.subplot(2, 2, 1)
    plt.hist(df['연봉'], bins=10, color='green', alpha=0.5)
    plt.title('연봉 분포')
    
    # 직급별 연봉 평균
    plt.subplot(2, 2, 2)
    df.groupby('직급')['연봉'].mean().plot(kind='bar', rot=0)
    plt.title('직급별 연봉 평균')
    
    # 부서별 연봉 평균
    plt.subplot(2, 2, 3)
    df.groupby('부서')['연봉'].mean().plot(kind='bar', rot=0)
    plt.title('부서별 연봉 평균')
    
    # 파이차트
    plt.subplot(2, 2, 4)
    jik_ypay = df.groupby(['직급'])['연봉'].mean()
    plt.pie(jik_ypay.values, 
            explode=(0.2, 0, 0, 0.3, 0),
            labels=jik_ypay.index,
            shadow=True,
            labeldistance=0.7,
            counterclock=False)
    plt.title('직급별 연봉 비율')
    
    plt.tight_layout()
    plt.show()

except Exception as e:
    print("SQL 실행 오류:", e)
    
finally:
    if 'conn' in locals():
        conn.close()
    print("연결 종료")
```

---

## 💡 핵심 정리

### ✅ 강사님이 강조한 핵심 포인트들

1. **세 가지 출력 방법 마스터**
   - 콘솔 출력: 디버깅용
   - DataFrame 수동 생성: 제어가 필요할 때
   - **pandas.read_sql(): 최고 권장!**

2. **with문의 중요성**
   - "with문 써야 close를 안합니다"
   - 자동 리소스 관리

3. **커서 재사용 주의**
   - 한 번 사용한 커서는 재실행 필요
   - `cursor.execute(sql)` 다시 호출

4. **pandas 기능의 강력함**
   - "pandas의 기능을 적용 가능!"
   - value_counts, groupby, 통계 함수들

5. **웹 출력 가능성**
   - "웹으로 출력하려면 Django 사용"
   - to_html() 메서드 활용

6. **시각화의 다양성**
   - 히스토그램, 막대그래프, 파이차트
   - explode, shadow 등 고급 옵션

### 🚀 실무 활용도

이 코드 패턴은 **실무에서 매일 사용**하는 핵심 기술입니다:
- **ETL 파이프라인**: DB → DataFrame → 분석 → 시각화
- **정기 리포트**: 자동화된 분석 및 차트 생성
- **대시보드**: 실시간 데이터 모니터링
- **의사결정 지원**: 데이터 기반 인사이트

**강사님**: "모두 관계형 데이터베이스입니다. SQL 표준을 따르고 있기 때문에 어떤 DB든 비슷하게 활용할 수 있어요!" 🎯