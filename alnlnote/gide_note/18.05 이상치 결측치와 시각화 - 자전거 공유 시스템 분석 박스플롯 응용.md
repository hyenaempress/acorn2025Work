# 18.05 이상치 결측치와 시각화 - 자전거 공유 시스템 분석

## 🚴 워싱턴 D.C 자전거 공유 시스템 데이터 분석

이번 실습에서는 **자전거 공유 시스템(Bike Sharing) 데이터**를 활용하여 이상치와 결측치 처리 방법을 시각화와 함께 학습합니다. 리니어 리그레션 분석을 위한 전처리 과정도 포함됩니다.

---

## 🔧 기본 설정 및 데이터 로드

### 라이브러리 import 및 설정
```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 한글 폰트 설정
plt.rc('font', family='Malgun Gothic')
plt.rcParams['axes.unicode_minus'] = False

# matplotlib 스타일 설정 (ggplot 스타일)
plt.style.use('ggplot')

# 전체 컬럼 표시 설정
pd.set_option('display.max_columns', 500)
```

### 자전거 공유 시스템 데이터 로드
```python
# 워싱턴 D.C 자전거 공유 시스템 데이터 로드
train = pd.read_csv('https://raw.githubusercontent.com/pykwon/python/refs/heads/master/data/train.csv', 
                   parse_dates=['datetime'])

print("🚴 자전거 공유 시스템 데이터 기본 정보")
print(f"데이터 크기: {train.shape}")
print(f"컬럼명: {list(train.columns)}")
print("\n데이터 타입 정보:")
print(train.info())
print("\n상위 3개 데이터:")
print(train.head(3))
```

### 데이터 구조 파악
```python
# 전체적인 요약 통계량 확인
print("📊 기술 통계량:")
print(train.describe())

# 온도 데이터 확인
print("\n🌡️ 온도 데이터 샘플:")
print(train.temp.head(3))
```

---

## 🔍 결측치 분석 및 시각화

### 1. 기본 결측치 확인
```python
# 결측치 확인
print("❌ 결측치 현황:")
missing_data = train.isnull().sum()
print(missing_data)

# 결측치 비율 계산
missing_ratio = (train.isnull().sum() / len(train)) * 100
print("\n결측치 비율(%):")
print(missing_ratio[missing_ratio > 0])  # 결측치가 있는 컬럼만 표시
```

### 2. missingno 라이브러리를 활용한 시각화 (선생님 추천!)
```python
# 선생님이 직접 설치하신 missingno 라이브러리 활용
# 설치: conda install missingno 또는 pip install missingno

try:
    import missingno as msno
    
    # 결측치 매트릭스 시각화
    msno.matrix(train, figsize=(12, 5))
    plt.title('결측치 분포 매트릭스 - 한눈에 보는 결측치 패턴')
    plt.show()
    
    # 결측치 막대 그래프
    msno.bar(train)
    plt.title('컬럼별 결측치 개수')
    plt.show()
    
    print("✅ missingno 라이브러리로 결측치 시각화 완료!")
    print("💡 선생님 말씀: '결측치 확인용 시각화 모듈이 따로 있어요!'")
    
except ImportError:
    print("⚠️ missingno 라이브러리가 설치되지 않았습니다.")
    print("📝 설치 방법: conda install missingno")
    print("💡 대신 Seaborn의 히트맵으로 결측치를 확인해보겠습니다.")
```

### 3. Seaborn을 활용한 결측치 시각화
```python
# 결측치 히트맵 생성
plt.figure(figsize=(12, 6))
sns.heatmap(train.isnull(), 
            yticklabels=False, 
            cbar=True, 
            cmap='viridis')
plt.title('결측치 분포 히트맵')
plt.show()

# 결측치가 있는 행의 비율
missing_rows = train.isnull().any(axis=1).sum()
print(f"결측치가 포함된 행의 수: {missing_rows}")
print(f"전체 데이터 중 결측치 포함 비율: {missing_rows/len(train)*100:.2f}%")
```

---

## 📅 시간 데이터 전처리 및 시각화

### 날짜/시간 컬럼 생성
```python
# datetime 컬럼에서 연, 월, 일, 시간 추출
train['year'] = train['datetime'].dt.year
train['month'] = train['datetime'].dt.month
train['day'] = train['datetime'].dt.day
train['hour'] = train['datetime'].dt.hour
train['minute'] = train['datetime'].dt.minute
train['second'] = train['datetime'].dt.second

print("📅 생성된 시간 컬럼들:")
print(train.columns.tolist())
print("\n시간 데이터 샘플:")
print(train[['datetime', 'year', 'month', 'day', 'hour']].head(1))
```

### 시간별 자전거 대여량 시각화
```python
# 객체지향적 방법으로 서브플롯 생성
figure, (ax1, ax2, ax3, ax4) = plt.subplots(nrows=1, ncols=4, figsize=(15, 5))

# 연도별 대여량
sns.barplot(x='year', y='count', data=train, ax=ax1)
ax1.set(ylabel='대여 건수', title='연도별 자전거 대여량')

# 월별 대여량
sns.barplot(x='month', y='count', data=train, ax=ax2)
ax2.set(ylabel='대여 건수', title='월별 자전거 대여량')

# 일별 대여량
sns.barplot(x='day', y='count', data=train, ax=ax3)
ax3.set(ylabel='대여 건수', title='일별 자전거 대여량')

# 시간별 대여량
sns.barplot(x='hour', y='count', data=train, ax=ax4)
ax4.set(ylabel='대여 건수', title='시간별 자전거 대여량')

plt.tight_layout()
plt.show()
```

---

## 🎯 선생님이 강조하신 박스플롯의 중요성

### "박스플롯은 데이터 분석하는 사람들에게 정말 중요한 녀석이다"

선생님께서 강의에서 특별히 강조하신 박스플롯의 핵심 개념과 실무 활용법을 정리해보겠습니다.

#### 📊 박스플롯 구조 완벽 이해
```python
# 선생님 설명 그대로!
"""
박스플롯 구조 해석:
📍 중앙선(Q2): 데이터의 정중앙 - 중앙값 (median)
📍 상자 하단(Q1): 1사분위수 (25% 지점) 
📍 상자 상단(Q3): 3사분위수 (75% 지점)
📍 Q1~Q3 범위: IQR (Interquartile Range) - 사분위 범위
📍 위스커(수염): IQR × 1.5배 정도까지 연장
📍 위스커 밖 점들: 아웃라이어(이상치) 후보
"""

# 실제 예제로 확인
sample_data = [10, 12, 15, 18, 20, 22, 25, 28, 30, 100]  # 100이 이상치

plt.figure(figsize=(10, 6))
plt.boxplot(sample_data, vert=True)
plt.title('박스플롯으로 이상치 탐지하기')
plt.ylabel('값')

# 통계값 표시
Q1 = np.percentile(sample_data, 25)
Q2 = np.percentile(sample_data, 50)  # 중앙값
Q3 = np.percentile(sample_data, 75)
IQR = Q3 - Q1

plt.text(1.1, Q1, f'Q1: {Q1}', fontsize=10)
plt.text(1.1, Q2, f'Q2 (중앙값): {Q2}', fontsize=10, weight='bold')
plt.text(1.1, Q3, f'Q3: {Q3}', fontsize=10)
plt.text(1.1, Q3 + 5, f'IQR: {IQR}', fontsize=10, color='red')

plt.show()

print("📊 박스플롯 통계 요약:")
print(f"Q1 (25%): {Q1}")
print(f"Q2 (중앙값): {Q2}")  
print(f"Q3 (75%): {Q3}")
print(f"IQR: {IQR}")
print(f"이상치 경계: {Q3 + 1.5*IQR} 이상 또는 {Q1 - 1.5*IQR} 이하")
```

#### 🚨 이상치 vs 정상 데이터 구분하기

선생님께서 말씀하신 중요한 개념을 코드로 구현해보겠습니다.

```python
print("🎯 선생님 예시: '시험 점수에서 200점이나 마이너스 300점?'")
print("❌ 이런 건 명백한 입력 오류 - 제거해야 할 이상치")
print()

# 시험 점수 예제 (0~100점 범위)
시험점수 = [85, 92, 78, 88, 91, 200, 76, 84, 89, -50, 93, 87]  # 200, -50이 이상치

print("🎯 선생님 예시: '회사 연봉에서 갑자기 3억?'")  
print("❓ 이건 진짜 고액 연봉일 수도 있음 - 신중한 판단 필요")
print()

# 연봉 예제 (단위: 만원)
연봉데이터 = [3000, 3200, 2800, 3100, 30000, 3300, 2900, 3050]  # 30000(3억)이 이상치?

def 이상치_판단_가이드(데이터, 컨텍스트=""):
    """선생님 방식의 이상치 판단 가이드"""
    
    Q1 = np.percentile(데이터, 25)
    Q3 = np.percentile(데이터, 75)
    IQR = Q3 - Q1
    
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    
    이상치들 = [x for x in 데이터 if x < lower_bound or x > upper_bound]
    
    print(f"📊 {컨텍스트} 이상치 분석:")
    print(f"   정상 범위: {lower_bound:.0f} ~ {upper_bound:.0f}")
    print(f"   이상치 후보: {이상치들}")
    
    for 값 in 이상치들:
        if 컨텍스트 == "시험점수" and (값 < 0 or 값 > 100):
            print(f"   ❌ {값}: 명백한 오류 데이터 - 제거 권장")
        elif 컨텍스트 == "연봉":
            print(f"   ❓ {값}: 실제 고액/저액 연봉일 가능성 - 검토 필요")
        else:
            print(f"   ⚠️ {값}: 도메인 지식으로 판단 필요")
    
    return 이상치들

# 분석 실행
이상치_판단_가이드(시험점수, "시험점수")
print()
이상치_판단_가이드(연봉데이터, "연봉")
```

#### 🛠️ 실무 이상치 처리 전략

```python
print("🎯 선생님 강조: '박스플롯으로 확인하고 바깥에 있는 녀석들은 이상치로 잘라버리는 게 좋다'")

def 실무_이상치_처리_파이프라인(데이터, 데이터명, 처리방법='제거'):
    """선생님 방식의 실무 이상치 처리"""
    
    print(f"🔧 {데이터명} 이상치 처리 파이프라인 시작")
    print("="*50)
    
    # 1. 원본 데이터 요약
    print(f"📊 원본 데이터: {len(데이터)}개")
    print(f"   평균: {np.mean(데이터):.2f}")
    print(f"   표준편차: {np.std(데이터):.2f}")
    
    # 2. 박스플롯으로 시각적 확인
    plt.figure(figsize=(12, 5))
    plt.subplot(1, 2, 1)
    plt.boxplot(데이터, vert=True)
    plt.title(f'{데이터명} - 원본 (이상치 포함)')
    plt.ylabel('값')
    
    # 3. IQR 방법으로 이상치 탐지
    Q1 = np.percentile(데이터, 25)
    Q3 = np.percentile(데이터, 75)
    IQR = Q3 - Q1
    
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    
    이상치_인덱스 = [i for i, x in enumerate(데이터) if x < lower_bound or x > upper_bound]
    이상치_값들 = [데이터[i] for i in 이상치_인덱스]
    
    print(f"📈 이상치 탐지 결과:")
    print(f"   정상 범위: {lower_bound:.2f} ~ {upper_bound:.2f}")
    print(f"   이상치 개수: {len(이상치_값들)}개")
    print(f"   이상치 비율: {len(이상치_값들)/len(데이터)*100:.1f}%")
    print(f"   이상치 값들: {이상치_값들}")
    
    # 4. 처리 방법에 따른 데이터 정제
    if 처리방법 == '제거':
        정제된_데이터 = [x for x in 데이터 if lower_bound <= x <= upper_bound]
        print(f"✂️ 이상치 제거 완료: {len(데이터)}개 → {len(정제된_데이터)}개")
        
    elif 처리방법 == '경계값치환':
        정제된_데이터 = 데이터.copy()
        for i in range(len(정제된_데이터)):
            if 정제된_데이터[i] > upper_bound:
                정제된_데이터[i] = upper_bound
            elif 정제된_데이터[i] < lower_bound:
                정제된_데이터[i] = lower_bound
        print(f"🔧 경계값 치환 완료")
    
    # 5. 처리 후 박스플롯
    plt.subplot(1, 2, 2)
    plt.boxplot(정제된_데이터, vert=True)
    plt.title(f'{데이터명} - 처리 후 (깔끔한 데이터)')
    plt.ylabel('값')
    
    plt.tight_layout()
    plt.show()
    
    # 6. 처리 결과 요약
    print(f"📊 처리 후 데이터: {len(정제된_데이터)}개")
    print(f"   평균: {np.mean(정제된_데이터):.2f}")
    print(f"   표준편차: {np.std(정제된_데이터):.2f}")
    print()
    print("💡 선생님 말씀: '착한 데이터로 만들어야 좋은 결과를 얻을 수 있다!'")
    
    return 정제된_데이터, 이상치_값들

# 실제 자전거 데이터에 적용
정제된_대여량, 대여량_이상치 = 실무_이상치_처리_파이프라인(
    train['count'].tolist(), 
    "자전거 대여량",
    '제거'
)
```

### 1. 시간별 대여량 분포 분석
```python
# BoxPlot으로 시간별 자전거 대여량 분포 확인
figure, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))

# 시간별 박스플롯 (동일한 데이터로 두 개 생성)
sns.boxplot(x='hour', y='count', data=train, ax=ax1)
ax1.set(ylabel='대여 건수', title='시간별 자전거 대여량 분포')
ax1.tick_params(axis='x', rotation=45)  # x축 레이블 회전

sns.boxplot(x='hour', y='count', data=train, ax=ax2)
ax2.set(ylabel='대여 건수', title='시간별 자전거 대여량 분포 (복사)')
ax2.tick_params(axis='x', rotation=45)

plt.tight_layout()
plt.show()

print("📊 BoxPlot 해석:")
print("- 상자 중앙선: 중앙값(median)")
print("- 상자 하단: 1사분위수(Q1, 25%)")
print("- 상자 상단: 3사분위수(Q3, 75%)")
print("- 수염: 최솟값/최댓값 (이상치 제외)")
print("- 점들: 이상치(outliers)")
```

### 2. 다양한 범주별 BoxPlot 분석
```python
# 선생님 스타일: 2행 2열 직접 지정 방법
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 8))

# 계절별 대여량
sns.boxplot(data=train, y='count', x='season', orient='v', ax=axes[0][0])
axes[0][0].set(ylabel='대여 건수', title='계절별 대여량')

# 시간별 대여량
sns.boxplot(data=train, y='count', x='hour', orient='v', ax=axes[0][1])
axes[0][1].set(ylabel='대여 건수', title='시간별 대여량')
axes[0][1].tick_params(axis='x', rotation=45)

# 근무일 여부에 따른 대여량
sns.boxplot(data=train, y='count', x='workingday', orient='v', ax=axes[1][0])
axes[1][0].set(ylabel='대여 건수', title='근무일 여부에 따른 대여량')

# 연도별 대여량
sns.boxplot(data=train, y='count', x='year', orient='v', ax=axes[1][1])
axes[1][1].set(ylabel='대여 건수', title='연도별 대여량')

plt.tight_layout()
plt.show()
```

---

## 🔢 통계적 이상치 탐지 방법

### 1. Z-Score를 활용한 이상치 탐지
```python
# Z-Score 계산 (표준화)
train['count_zscore'] = (train['count'] - train['count'].mean()) / train['count'].std()

# Z-Score가 ±3을 넘는 이상치 찾기
outliers_zscore = train[abs(train['count_zscore']) > 3]

print("📈 Z-Score 기반 이상치 탐지:")
print(f"전체 데이터 수: {len(train)}")
print(f"이상치 개수: {len(outliers_zscore)}")
print(f"이상치 비율: {len(outliers_zscore)/len(train)*100:.2f}%")

# 이상치 데이터 확인
print("\n이상치 샘플:")
print(outliers_zscore[['datetime', 'hour', 'temp', 'count', 'count_zscore']].head())
```

### 2. IQR 방법을 활용한 이상치 탐지
```python
# IQR(Interquartile Range) 계산
Q1 = train['count'].quantile(0.25)
Q3 = train['count'].quantile(0.75)
IQR = Q3 - Q1

# 이상치 경계값 설정
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# 이상치 찾기
outliers_iqr = train[(train['count'] < lower_bound) | (train['count'] > upper_bound)]

print("📊 IQR 기반 이상치 탐지:")
print(f"Q1 (25%): {Q1:.0f}")
print(f"Q3 (75%): {Q3:.0f}")
print(f"IQR: {IQR:.0f}")
print(f"정상 범위: {lower_bound:.0f} ~ {upper_bound:.0f}")
print(f"이상치 개수: {len(outliers_iqr)}")
print(f"이상치 비율: {len(outliers_iqr)/len(train)*100:.2f}%")
```

### 3. 이상치 시각화
```python
# 이상치 시각화
fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# 1. 히스토그램
train['count'].hist(bins=50, ax=axes[0])
axes[0].axvline(lower_bound, color='red', linestyle='--', label=f'하한: {lower_bound:.0f}')
axes[0].axvline(upper_bound, color='red', linestyle='--', label=f'상한: {upper_bound:.0f}')
axes[0].set_title('대여량 분포 및 이상치 경계')
axes[0].legend()

# 2. 박스플롯
sns.boxplot(y='count', data=train, ax=axes[1])
axes[1].set_title('대여량 박스플롯')

# 3. 산점도 (시간 vs 대여량)
axes[2].scatter(train['hour'], train['count'], alpha=0.5, label='정상 데이터')
axes[2].scatter(outliers_iqr['hour'], outliers_iqr['count'], 
                color='red', alpha=0.7, label='이상치')
axes[2].set_xlabel('시간')
axes[2].set_ylabel('대여량')
axes[2].set_title('시간별 대여량 및 이상치')
axes[2].legend()

plt.tight_layout()
plt.show()
```

---

## 🛠️ 이상치 처리 방법

### 1. 이상치 제거
```python
# 이상치 제거된 데이터셋 생성
train_no_outliers = train[(train['count'] >= lower_bound) & (train['count'] <= upper_bound)]

print("🧹 이상치 제거 결과:")
print(f"원본 데이터 크기: {train.shape}")
print(f"이상치 제거 후: {train_no_outliers.shape}")
print(f"제거된 데이터: {len(train) - len(train_no_outliers)}개")
```

### 2. 이상치 변환 (Capping)
```python
# 경계값으로 치환 (Capping)
train_capped = train.copy()
train_capped.loc[train_capped['count'] > upper_bound, 'count'] = upper_bound
train_capped.loc[train_capped['count'] < lower_bound, 'count'] = lower_bound

print("🔧 경계값 치환(Capping) 결과:")
print(f"원본 최대값: {train['count'].max()}")
print(f"치환 후 최대값: {train_capped['count'].max()}")
print(f"상한 경계값: {upper_bound}")
```

### 3. 로그 변환
```python
# 로그 변환으로 이상치 완화
train['count_log'] = np.log1p(train['count'])  # log1p = log(1+x), 0값 문제 해결

# 변환 전후 비교 시각화
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# 원본 데이터
train['count'].hist(bins=50, ax=axes[0])
axes[0].set_title('원본 대여량 분포')
axes[0].set_xlabel('대여량')

# 로그 변환 후
train['count_log'].hist(bins=50, ax=axes[1])
axes[1].set_title('로그 변환 후 분포')
axes[1].set_xlabel('log(대여량)')

plt.tight_layout()
plt.show()

print("📊 로그 변환 효과:")
print(f"원본 왜도(skewness): {train['count'].skew():.3f}")
print(f"변환 후 왜도: {train['count_log'].skew():.3f}")
print("* 왜도가 0에 가까울수록 정규분포에 가까움")
```

---

## 🌡️ 온도와 대여량 관계 분석 (리니어 리그레션 준비)

### 1. 온도 데이터 전처리
```python
# 온도 데이터 확인
print("🌡️ 온도 데이터 분석:")
print(f"온도 범위: {train['temp'].min():.2f} ~ {train['temp'].max():.2f}")
print(f"평균 온도: {train['temp'].mean():.2f}")
print(f"온도 결측치: {train['temp'].isnull().sum()}개")

# 온도 이상치 확인
temp_Q1 = train['temp'].quantile(0.25)
temp_Q3 = train['temp'].quantile(0.75)
temp_IQR = temp_Q3 - temp_Q1
temp_lower = temp_Q1 - 1.5 * temp_IQR
temp_upper = temp_Q3 + 1.5 * temp_IQR

temp_outliers = train[(train['temp'] < temp_lower) | (train['temp'] > temp_upper)]
print(f"온도 이상치 개수: {len(temp_outliers)}")
```

### 2. 온도-대여량 상관관계 시각화
```python
# 온도와 대여량의 관계 분석
fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# 1. 산점도
axes[0,0].scatter(train['temp'], train['count'], alpha=0.5)
axes[0,0].set_xlabel('온도')
axes[0,0].set_ylabel('대여량')
axes[0,0].set_title('온도 vs 대여량 산점도')

# 2. 회귀선 포함 산점도 (seaborn)
sns.regplot(data=train, x='temp', y='count', ax=axes[0,1])
axes[0,1].set_title('온도 vs 대여량 (회귀선 포함)')

# 3. 온도 히스토그램
train['temp'].hist(bins=30, ax=axes[1,0])
axes[1,0].set_xlabel('온도')
axes[1,0].set_title('온도 분포')

# 4. 대여량 히스토그램
train['count'].hist(bins=30, ax=axes[1,1])
axes[1,1].set_xlabel('대여량')
axes[1,1].set_title('대여량 분포')

plt.tight_layout()
plt.show()

# 상관계수 계산
correlation = train['temp'].corr(train['count'])
print(f"🔗 온도-대여량 상관계수: {correlation:.3f}")
```

### 3. 계절별 온도-대여량 관계
```python
# 계절별 분석
seasons = {1: '봄', 2: '여름', 3: '가을', 4: '겨울'}
train['season_name'] = train['season'].map(seasons)

# 계절별 온도-대여량 관계
plt.figure(figsize=(12, 8))
for season_num, season_name in seasons.items():
    season_data = train[train['season'] == season_num]
    plt.scatter(season_data['temp'], season_data['count'], 
               label=season_name, alpha=0.6)

plt.xlabel('온도')
plt.ylabel('대여량')
plt.title('계절별 온도-대여량 관계')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# 계절별 상관계수
print("📊 계절별 온도-대여량 상관계수:")
for season_num, season_name in seasons.items():
    season_data = train[train['season'] == season_num]
    corr = season_data['temp'].corr(season_data['count'])
    print(f"{season_name}: {corr:.3f}")
```

---

## 🚴 시간대별 심화 분석

### 1. 출퇴근 시간대 분석
```python
# 시간대 카테고리 생성
def categorize_time(hour):
    if 6 <= hour <= 9:
        return '출근시간'
    elif 10 <= hour <= 16:
        return '오전~오후'
    elif 17 <= hour <= 20:
        return '퇴근시간'
    else:
        return '야간/새벽'

train['time_category'] = train['hour'].apply(categorize_time)

# 시간대별 평균 대여량
time_avg = train.groupby('time_category')['count'].agg(['mean', 'std', 'count'])
print("⏰ 시간대별 대여량 통계:")
print(time_avg)

# 시간대별 박스플롯
plt.figure(figsize=(10, 6))
sns.boxplot(data=train, x='time_category', y='count')
plt.title('시간대별 자전거 대여량 분포')
plt.xticks(rotation=45)
plt.show()
```

### 2. 근무일/휴일 패턴 분석
```python
# 근무일 여부별 시간대 패턴
fig, axes = plt.subplots(1, 2, figsize=(15, 5))

# 근무일 패턴
workday_data = train[train['workingday'] == 1]
workday_hourly = workday_data.groupby('hour')['count'].mean()
axes[0].plot(workday_hourly.index, workday_hourly.values, 'b-o', linewidth=2)
axes[0].set_title('근무일 시간별 평균 대여량')
axes[0].set_xlabel('시간')
axes[0].set_ylabel('평균 대여량')
axes[0].grid(True, alpha=0.3)

# 휴일 패턴
holiday_data = train[train['workingday'] == 0]
holiday_hourly = holiday_data.groupby('hour')['count'].mean()
axes[1].plot(holiday_hourly.index, holiday_hourly.values, 'r-o', linewidth=2)
axes[1].set_title('휴일 시간별 평균 대여량')
axes[1].set_xlabel('시간')
axes[1].set_ylabel('평균 대여량')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("📈 근무일 vs 휴일 패턴 차이:")
print(f"근무일 최대 시간: {workday_hourly.idxmax()}시 ({workday_hourly.max():.0f}건)")
print(f"휴일 최대 시간: {holiday_hourly.idxmax()}시 ({holiday_hourly.max():.0f}건)")
```

---

## 📋 실제 강의 재현: 워싱턴 D.C 자전거 데이터 분석

### 선생님이 실제로 진행하신 분석 과정 그대로 따라하기

#### 🌐 데이터 출처 및 배경
```python
print("🚴 워싱턴 D.C 자전거 공유 시스템 (Bike Sharing)")
print("📅 2011년 데이터 사용")
print("🔗 출처: 캐글 바이크 셰어링 데이터셋")
print("📊 선생님: '따릉이 데이터 같은 건데 다른 나라 버전이야'")
print()

# 선생님이 설명하신 컬럼들
컬럼_설명 = {
    'datetime': '연월일시 정보',
    'season': '계절 (1:봄, 2:여름, 3:가을, 4:겨울)',
    'holiday': '공휴일 여부 (0:평일, 1:공휴일)', 
    'workingday': '근무일 여부 (0:휴일, 1:근무일)',
    'weather': '날씨 (1:맑음, 2:안개, 3:비/눈, 4:심한날씨)',
    'temp': '섭씨 온도',
    'atemp': '체감 온도', 
    'humidity': '습도',
    'windspeed': '풍속',
    'registered': '정식 회원 대여량',
    'casual': '비회원 대여량',
    'count': '총 대여량'
}

print("📋 데이터 컬럼 설명:")
for 컬럼명, 설명 in 컬럼_설명.items():
    print(f"   {컬럼명}: {설명}")
```

#### 📊 판다스 디스플레이 옵션 조정 (선생님 팁!)
```python
print("🔧 선생님이 실제로 사용하신 판다스 설정:")
print("'점점점하고 나와 있네요. 그거를 늘려볼 수 있는데...'")

# 선생님이 실제로 설정하신 옵션
pd.set_option('display.max_columns', 500)
print("✅ pd.set_option('display.max_columns', 500) 설정 완료")
print("💡 이제 모든 컬럼이 생략되지 않고 보입니다!")

# 추가 유용한 옵션들
pd.set_option('display.width', 1000)
pd.set_option('display.max_colwidth', 100)
print("✅ 추가 디스플레이 옵션 설정 완료")
```

#### 🕒 날짜 시간 데이터 처리 (선생님 방식)
```python
print("📅 선생님이 강조하신 날짜 처리의 중요성:")
print("'이게 지금 문자입니다. 연도별 월별 일별 시별 하고 싶은데 문자열이야'")
print("'타입을 전환해서 바꿔도 되고 아예 부를 때 바꿀 수 있다'")
print()

# 방법 1: 읽을 때 바로 변환 (선생님 추천 방법)
print("🎯 선생님 방법: 읽을 때 바로 parse_dates 옵션 사용")
print("train = pd.read_csv(url, parse_dates=['datetime'])")
print()

# 방법 2: 읽은 후 변환
print("🔄 읽은 후 변환하는 방법:")
print("train['datetime'] = pd.to_datetime(train['datetime'])")
print()

# 실제로 datetime 컬럼에서 연월일시 추출
if 'train' in locals() and 'datetime' in train.columns:
    print("🔧 datetime에서 연월일시 추출 중...")
    
    # 선생님이 실제로 만드신 컬럼들
    train['year'] = train['datetime'].dt.year
    train['month'] = train['datetime'].dt.month  
    train['day'] = train['datetime'].dt.day
    train['hour'] = train['datetime'].dt.hour
    train['minute'] = train['datetime'].dt.minute
    train['second'] = train['datetime'].dt.second
    
    print("✅ 연월일시 컬럼 생성 완료!")
    print(f"📊 컬럼 수 변화: 기존 → 현재 (6개 컬럼 추가)")
    
    # 생성된 컬럼 확인
    시간_컬럼들 = ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second']
    print("\n🕐 생성된 시간 관련 컬럼들:")
    print(train[시간_컬럼들].head(1))
    
else:
    print("⚠️ 데이터가 로드되지 않았습니다. 위의 데이터 로딩 섹션을 확인해주세요.")
```

#### 📈 리니어 리그레션 준비 과정
```python
print("🎯 선생님 예고: '요거 가지고 우리가 이제 리니어 리그레션 연습할 때 많이 써먹는데'")
print("📚 현재는 시각화 연습 단계, 나중에 머신러닝에서 활용 예정")
print()

# 온도와 대여량의 기본적인 관계 확인
if 'train' in locals():
    온도_대여량_상관계수 = train['temp'].corr(train['count'])
    print(f"🌡️ 온도-대여량 상관계수: {온도_대여량_상관계수:.3f}")
    
    if 온도_대여량_상관계수 > 0.5:
        print("✅ 양의 상관관계: 온도가 높을수록 대여량 증가 경향")
    elif 온도_대여량_상관계수 < -0.5:
        print("❄️ 음의 상관관계: 온도가 높을수록 대여량 감소 경향") 
    else:
        print("➖ 약한 상관관계: 온도와 대여량의 직접적 관계는 약함")
        
    print("🔮 리니어 리그레션에서 이 관계를 더 정밀하게 분석할 예정!")
```

#### 🎨 ggplot 스타일 적용 (선생님 선호!)
```python
print("🎨 선생님이 적용하신 ggplot 스타일:")
print("plt.style.use('ggplot')")
print("💡 R의 ggplot과 비슷한 깔끔한 스타일!")

# 실제 적용
plt.style.use('ggplot')
print("✅ ggplot 스타일 적용 완료!")

# 스타일 확인용 간단한 차트
plt.figure(figsize=(8, 4))
plt.plot([1, 2, 3, 4], [1, 4, 2, 3], 'o-', linewidth=2, markersize=8)
plt.title('ggplot 스타일 확인')
plt.xlabel('X축')
plt.ylabel('Y축')
plt.grid(True, alpha=0.3)
plt.show()
```

---

## 📊 종합 대시보드 시각화

### 전체 데이터 요약 대시보드
```python
# 종합 대시보드 생성
fig = plt.figure(figsize=(20, 15))

# 1. 시간별 대여량 (라인 차트)
plt.subplot(3, 3, 1)
hourly_avg = train.groupby('hour')['count'].mean()
plt.plot(hourly_avg.index, hourly_avg.values, 'b-o', linewidth=2)
plt.title('시간별 평균 대여량')
plt.xlabel('시간')
plt.ylabel('대여량')
plt.grid(True, alpha=0.3)

# 2. 월별 대여량 (막대 차트)
plt.subplot(3, 3, 2)
monthly_avg = train.groupby('month')['count'].mean()
plt.bar(monthly_avg.index, monthly_avg.values, color='skyblue')
plt.title('월별 평균 대여량')
plt.xlabel('월')
plt.ylabel('대여량')

# 3. 계절별 대여량 (박스플롯)
plt.subplot(3, 3, 3)
sns.boxplot(data=train, x='season', y='count')
plt.title('계절별 대여량 분포')

# 4. 온도 vs 대여량 (산점도)
plt.subplot(3, 3, 4)
plt.scatter(train['temp'], train['count'], alpha=0.5, color='green')
plt.xlabel('온도')
plt.ylabel('대여량')
plt.title('온도 vs 대여량')

# 5. 대여량 히스토그램
plt.subplot(3, 3, 5)
train['count'].hist(bins=30, color='orange', alpha=0.7)
plt.xlabel('대여량')
plt.title('대여량 분포')

# 6. 근무일/휴일 비교
plt.subplot(3, 3, 6)
sns.violinplot(data=train, x='workingday', y='count')
plt.title('근무일 여부별 대여량')

# 7. 이상치 포함 박스플롯
plt.subplot(3, 3, 7)
sns.boxplot(y='count', data=train)
plt.title('전체 대여량 박스플롯')

# 8. 로그 변환 후 분포
plt.subplot(3, 3, 8)
train['count_log'].hist(bins=30, color='purple', alpha=0.7)
plt.xlabel('log(대여량)')
plt.title('로그 변환 후 분포')

# 9. 상관관계 히트맵
plt.subplot(3, 3, 9)
correlation_vars = ['temp', 'humidity', 'windspeed', 'count']
corr_matrix = train[correlation_vars].corr()
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', center=0)
plt.title('변수간 상관관계')

plt.tight_layout()
plt.show()
```

---

## 🎯 리니어 리그레션을 위한 최종 전처리

### 1. 피처 엔지니어링
```python
# 리니어 리그레션을 위한 새로운 변수 생성
train_ml = train.copy()

# 온도 구간 변수
train_ml['temp_range'] = pd.cut(train_ml['temp'], 
                               bins=4, 
                               labels=['저온', '중온', '고온', '최고온'])

# 시간대 더미 변수
train_ml['is_rush_hour'] = ((train_ml['hour'].isin([7, 8, 17, 18, 19]))).astype(int)

# 계절 더미 변수
season_dummies = pd.get_dummies(train_ml['season'], prefix='season')
train_ml = pd.concat([train_ml, season_dummies], axis=1)

print("🔧 피처 엔지니어링 결과:")
print(f"새로운 컬럼 수: {train_ml.shape[1]}")
print("추가된 변수들:")
print("- temp_range: 온도 구간")
print("- is_rush_hour: 출퇴근 시간 여부")
print("- season_1~4: 계절 더미 변수")
```

### 2. 최종 데이터셋 준비
```python
# 리니어 리그레션을 위한 최종 변수 선택
feature_columns = ['temp', 'humidity', 'windspeed', 'hour', 'workingday', 'is_rush_hour'] + \
                 [col for col in train_ml.columns if col.startswith('season_')]

X_features = train_ml[feature_columns]
y_target = train_ml['count']

print("📋 최종 모델링 데이터셋:")
print(f"피처 수: {X_features.shape[1]}")
print(f"샘플 수: {X_features.shape[0]}")
print(f"타겟 변수: {y_target.name}")

# 기술 통계량 확인
print("\n피처 기술 통계량:")
print(X_features.describe())
```

---

## 🎉 마무리: 선생님의 핵심 교훈

### 💎 강의에서 얻은 핵심 인사이트

#### 📚 데이터 분석의 기본 원칙
```python
print("🎯 선생님의 데이터 분석 철학:")
print()
print("1️⃣ '박스플롯은 데이터 분석하는 사람들에게 정말 중요한 녀석이다'")
print("   → 이상치 탐지와 분포 파악의 핵심 도구")
print()
print("2️⃣ '착한 데이터로 아주 예쁜 데이터로 만들어야 좋은 결과를 얻을 수 있다'") 
print("   → 데이터 전처리의 중요성")
print()
print("3️⃣ '텍스트만 보면 느낌이 안 와. 이럴 때 차트를 그린다'")
print("   → 시각화의 필요성과 가치")
print()
print("4️⃣ '요거 가지고 리니어 리그레션 연습할 때 많이 써먹는데'")
print("   → 머신러닝으로의 발전 방향")
```

#### 🛠️ 실무 활용 가이드라인
```python
print("💼 실무에서 적용할 수 있는 선생님의 노하우:")
print()
print("🔍 이상치 처리:")
print("   • 박스플롯으로 먼저 시각적 확인")
print("   • 도메인 지식으로 이상치 여부 판단")
print("   • 명백한 오류는 제거, 애매한 경우는 보존")
print()
print("📊 시각화 접근:")
print("   • 객체지향적 방법(subplot) 활용")
print("   • 여러 차트를 한 번에 보여주기")
print("   • ggplot 스타일로 깔끔하게")
print()
print("🧹 데이터 정제:")
print("   • missingno로 결측치 패턴 파악")
print("   • pandas 옵션으로 전체 데이터 확인")
print("   • 날짜 데이터는 읽을 때 바로 변환")
```

#### 🚀 다음 학습 로드맵
```python
print("🗺️ 선생님이 제시한 학습 경로:")
print()
print("현재 단계: 18.05 이상치 결측치와 시각화 ✅")
print("    ↓")
print("다음 단계: 리니어 리그레션 (Linear Regression)")
print("    ↓") 
print("고급 단계: 머신러닝 모델링")
print("    ↓")
print("실무 단계: 실제 프로젝트 적용")
print()
print("🎯 핵심 메시지:")
print("'데이터를 깨끗하게 만드는 것이 좋은 모델의 시작점이다!'")
```

### 📋 체크리스트: 다음 강의 준비사항

```python
체크리스트 = {
    "✅ 기본 라이브러리": ["pandas", "numpy", "matplotlib", "seaborn"],
    "✅ 추가 라이브러리": ["missingno (선택사항)"],
    "✅ 데이터 이해": ["자전거 공유 시스템 데이터 구조", "컬럼별 의미"],
    "✅ 전처리 기법": ["이상치 탐지", "결측치 처리", "날짜 데이터 변환"],
    "✅ 시각화 기법": ["박스플롯", "히트맵", "다중 서브플롯"],
    "🔜 다음 학습": ["선형 회귀 이론", "sklearn 라이브러리", "모델 평가 지표"]
}

print("📋 학습 완료 체크리스트:")
for 카테고리, 항목들 in 체크리스트.items():
    print(f"\n{카테고리}:")
    for 항목 in 항목들:
        print(f"   • {항목}")
```

---

## 📝 핵심 정리 및 다음 단계

### 🎯 이번 실습에서 배운 내용

#### 1. **이상치 탐지 방법**
- **Z-Score**: 표준화된 값이 ±3 범위를 벗어나는 데이터
- **IQR 방법**: Q1-1.5×IQR ~ Q3+1.5×IQR 범위를 벗어나는 데이터  
- **시각적 탐지**: BoxPlot, 히스토그램, 산점도

#### 2. **이상치 처리 전략**
- **제거**: 명확한 오류 데이터인 경우
- **변환**: 경계값 치환(Capping), 로그 변환
- **유지**: 비즈니스적으로 의미가 있는 경우

#### 3. **결측치 처리**
- **탐지**: `isnull()`, 히트맵, missingno 라이브러리
- **처리**: 삭제, 평균/중앙값 대체, 예측값 대체

#### 4. **시각화 활용**
- **BoxPlot**: 분포와 이상치 한눈에 파악
- **히트맵**: 결측치 패턴, 상관관계 분석
- **다면 차트**: 종합적 데이터 이해

### 🚀 다음 단계: 리니어 리그레션 모델링

```python
# 다음 강의에서 다룰 내용 미리보기
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

print("🔮 다음 강의 예고:")
print("1. 선형 회귀 모델 구축")
print("2. 모델 성능 평가")
print("3. 예측 결과 시각화")
print("4. 잔차 분석 및 모델 진단")
```

### ⚡ 실무 포인트

#### 💡 **데이터 품질이 모델 성능을 결정한다**
- 이상치와 결측치 처리는 모든 분석의 첫 단계
- 도메인 지식을 활용한 논리적 판단이 중요
- 시각화를 통한 데이터 이해가 선행되어야 함

#### 🔧 **자전거 공유 시스템 인사이트**
- **출퇴근 시간대**에 대여량 급증 (Rush Hour Effect)
- **온도와 계절**이 이용 패턴에 큰 영향
- **근무일과 휴일**의 뚜렷한 패턴 차이
- **극한 날씨**에서 이상치 발생 가능성

---

## 🎉 마무리

자전거 공유 시스템 데이터를 통해 **이상치와 결측치 처리의 전 과정**을 실습했습니다. 

**핵심 메시지**: "데이터를 깨끗하게 만드는 것이 좋은 모델의 시작점이다!"

다음 강의에서는 전처리된 이 데이터로 **리니어 리그레션 모델**을 구축하여 자전거 대여량을 예측해보겠습니다. 🚴‍♂️📈