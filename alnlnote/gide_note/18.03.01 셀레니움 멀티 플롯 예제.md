# 18.03.01 셀레니움 멀티 플롯 예제 - 봉구스밥버거 메뉴 가격 종합 시각화

## 🎯 개요
이 예제는 Selenium을 사용해 동적 웹 페이지에서 데이터를 크롤링하고, matplotlib과 seaborn을 활용하여 다양한 시각화를 구현하는 종합적인 실습입니다. 하나의 데이터셋으로 6가지 다른 차트를 동시에 생성하는 멀티플롯 기법을 다룹니다.

---

## 💬 선생님의 실전 강의 포인트

> **"셀레니움은 뭐라 해서 브라우저를 통제한다고 그랬지"**  
> **"브라우저를 통제하는 거야, 그러니까 내가 브라우저를 띄워가지고 통제를 하는 거예요"**

### 🤔 왜 Selenium을 써야 하는가?

**선생님 설명:**
- *"봉구스밥버거의 메뉴 정보는 동적으로 로딩되는 웹 페이지다"*
- *"일반적인 HTTP 요청으로는 HTML 소스를 가져올 수 없다"*
- *"아작스(AJAX) 요청을 하다가 공적으로... 중간 중간에 뭐 하래 로그인을 하라고 막 그래요"*
- *"그런 거는요 일반 프로그램으로 안 돼요"*

### 🎯 실무에서 Selenium이 필요한 상황들

**선생님이 언급한 실제 사례들:**
1. **동적 로딩 페이지**: JavaScript로 데이터가 나중에 로드되는 경우
2. **로그인이 필요한 사이트**: 프로그램이 자동으로 로그인 처리
3. **캡차(CAPTCHA) 처리**: 보안 문자 입력이 필요한 경우
4. **복잡한 사용자 상호작용**: 버튼 클릭, 폼 입력 등

> **"셀레늄이 뭔데 나만의 브라우저를 띄우는 거예요"**  
> **"이 브라우저는 프로그램의 통제를 받고 있는 브라우저야"**

---

## 🛠️ 환경 설정 및 필수 준비사항

### 필수 라이브러리 설치
```bash
pip install selenium beautifulsoup4 pandas matplotlib seaborn
```

### 크롬 버전 확인 및 드라이버 다운로드

**선생님 설명:**
> *"자기 걸 맞춰가지고 자기 걸 찾아야 되거나 자기 거 차기 버전"*  
> *"크롬을 띄워가지고 최신 버전인지 확인해"*

**단계별 진행:**
1. **크롬 브라우저 버전 확인**
   ```
   크롬 실행 → 설정(⚙️) → 크롬 정보 → 버전 확인
   예: "버전 131.0.6778.86 (공식 빌드) (64비트)"
   ```

2. **크롬 드라이버 다운로드**
   - [Chrome for Testing](https://googlechromelabs.github.io/chrome-for-testing/#stable)
   - 본인의 크롬 버전과 **정확히 일치**하는 드라이버 다운로드
   
3. **드라이버 배치**
   ```python
   # 예시 경로 (본인 환경에 맞게 수정)
   chrome_path = "./chromedriver.exe"  # Windows
   # chrome_path = "./chromedriver"    # Mac/Linux
   ```

### ⚠️ 선생님의 중요 주의사항

**버전 호환성:**
> *"파이썬에서 가장 고통스러운 게 버전이 안 맞으면 완전 개털이다"*  
> *"버전이 안 맞아, 맞는 거예요, 그것 때문에 실행을 시켰는데 메시지가 떴어 버전 문제가 나와"*

**해결 방법:**
- 크롬 드라이버 버전 ↔ 크롬 브라우저 버전 일치시키기
- 또는 Python 버전을 라이브러리 요구사항에 맞추기

**설치 확인:**
> *"특히 가상 환경을 쓰는 사람은요. 정말 깔렸는지 확인해 볼 필요가 있어요"*

```python
# 설치 확인 방법
import selenium
print("Selenium 설치 완료:", selenium.__version__)

# 가상환경 사용자는 경로 확인 필수
# Anaconda3/Lib/site-packages에 selenium 폴더가 있는지 확인
```

---

## 📊 완전한 코드 구현

```python
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from bs4 import BeautifulSoup
import pandas as pd
import time
import matplotlib.pyplot as plt
import matplotlib
import seaborn as sns

# 셀레니움을 사용해야 하는 이유
# - 봉구스밥버거의 메뉴 정보는 동적으로 로딩되는 웹 페이지로, 일반적인 HTTP 요청으로는 HTML 소스를 가져올 수 없습니다.
# - 따라서, 셀레니움을 사용하여 실제 브라우저를 통해 페이지를 로드하고, 필요한 데이터를 추출해야 합니다.

matplotlib.rc('font', family='Malgun Gothic')  # 윈도우: 'Malgun Gothic'
plt.rcParams['axes.unicode_minus'] = False     # 마이너스(-) 깨짐 방지

# 0. 필요사항
# - 로컬에 Python 3.13.5 설치
# - Selenium 및 BeautifulSoup4, pandas, matplotlib, seaborn 설치
# -- pip install selenium beautifulsoup4 pandas matplotlib seaborn
# - https://googlechromelabs.github.io/chrome-for-testing/#stable 에서 크롬 드라이버 다운로드 및 경로 설정
# - (터미널) 아나콘다 자동 활성화 비활성화 명령어: conda config --set auto_activate_base false

# 1. 크롬 드라이버 경로 지정 (chromedriver.exe 위치에 맞게 수정)
chrome_path = "./01_big_data_machine_learning/code/0807/연습문제/chromedriver.exe"
service = Service(chrome_path)
options = webdriver.ChromeOptions()
options.add_argument('--headless')  # 창 안 띄우고 실행

# 2. 웹 페이지 열기
driver = webdriver.Chrome(service=service, options=options)
driver.get("https://bongousse.com/Menu_list.asp")
time.sleep(2)  # 페이지 로딩 대기

# 3. HTML 소스 가져오기
html = driver.page_source

# 4. BeautifulSoup 객체 생성 후 soup에 저장
soup = BeautifulSoup(html, "html.parser")

# 5. (로그) soup 파일의 내용을 log_downloaded_menu.html로 저장
# 로그 저장 활성화 여부
SAVE_LOG = False  # False로 바꾸면 로그 저장 안 함
if SAVE_LOG:
    with open("./01_big_data_machine_learning/code/0807/연습문제/log_downloaded_menu.html", "w", encoding="utf-8") as f:
        f.write(str(soup.prettify()))

# 6. 드라이버 종료
driver.quit()

# 7. soup 객체에서 메뉴명과 가격 추출
names = [tag.text.strip() for tag in soup.select('ul#bonmenu_list li div.txtbox > div.tit')]
prices = [int(tag.text.strip().replace(',', '')) for tag in soup.select('ul#bonmenu_list li div.txtbox > div.price')]

# 8. 읽어온 거 출력
PRINT_MENU_PRICE = False # False로 바꾸면 출력 안 함
if PRINT_MENU_PRICE:
    print("메뉴명:", names)
    print("가격:", prices)

# 9. 읽어온 데이터로 DataFrame 생성
# 메뉴명    가격    설명
df = pd.DataFrame({
    '상품명': names,
    '가격': prices,
    '설명': ['저는 봉구킹을 좋아합니다!'] * len(names)
})

PRINT_DATAFRAME = False # False로 바꾸면 출력 안 함
if PRINT_DATAFRAME:
    print(df)

# 건수:
print('메뉴 개수: \t', len(names), '개')
# 가격평균:
print('가격 평균: \t', round(df['가격'].mean(), 2), '원')
# 표준편차:
print('표준 편차: \t', round(df['가격'].std(), 2), '원')
# 최고가격:
print('최고 가격: \t', df['가격'].max(), '원')
# 최저가격:
print('최저 가격: \t', df['가격'].min(), '원')

# # 시각화
plt.figure(figsize=(16, 9))

# 1. 선 그래프 (가격 추이)
plt.subplot(3, 2, 1)
plt.plot(range(len(df)), df['가격'], 'r-o')
plt.title('메뉴별 가격 추이 (선 그래프)')
plt.xlabel('순서')
plt.ylabel('가격')
plt.grid()

# 2. 막대 그래프 (가격)
plt.subplot(3, 2, 2)
plt.bar(range(len(df)), df['가격'], color='skyblue')
plt.title('메뉴별 가격 (막대 그래프)')
plt.xlabel('순서')
plt.ylabel('가격')
plt.grid()

# 3. 히스토그램 (가격 분포)
plt.subplot(3, 2, 3)
plt.hist(df['가격'], bins=10, color='orange', edgecolor='black')
plt.title('가격 분포 (히스토그램)')
plt.xlabel('가격')
plt.ylabel('빈도')
plt.grid()

# 4. 박스플롯 (이상치 포함 가격 분포)
plt.subplot(3, 2, 4)
plt.boxplot(df['가격'], vert=False)
plt.title('가격 분포 (박스플롯)')
plt.xlabel('가격')
plt.grid()

# 5. 파이 차트 (상위 5개 메뉴 가격 비중)
top5 = df.nlargest(5, '가격')
plt.subplot(3, 2, 5)
plt.pie(top5['가격'], labels=list(top5['상품명']), autopct='%1.1f%%', startangle=140)
plt.title('상위 5개 메뉴 가격 비중 (파이 차트)')

# 6. 산점도 (순서 vs 가격)
plt.subplot(3, 2, 6)
plt.scatter(range(len(df)), df['가격'], c=df['가격'], cmap='viridis', s=100)
plt.title('순서 vs 가격 (산점도)')
plt.xlabel('순서')
plt.ylabel('가격')
plt.grid()

plt.tight_layout()
plt.show()

#seaborn 스타일 적용

# 스타일 적용 (seaborn 스타일)
sns.set_theme(style="whitegrid", font="Malgun Gothic", rc={"axes.unicode_minus":False})

plt.figure(figsize=(16, 12))

# 1. 선 그래프 (가격 추이)
plt.subplot(3, 2, 1)
sns.lineplot(x=range(len(df)), y=df['가격'], marker='o', color='crimson')
plt.title('메뉴별 가격 추이 (선 그래프)')
plt.xlabel('순서')
plt.ylabel('가격')

# 2. 막대 그래프 (가격)
plt.subplot(3, 2, 2)
sns.barplot(x=range(len(df)), y=df['가격'], palette='Blues_d')
plt.title('메뉴별 가격 (막대 그래프)')
plt.xlabel('순서')
plt.ylabel('가격')
plt.xticks(ticks=range(0, len(df), max(1, len(df)//10)), rotation=45, ha='right')  # x축 레이블을 10개 간격으로만 표시

# 3. 히스토그램 (가격 분포)
plt.subplot(3, 2, 3)
sns.histplot(data = df, x='가격', bins=10, color='orange', edgecolor='black')
plt.title('가격 분포 (히스토그램)')
plt.xlabel('가격')
plt.ylabel('빈도')

# 4. 박스플롯 (이상치 포함 가격 분포)
plt.subplot(3, 2, 4)
sns.boxplot(x=df['가격'], color='limegreen')
plt.title('가격 분포 (박스플롯)')
plt.xlabel('가격')

# 5. 파이 차트 (상위 5개 메뉴 가격 비중) - matplotlib 사용
top5 = df.nlargest(5, '가격')
plt.subplot(3, 2, 5)
plt.pie(top5['가격'], labels=list(top5['상품명']), autopct='%1.1f%%', startangle=140, colors=sns.color_palette('pastel'))
plt.title('상위 5개 메뉴 가격 비중 (파이 차트)')

# 6. 산점도 (순서 vs 가격)
plt.subplot(3, 2, 6)
sns.scatterplot(x=range(len(df)), y=df['가격'], hue=df['가격'], palette='viridis', s=100, legend=False)
plt.title('순서 vs 가격 (산점도)')
plt.xlabel('순서')
plt.ylabel('가격')

plt.tight_layout(pad=3.0)  # pad 값을 늘려 간격 확보
plt.show()
```

---

## 🔍 코드 분석 및 핵심 개념

### 🔍 코드 동작 원리 - 선생님 해설

**브라우저 제어 과정:**
> *"브라우저를 띄워 놓은 거야? 그리고 잠시 대기하셔 요거 일부러 하는 거"*  
> *"내가 브라우저를 띄웠잖아 그런 다음에 요로 가잖아. 그런데 보통 뭐 합니까 이게 인터벌이 필요해요"*

**time.sleep(2)의 중요성:**
> *"요거 준 다음에 바로 넘어가면 안 돼. 브라우저에 얘가 로딩이 안 됐는데 이 명령으로 바로 넘어갈 수 있어요"*  
> *"그래서 살짝 인터벌을 주는 거야 그지 요거 주고 숨 한번 쉬고 그다음 넘어가는 거예요"*

```python
# 선생님이 강조한 필수 대기 시간
time.sleep(2)  # "숨 한번 쉬고 그다음 넘어가는 거예요"

# 네트워크 상태에 따라 조정 가능
# time.sleep(5)  # "뭐 5G 아니야. 뭐 늘릴 수 있어요"
```

**데이터 추출 과정:**
> *"페이지를 통제하는 셀레늄의 질 이거 로딩 하면 끝난 거야"*  
> *"그다음에 이제 내가 하고 싶은 거 하는 거잖아 뷰티풀 수업으로 읽어 가지고 뭔가 하고"*

---

### 2. 데이터 전처리 및 통계 분석

#### DataFrame 생성과 기본 통계
```python
df = pd.DataFrame({
    '상품명': names,
    '가격': prices,
    '설명': ['저는 봉구킹을 좋아합니다!'] * len(names)
})

# 기본 통계 정보 출력
print('메뉴 개수: \t', len(names), '개')
print('가격 평균: \t', round(df['가격'].mean(), 2), '원')
print('표준 편차: \t', round(df['가격'].std(), 2), '원')
print('최고 가격: \t', df['가격'].max(), '원')
print('최저 가격: \t', df['가격'].min(), '원')
```

### 3. 멀티플롯 시각화 구현

#### 3×2 그리드 레이아웃으로 6개 차트 동시 표시
```python
plt.figure(figsize=(16, 9))  # 전체 캔버스 크기 설정

# subplot(행, 열, 인덱스) - 3행 2열 구조
plt.subplot(3, 2, 1)  # 첫 번째 위치 (1행 1열)
plt.subplot(3, 2, 2)  # 두 번째 위치 (1행 2열)
# ... 6번째까지
```

#### 각 차트 유형별 분석 목적

1. **선 그래프**: 메뉴 순서대로 가격 변화 추이 관찰
2. **막대 그래프**: 개별 메뉴별 가격 비교
3. **히스토그램**: 가격대별 메뉴 분포 확인
4. **박스플롯**: 가격 분포의 사분위수와 이상치 탐지
5. **파이 차트**: 상위 5개 고가 메뉴의 가격 비중
6. **산점도**: 순서와 가격의 상관관계 및 색상으로 가격 표현

### 📊 시각화 구현 - 선생님의 차트 선택 철학

**멀티플롯의 실무 가치:**
> *"여러 가지 방법을 이렇게 볼 수 하는 거죠? 저런 방법으로 확인하시면 딱이에요"*  
> *"이게 데이터에 따라서 누구 어떤 데이터에 어떤 그래프가 맞는지 요것들을 많이 해봐야 돼"*

**6가지 차트의 분석 목적:**

1. **선 그래프**: *"메뉴별 가격 추이"* - 순서대로 나열된 데이터의 패턴 관찰
2. **막대 그래프**: *"메뉴별 가격"* - 개별 아이템 비교에 최적
3. **히스토그램**: *"가격 분포"* - 가격대별 메뉴 분포 확인
4. **박스플롯**: *"이상치 포함 가격 분포"* - 아웃라이어까지 한 눈에!
5. **파이 차트**: *"상위 5개 메뉴 가격 비중"* - 고가 메뉴들의 비중 파악
6. **산점도**: *"순서 vs 가격"* - 색상으로 가격까지 표현하는 고급 기법

**seaborn vs matplotlib:**
> *"시본을 써 가지고 딱 한 겁니다"* - 더 현대적이고 아름다운 차트를 위해!

---

## 🎯 실무 활용 포인트

### 1. 멀티플롯의 실무 의미
- **대시보드 형태**: 하나의 화면에서 데이터의 다각도 분석
- **보고서 자동화**: 일관된 형태의 분석 리포트 생성
- **데이터 탐색**: 다양한 시각화로 데이터의 숨겨진 패턴 발견

### 2. 동적 웹 크롤링의 실용성
- **실시간 가격 모니터링**: 경쟁사 제품 가격 추적
- **콘텐츠 업데이트 감지**: 웹사이트 변경사항 자동 체크
- **데이터 수집 자동화**: 정기적인 비즈니스 인텔리전스 수집

### 3. 시각화 선택 기준
```python
# 데이터 특성에 따른 차트 선택
if len(data) < 20:
    # 소량 데이터: 막대그래프, 파이차트
    plt.bar() / plt.pie()
elif len(data) < 1000:
    # 중량 데이터: 히스토그램, 박스플롯
    plt.hist() / plt.boxplot()
else:
    # 대량 데이터: 산점도, 히트맵
    plt.scatter() / sns.heatmap()
```

---

## 💡 확장 가능한 개선 아이디어

### 1. 데이터 저장 및 이력 관리
```python
# CSV 파일로 저장하여 시계열 분석 가능
df['수집일시'] = pd.Timestamp.now()
df.to_csv(f'menu_data_{pd.Timestamp.now().strftime("%Y%m%d")}.csv', index=False)
```

### 2. 인터랙티브 시각화로 발전
```python
import plotly.express as px
# 줌, 필터링 가능한 동적 차트로 업그레이드
fig = px.scatter(df, x='순서', y='가격', color='가격', hover_data=['상품명'])
```

### 3. 자동화 스케줄링
```python
import schedule
import time

def daily_menu_analysis():
    # 위의 전체 분석 프로세스 실행
    pass

schedule.every().day.at("09:00").do(daily_menu_analysis)
```

---

### 🎓 선생님의 학습 조언

**실무 접근법:**
> *"요거 요거 하나 요거 요 요거 요 내용 꼭 기억해 주면 좋을 것 같아요"*  
> *"잘 정리가 돼 있습니다. 잘 정리돼 셀레늄까지 요 파일 하나는 알아, 2시면은요 좋을 것 같아요"*

**문제 해결 철학:**
> *"한 문제에 대해서 아주 다양한 방법으로 풀어낼 수 있거든요. 개성에 맞게"*  
> *"시행착오를 거쳐야 실력이 늘어난다"*

**학습 순서:**
1. **이론 이해**: 셀레늄과 matplotlib의 기본 개념
2. **실전 연습**: 실제 웹사이트로 데이터 수집
3. **다양한 시도**: 여러 시각화 방법 실험
4. **패턴 발견**: 데이터 특성에 맞는 차트 선택 능력 개발

**질문하는 문화:**
> *"느낌 안 온 거 있으면은요. 그거 만든 사람한테 좀 물어보는데 왜 바로 옆에 있잖아 직접 물어보면 됩니다"*  
> *"ChatGPT한테 가지 말고 솔직히 너무 가지 말고 어 본인한테 물어보고"*

---