# 20.02.02 Django JSON 직렬화 완벽 가이드 - Python에서 JavaScript로

> **참고 자료**: [17.04.01 JSON 기초부터 실전까지](17.04.01%20JSON%20기초부터%20실전까지%20-%20API%20시대의%20핵심%20기술.md)에서 JSON의 기본 개념과 Python json 라이브러리 사용법을 먼저 학습하시기 바랍니다.

## 목차
1. [JSON 직렬화란 무엇인가](#json-직렬화란-무엇인가)
2. [Django에서 JSON 직렬화 기본](#django에서-json-직렬화-기본)
3. [Python 데이터 타입별 직렬화](#python-데이터-타입별-직렬화)
4. [Django 모델 직렬화](#django-모델-직렬화)
5. [Pandas 데이터프레임 직렬화](#pandas-데이터프레임-직렬화)
6. [날짜/시간 데이터 직렬화](#날짜시간-데이터-직렬화)
7. [한글 및 유니코드 처리](#한글-및-유니코드-처리)
8. [ECharts 연동 최적화](#echarts-연동-최적화)
9. [성능 최적화 기법](#성능-최적화-기법)
10. [보안 고려사항](#보안-고려사항)
11. [실전 예제 모음](#실전-예제-모음)

---

## JSON 직렬화란 무엇인가

### 🎯 직렬화(Serialization) 개념

**직렬화**는 메모리에 있는 객체나 데이터 구조를 저장이나 전송이 가능한 형태로 변환하는 과정입니다.

```python
# 🧠 메모리에 있는 Python 객체
python_data = {
    'name': '김개발',
    'skills': ['Python', 'Django'],
    'score': 95.5
}

# 📝 JSON 문자열로 직렬화 (Serialization)
json_string = json.dumps(python_data)
# 결과: '{"name": "김개발", "skills": ["Python", "Django"], "score": 95.5}'

# 🔄 다시 Python 객체로 역직렬화 (Deserialization)
restored_data = json.loads(json_string)
```

### 🌐 Django에서 JSON 직렬화가 중요한 이유

#### 1. **웹 브라우저와의 통신**
```python
# Python (Django 서버)                    JavaScript (브라우저)
python_list = [1, 2, 3, 4, 5]     →      const jsArray = [1, 2, 3, 4, 5];
python_dict = {'key': 'value'}    →      const jsObject = {key: 'value'};
```

#### 2. **ECharts 차트 데이터 전달**
```python
# 🐍 Python에서 차트 데이터 준비
chart_labels = ['1월', '2월', '3월', '4월']
chart_values = [120, 200, 150, 80]

# 📤 JSON으로 직렬화해서 템플릿으로 전달
context = {
    'labels_json': json.dumps(chart_labels, ensure_ascii=False),
    'values_json': json.dumps(chart_values)
}
```

```html
<!-- 🌐 HTML 템플릿에서 JavaScript로 사용 -->
<script>
    const labels = {{ labels_json|safe }};      // ['1월', '2월', '3월', '4월']
    const values = {{ values_json|safe }};      // [120, 200, 150, 80]
    
    // ECharts에서 사용
    const option = {
        xAxis: { data: labels },
        series: [{ data: values }]
    };
</script>
```

---

## Django에서 JSON 직렬화 기본

### 🔧 json.dumps() 기본 사용법

```python
import json
from django.shortcuts import render

def basic_json_view(request):
    """기본적인 JSON 직렬화 예제"""
    
    # 📊 차트용 데이터 준비
    sales_data = {
        'months': ['1월', '2월', '3월', '4월', '5월'],
        'values': [1200, 1500, 1800, 1600, 2100],
        'categories': {
            '온라인': 800,
            '오프라인': 1300
        }
    }
    
    # 🔄 JSON 직렬화 (기본)
    sales_json_basic = json.dumps(sales_data)
    print("기본 직렬화:", sales_json_basic)
    
    # 🔄 JSON 직렬화 (한글 지원)
    sales_json_korean = json.dumps(sales_data, ensure_ascii=False)
    print("한글 지원:", sales_json_korean)
    
    # 🔄 JSON 직렬화 (예쁘게 포맷팅)
    sales_json_pretty = json.dumps(sales_data, ensure_ascii=False, indent=2)
    print("예쁜 포맷:", sales_json_pretty)
    
    # 📤 템플릿에 전달
    context = {
        'sales_data_json': sales_json_korean,
        'months_json': json.dumps(sales_data['months'], ensure_ascii=False),
        'values_json': json.dumps(sales_data['values'])
    }
    
    return render(request, 'chart.html', context)
```

### 🎛️ json.dumps() 주요 옵션들

```python
def json_options_demo():
    """json.dumps()의 다양한 옵션들"""
    
    test_data = {
        'korean': '한글 테스트',
        'number': 123.456789,
        'boolean': True,
        'null_value': None,
        'list': [1, 2, 3],
        'nested': {'deep': {'value': '중첩 객체'}}
    }
    
    # 1️⃣ ensure_ascii (한글 처리)
    print("🔤 ensure_ascii 옵션:")
    print("False:", json.dumps(test_data, ensure_ascii=False))
    print("True :", json.dumps(test_data, ensure_ascii=True))
    
    # 2️⃣ indent (들여쓰기)
    print("\n📝 indent 옵션:")
    print("없음:", json.dumps(test_data, ensure_ascii=False))
    print("2칸 :", json.dumps(test_data, ensure_ascii=False, indent=2))
    
    # 3️⃣ sort_keys (키 정렬)
    print("\n🔤 sort_keys 옵션:")
    print("정렬X:", json.dumps(test_data, ensure_ascii=False))
    print("정렬O:", json.dumps(test_data, ensure_ascii=False, sort_keys=True))
    
    # 4️⃣ separators (구분자 커스터마이징)
    print("\n✂️ separators 옵션:")
    print("기본  :", json.dumps(test_data, ensure_ascii=False))
    print("컴팩트:", json.dumps(test_data, ensure_ascii=False, separators=(',', ':')))

json_options_demo()
```

---

## Python 데이터 타입별 직렬화

### 📋 기본 데이터 타입

```python
def basic_types_serialization():
    """Python 기본 타입들의 JSON 직렬화"""
    
    # ✅ JSON에서 지원하는 타입들
    supported_types = {
        'string': '문자열',
        'integer': 42,
        'float': 3.14159,
        'boolean_true': True,
        'boolean_false': False,
        'null': None,
        'list': [1, 2, 3, '리스트'],
        'dict': {'중첩': '딕셔너리'}
    }
    
    print("✅ 지원되는 타입들:")
    json_result = json.dumps(supported_types, ensure_ascii=False, indent=2)
    print(json_result)
    
    # ❌ JSON에서 지원하지 않는 타입들
    from decimal import Decimal
    from datetime import datetime, date
    import numpy as np
    
    unsupported_examples = {
        'decimal': Decimal('10.50'),
        'datetime': datetime.now(),
        'date': date.today(),
        'set': {1, 2, 3},
        'tuple': (1, 2, 3),
        'numpy_array': np.array([1, 2, 3]),
        'function': lambda x: x + 1
    }
    
    print("\n❌ 지원되지 않는 타입들:")
    for key, value in unsupported_examples.items():
        try:
            json.dumps(value)
            print(f"  {key}: ✅ (변환됨)")
        except TypeError as e:
            print(f"  {key}: ❌ ({type(value).__name__})")

basic_types_serialization()
```

### 🔄 지원되지 않는 타입 변환하기

```python
from decimal import Decimal
from datetime import datetime, date
import numpy as np

def convert_unsupported_types():
    """지원되지 않는 타입들을 JSON 호환 타입으로 변환"""
    
    # 원본 데이터 (JSON 직렬화 불가능)
    problematic_data = {
        'price': Decimal('29.99'),
        'created_at': datetime.now(),
        'birth_date': date(1990, 5, 15),
        'tags': {'Python', 'Django', 'JSON'},  # set
        'coordinates': (37.5665, 126.9780),    # tuple
        'scores': np.array([85, 90, 78, 92])   # numpy array
    }
    
    # 🔧 변환 함수들
    def convert_for_json(obj):
        """JSON 직렬화 가능한 형태로 변환"""
        if isinstance(obj, Decimal):
            return float(obj)
        elif isinstance(obj, (datetime, date)):
            return obj.isoformat()
        elif isinstance(obj, set):
            return list(obj)
        elif isinstance(obj, tuple):
            return list(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        elif hasattr(obj, '__dict__'):  # 사용자 정의 객체
            return obj.__dict__
        else:
            return obj
    
    # 🔄 데이터 변환
    converted_data = {}
    for key, value in problematic_data.items():
        converted_data[key] = convert_for_json(value)
    
    print("🔧 변환된 데이터:")
    json_result = json.dumps(converted_data, ensure_ascii=False, indent=2)
    print(json_result)
    
    return converted_data

converted = convert_unsupported_types()
```

### 🎭 Custom JSON Encoder 사용하기

```python
import json
from decimal import Decimal
from datetime import datetime, date

class CustomJSONEncoder(json.JSONEncoder):
    """사용자 정의 JSON 인코더"""
    
    def default(self, obj):
        """JSON 직렬화 불가능한 객체들을 처리"""
        
        if isinstance(obj, Decimal):
            return float(obj)
        elif isinstance(obj, datetime):
            return obj.strftime('%Y-%m-%d %H:%M:%S')
        elif isinstance(obj, date):
            return obj.strftime('%Y-%m-%d')
        elif isinstance(obj, set):
            return list(obj)
        elif isinstance(obj, tuple):
            return list(obj)
        elif hasattr(obj, 'tolist'):  # numpy 배열
            return obj.tolist()
        
        # 기본 처리를 부모 클래스에 위임
        return super().default(obj)

def custom_encoder_demo():
    """Custom JSON Encoder 사용 예제"""
    
    complex_data = {
        'product_name': '프리미엄 상품',
        'price': Decimal('149.99'),
        'created_at': datetime.now(),
        'launch_date': date(2024, 3, 15),
        'tags': {'프리미엄', '한정판', '신상품'},
        'coordinates': (37.5665, 126.9780),
        'ratings': np.array([4.5, 4.8, 4.2, 4.9])
    }
    
    # ❌ 기본 json.dumps() 사용 시 오류
    try:
        standard_json = json.dumps(complex_data, ensure_ascii=False)
    except TypeError as e:
        print(f"❌ 기본 직렬화 실패: {e}")
    
    # ✅ Custom Encoder 사용
    try:
        custom_json = json.dumps(
            complex_data, 
            cls=CustomJSONEncoder,
            ensure_ascii=False,
            indent=2
        )
        print("✅ Custom Encoder로 성공:")
        print(custom_json)
    except Exception as e:
        print(f"❌ Custom Encoder 실패: {e}")

custom_encoder_demo()
```

---

## Django 모델 직렬화

### 🗄️ Django 모델을 JSON으로 변환하기

```python
# models.py
from django.db import models
from decimal import Decimal

class Product(models.Model):
    name = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    created_at = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)
    
    def __str__(self):
        return self.name

class Sale(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.IntegerField()
    sale_date = models.DateTimeField(auto_now_add=True)
    total_amount = models.DecimalField(max_digits=12, decimal_places=2)
```

```python
# views.py
from django.shortcuts import render
from django.core import serializers
from django.http import JsonResponse
import json

def django_model_serialization(request):
    """Django 모델 직렬화 다양한 방법들"""
    
    # 📊 샘플 데이터 조회
    products = Product.objects.all()[:5]
    
    # 방법 1: Django serializers 사용
    django_serialized = serializers.serialize('json', products)
    print("Django serializer 결과:")
    print(django_serialized)
    
    # 방법 2: 수동으로 딕셔너리 변환
    products_list = []
    for product in products:
        product_dict = {
            'id': product.id,
            'name': product.name,
            'price': float(product.price),  # Decimal → float 변환
            'created_at': product.created_at.isoformat(),
            'is_active': product.is_active
        }
        products_list.append(product_dict)
    
    manual_serialized = json.dumps(products_list, ensure_ascii=False)
    print("수동 변환 결과:")
    print(manual_serialized)
    
    # 방법 3: values() 활용
    products_values = list(Product.objects.values(
        'id', 'name', 'price', 'created_at', 'is_active'
    ))
    
    # Decimal과 datetime 변환
    for product in products_values:
        product['price'] = float(product['price'])
        product['created_at'] = product['created_at'].isoformat()
    
    values_serialized = json.dumps(products_values, ensure_ascii=False)
    print("values() 활용 결과:")
    print(values_serialized)
    
    return JsonResponse({
        'django_serialized': json.loads(django_serialized),
        'manual_serialized': products_list,
        'values_serialized': products_values
    })
```

### 🔗 Related Field 처리하기

```python
def related_field_serialization():
    """관계형 필드가 있는 모델 직렬화"""
    
    # 판매 데이터 조회 (Product와 연결됨)
    sales = Sale.objects.select_related('product').all()[:10]
    
    # 방법 1: 수동으로 관련 객체 포함
    sales_with_product = []
    for sale in sales:
        sale_dict = {
            'id': sale.id,
            'quantity': sale.quantity,
            'total_amount': float(sale.total_amount),
            'sale_date': sale.sale_date.isoformat(),
            'product': {
                'id': sale.product.id,
                'name': sale.product.name,
                'price': float(sale.product.price)
            }
        }
        sales_with_product.append(sale_dict)
    
    # 방법 2: values() with 관계형 필드
    sales_values = list(Sale.objects.select_related('product').values(
        'id', 'quantity', 'total_amount', 'sale_date',
        'product__id', 'product__name', 'product__price'
    ))
    
    # 데이터 타입 변환
    for sale in sales_values:
        sale['total_amount'] = float(sale['total_amount'])
        sale['product__price'] = float(sale['product__price'])
        sale['sale_date'] = sale['sale_date'].isoformat()
    
    return {
        'manual_with_product': sales_with_product,
        'values_with_product': sales_values
    }
```

### 📈 Aggregation 결과 직렬화

```python
from django.db.models import Sum, Count, Avg
from django.db.models.functions import TruncMonth

def aggregation_serialization():
    """집계 결과를 차트용 JSON으로 직렬화"""
    
    # 월별 매출 집계
    monthly_sales = (
        Sale.objects
        .annotate(month=TruncMonth('sale_date'))
        .values('month')
        .annotate(
            total_sales=Sum('total_amount'),
            total_quantity=Sum('quantity'),
            avg_amount=Avg('total_amount')
        )
        .order_by('month')
    )
    
    # ECharts용 데이터 준비
    chart_data = {
        'months': [],
        'sales': [],
        'quantities': [],
        'averages': []
    }
    
    for item in monthly_sales:
        chart_data['months'].append(item['month'].strftime('%Y-%m'))
        chart_data['sales'].append(float(item['total_sales'] or 0))
        chart_data['quantities'].append(item['total_quantity'] or 0)
        chart_data['averages'].append(float(item['avg_amount'] or 0))
    
    # JSON 직렬화
    chart_json = {
        'months_json': json.dumps(chart_data['months'], ensure_ascii=False),
        'sales_json': json.dumps(chart_data['sales']),
        'quantities_json': json.dumps(chart_data['quantities']),
        'averages_json': json.dumps(chart_data['averages'])
    }
    
    return chart_json
```

---

## Pandas 데이터프레임 직렬화

### 📊 DataFrame을 JSON으로 변환하기

```python
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

def pandas_json_serialization():
    """Pandas DataFrame의 다양한 JSON 직렬화 방법"""
    
    # 📊 샘플 데이터프레임 생성
    dates = pd.date_range('2024-01-01', periods=12, freq='M')
    df = pd.DataFrame({
        'month': dates,
        'sales': np.random.randint(1000, 5000, 12),
        'profit': np.random.uniform(0.1, 0.3, 12),
        'region': ['서울', '부산', '대구', '인천'] * 3,
        'is_holiday': [True, False, False, True] * 3
    })
    
    print("📊 원본 DataFrame:")
    print(df.head())
    print(f"데이터 타입:\n{df.dtypes}")
    
    # 방법 1: to_json() 사용
    print("\n1️⃣ DataFrame.to_json() 방법들:")
    
    # records 형식 (가장 일반적)
    records_json = df.to_json(orient='records', date_format='iso', force_ascii=False)
    print("records 형식:", records_json[:100] + "...")
    
    # values 형식 (2차원 배열)
    values_json = df.to_json(orient='values', date_format='iso')
    print("values 형식:", values_json[:100] + "...")
    
    # index 형식 (인덱스를 키로)
    index_json = df.to_json(orient='index', date_format='iso', force_ascii=False)
    print("index 형식:", index_json[:100] + "...")
    
    # 방법 2: 수동 변환 (더 세밀한 제어)
    print("\n2️⃣ 수동 변환:")
    
    # 날짜를 문자열로 변환
    df_copy = df.copy()
    df_copy['month'] = df_copy['month'].dt.strftime('%Y-%m')
    df_copy['profit'] = df_copy['profit'].round(3)
    
    manual_json = json.dumps(
        df_copy.to_dict('records'),
        ensure_ascii=False,
        indent=2
    )
    print("수동 변환 결과:", manual_json[:200] + "...")
    
    return df, records_json, manual_json

# 실행
df, records, manual = pandas_json_serialization()
```

### 📈 시계열 데이터 특별 처리

```python
def timeseries_json_serialization():
    """시계열 데이터의 JSON 직렬화"""
    
    # 📅 시계열 데이터 생성
    dates = pd.date_range('2024-01-01', periods=365, freq='D')
    ts_df = pd.DataFrame({
        'date': dates,
        'temperature': 20 + 10 * np.sin(2 * np.pi * np.arange(365) / 365) + np.random.normal(0, 2, 365),
        'humidity': 50 + 20 * np.cos(2 * np.pi * np.arange(365) / 365) + np.random.normal(0, 5, 365),
        'rainfall': np.random.exponential(2, 365)
    })
    
    # 월별 집계
    monthly_avg = ts_df.resample('M', on='date').agg({
        'temperature': 'mean',
        'humidity': 'mean',
        'rainfall': 'sum'
    }).round(2)
    
    # ECharts용 데이터 준비
    chart_data = {
        'months': monthly_avg.index.strftime('%Y-%m').tolist(),
        'temperature': monthly_avg['temperature'].tolist(),
        'humidity': monthly_avg['humidity'].tolist(),
        'rainfall': monthly_avg['rainfall'].tolist()
    }
    
    # JSON 직렬화
    json_data = {}
    for key, values in chart_data.items():
        if key == 'months':
            json_data[f'{key}_json'] = json.dumps(values, ensure_ascii=False)
        else:
            json_data[f'{key}_json'] = json.dumps(values)
    
    print("📈 시계열 차트용 JSON 데이터:")
    for key, value in json_data.items():
        print(f"{key}: {value[:50]}...")
    
    return json_data

timeseries_data = timeseries_json_serialization()
```

### 🔄 MultiIndex DataFrame 처리

```python
def multiindex_json_serialization():
    """MultiIndex DataFrame의 JSON 직렬화"""
    
    # 🏢 다차원 데이터 생성
    regions = ['서울', '부산', '대구']
    quarters = ['Q1', 'Q2', 'Q3', 'Q4']
    years = [2023, 2024]
    
    # MultiIndex 생성
    index = pd.MultiIndex.from_product(
        [years, quarters, regions],
        names=['year', 'quarter', 'region']
    )
    
    # 랜덤 데이터
    data = {
        'sales': np.random.randint(1000, 10000, len(index)),
        'profit': np.random.randint(100, 1000, len(index)),
        'customers': np.random.randint(50, 500, len(index))
    }
    
    multi_df = pd.DataFrame(data, index=index)
    
    print("🏢 MultiIndex DataFrame:")
    print(multi_df.head())
    
    # 방법 1: reset_index()로 평면화
    flat_df = multi_df.reset_index()
    flat_json = json.dumps(
        flat_df.to_dict('records'),
        ensure_ascii=False,
        indent=2
    )
    
    print("\n1️⃣ 평면화 후 JSON:")
    print(flat_json[:200] + "...")
    
    # 방법 2: 피벗 테이블로 변환
    pivot_df = multi_df.reset_index().pivot_table(
        index=['year', 'quarter'],
        columns='region',
        values='sales',
        aggfunc='sum'
    ).fillna(0)
    
    print("\n2️⃣ 피벗 테이블:")
    print(pivot_df)
    
    # 히트맵용 데이터 준비
    heatmap_data = []
    for i, year_quarter in enumerate(pivot_df.index):
        for j, region in enumerate(pivot_df.columns):
            heatmap_data.append([i, j, int(pivot_df.iloc[i, j])])
    
    heatmap_json = {
        'x_labels': [f"{yq[0]} {yq[1]}" for yq in pivot_df.index],
        'y_labels': pivot_df.columns.tolist(),
        'data': heatmap_data
    }
    
    print("\n3️⃣ 히트맵용 JSON:")
    print(json.dumps(heatmap_json, ensure_ascii=False, indent=2))
    
    return flat_json, heatmap_json

flat, heatmap = multiindex_json_serialization()
```

---

## 날짜/시간 데이터 직렬화

### 📅 다양한 날짜 형식 처리

```python
from datetime import datetime, date, time, timedelta
import pytz

def datetime_json_serialization():
    """날짜/시간 데이터의 JSON 직렬화"""
    
    # 📅 다양한 날짜/시간 객체들
    now = datetime.now()
    today = date.today()
    current_time = time(14, 30, 45)
    utc_now = datetime.now(pytz.UTC)
    seoul_tz = pytz.timezone('Asia/Seoul')
    seoul_now = datetime.now(seoul_tz)
    
    datetime_data = {
        'naive_datetime': now,
        'date_only': today,
        'time_only': current_time,
        'utc_datetime': utc_now,
        'seoul_datetime': seoul_now,
        'timedelta': timedelta(days=7, hours=3, minutes=30)
    }
    
    print("📅 원본 날짜/시간 데이터:")
    for key, value in datetime_data.items():
        print(f"  {key}: {value} ({type(value).__name__})")
    
    # 🔄 JSON 호환 형식으로 변환
    converted_data = {}
    
    for key, value in datetime_data.items():
        if isinstance(value, datetime):
            # ISO 8601 형식으로 변환
            converted_data[key] = value.isoformat()
        elif isinstance(value, date):
            # YYYY-MM-DD 형식
            converted_data[key] = value.isoformat()
        elif isinstance(value, time):
            # HH:MM:SS 형식
            converted_data[key] = value.isoformat()
        elif isinstance(value, timedelta):
            # 총 초 단위로 변환
            converted_data[key] = int(value.total_seconds())
        else:
            converted_data[key] = str(value)
    
    print("\n🔄 변환된 데이터:")
    json_result = json.dumps(converted_data, ensure_ascii=False, indent=2)
    print(json_result)
    
    return converted_data

datetime_converted = datetime_json_serialization()
```

### 🌍 타임존 처리

```python
def timezone_aware_serialization():
    """타임존을 고려한 날짜/시간 직렬화"""
    
    # 🌍 다양한 타임존의 현재 시간
    timezones = {
        'UTC': pytz.UTC,
        'Seoul': pytz.timezone('Asia/Seoul'),
        'Tokyo': pytz.timezone('Asia/Tokyo'),
        'New_York': pytz.timezone('America/New_York'),
        'London': pytz.timezone('Europe/London')
    }
    
    base_time = datetime(2024, 6, 15, 12, 0, 0)  # 정오
    
    timezone_data = {}
    for name, tz in timezones.items():
        localized_time = tz.localize(base_time) if tz != pytz.UTC else base_time.replace(tzinfo=pytz.UTC)
        timezone_data[name] = {
            'datetime': localized_time.isoformat(),
            'timestamp': int(localized_time.timestamp()),
            'readable': localized_time.strftime('%Y-%m-%d %H:%M:%S %Z')
        }
    
    print("🌍 타임존별 시간 데이터:")
    json_result = json.dumps(timezone_data, ensure_ascii=False, indent=2)
    print(json_result)
    
    # JavaScript에서 사용하기 좋은 형식
    js_friendly = {
        'timestamps': [data['timestamp'] for data in timezone_data.values()],
        'labels': list(timezone_data.keys()),
        'iso_strings': [data['datetime'] for data in timezone_data.values()]
    }
    
    print("\n🌐 JavaScript 친화적 형식:")
    js_json = json.dumps(js_friendly, ensure_ascii=False, indent=2)
    print(js_json)
    
    return timezone_data, js_friendly

tz_data, js_data = timezone_aware_serialization()
```

---

## 한글 및 유니코드 처리

### 🔤 한글 직렬화 문제와 해결책

```python
def korean_unicode_handling():
    """한글 및 유니코드 문자 처리"""
    
    # 🇰🇷 한글이 포함된 데이터
    korean_data = {
        'product_name': '프리미엄 김치냉장고',
        'description': '100% 국산 배추로 만든 프리미엄 김치를 보관하는 냉장고',
        'categories': ['가전제품', '주방용품', '냉장고'],
        'reviews': [
            {'user': '김고객', 'rating': 5, 'comment': '정말 좋아요! 👍'},
            {'user': '박구매자', 'rating': 4, 'comment': '가성비 최고 🌟'},
            {'user': '이사용자', 'rating': 5, 'comment': '강력 추천합니다! 💯'}
        ],
        'specs': {
            '용량': '500L',
            '색상': '화이트/스테인리스',
            '에너지효율': '1등급 ⭐⭐⭐⭐⭐'
        }
    }
    
    print("🇰🇷 한글 데이터 직렬화 비교:")
    print("=" * 60)
    
    # ❌ ensure_ascii=True (기본값) - 한글이 유니코드 이스케이프로 변환
    ascii_true = json.dumps(korean_data, ensure_ascii=True, indent=2)
    print("1️⃣ ensure_ascii=True (기본값):")
    print(ascii_true[:200] + "...")
    print(f"길이: {len(ascii_true)} 문자")
    
    # ✅ ensure_ascii=False - 한글이 그대로 유지
    ascii_false = json.dumps(korean_data, ensure_ascii=False, indent=2)
    print(f"\n2️⃣ ensure_ascii=False:")
    print(ascii_false[:200] + "...")
    print(f"길이: {len(ascii_false)} 문자")
    
    # 📊 크기 비교
    print(f"\n📊 크기 비교:")
    print(f"  ASCII True:  {len(ascii_true):,} 문자")
    print(f"  ASCII False: {len(ascii_false):,} 문자")
    print(f"  차이: {len(ascii_true) - len(ascii_false):,} 문자 ({((len(ascii_true) - len(ascii_false)) / len(ascii_false) * 100):.1f}% 증가)")
    
    return korean_data, ascii_false

korean_data, korean_json = korean_unicode_handling()
```

### 🌐 다국어 지원

```python
def multilingual_json_handling():
    """다국어 데이터 JSON 직렬화"""
    
    # 🌍 다국어 데이터
    multilingual_data = {
        'product_id': 'GLOBAL_001',
        'translations': {
            'ko': {
                'name': '글로벌 스마트폰',
                'description': '최신 기술이 집약된 프리미엄 스마트폰',
                'features': ['고성능 프로세서', '뛰어난 카메라', '긴 배터리 수명']
            },
            'en': {
                'name': 'Global Smartphone',
                'description': 'Premium smartphone with cutting-edge technology',
                'features': ['High-performance processor', 'Excellent camera', 'Long battery life']
            },
            'ja': {
                'name': 'グローバルスマートフォン',
                'description': '最新技術を搭載したプレミアムスマートフォン',
                'features': ['高性能プロセッサー', '優秀なカメラ', '長時間バッテリー']
            },
            'zh': {
                'name': '全球智能手机',
                'description': '采用尖端技术的高端智能手机',
                'features': ['高性能处理器', '卓越相机', '长续航电池']
            },
            'ar': {
                'name': 'الهاتف الذكي العالمي',
                'description': 'هاتف ذكي متميز بأحدث التقنيات',
                'features': ['معالج عالي الأداء', 'كاميرا ممتازة', 'بطارية طويلة المدى']
            }
        },
        'emoji_features': ['📱', '📸', '🔋', '⚡', '🌟'],
        'special_chars': 'αβγδε ñáéíóú ❤️🔥💯'
    }
    
    # ✅ 다국어 JSON 직렬화
    multilingual_json = json.dumps(
        multilingual_data,
        ensure_ascii=False,
        indent=2
    )
    
    print("🌍 다국어 JSON 직렬화:")
    print(multilingual_json)
    
    # 📝 UTF-8 파일로 저장
    with open('multilingual_data.json', 'w', encoding='utf-8') as f:
        json.dump(multilingual_data, f, ensure_ascii=False, indent=2)
    
    print(f"\n💾 파일 저장 완료: multilingual_data.json")
    
    return multilingual_data

multilingual = multilingual_json_handling()
```

---

## ECharts 연동 최적화

### 📊 ECharts 데이터 형식 최적화

```python
def echarts_optimized_serialization():
    """ECharts에 최적화된 JSON 직렬화"""
    
    # 📈 차트용 샘플 데이터
    months = ['1월', '2월', '3월', '4월', '5월', '6월']
    sales_2023 = [1200, 1500, 1800, 1600, 2100, 2400]
    sales_2024 = [1400, 1700, 2000, 1800, 2300, 2600]
    categories = ['온라인', '오프라인', '모바일', '전화주문']
    category_values = [35, 25, 30, 10]
    
    # 🎯 방법 1: 개별 데이터 직렬화 (권장)
    individual_json = {
        'months': json.dumps(months, ensure_ascii=False),
        'sales_2023': json.dumps(sales_2023),
        'sales_2024': json.dumps(sales_2024),
        'categories': json.dumps(categories, ensure_ascii=False),
        'category_values': json.dumps(category_values)
    }
    
    print("🎯 방법 1: 개별 직렬화 (권장)")
    for key, value in individual_json.items():
        print(f"  {key}: {value}")
    
    # 🔄 방법 2: 전체 데이터 한번에 직렬화
    all_data = {
        'line_chart': {
            'months': months,
            'sales_2023': sales_2023,
            'sales_2024': sales_2024
        },
        'pie_chart': {
            'categories': categories,
            'values': category_values
        }
    }
    
    all_json = json.dumps(all_data, ensure_ascii=False)
    print(f"\n🔄 방법 2: 전체 직렬화")
    print(f"  all_data: {all_json}")
    
    # 📏 크기 비교
    individual_size = sum(len(v) for v in individual_json.values())
    all_size = len(all_json)
    
    print(f"\n📏 크기 비교:")
    print(f"  개별 직렬화: {individual_size} 문자")
    print(f"  전체 직렬화: {all_size} 문자")
    print(f"  차이: {all_size - individual_size} 문자")
    
    return individual_json, all_data

individual, all_data = echarts_optimized_serialization()
```

### 🚀 대용량 차트 데이터 최적화

```python
def large_chart_data_optimization():
    """대용량 차트 데이터 최적화"""
    
    # 📊 대용량 데이터 시뮬레이션 (1년치 일별 데이터)
    dates = pd.date_range('2024-01-01', '2024-12-31', freq='D')
    large_data = pd.DataFrame({
        'date': dates,
        'value1': np.random.randint(100, 1000, len(dates)),
        'value2': np.random.randint(50, 500, len(dates)),
        'value3': np.random.randint(200, 800, len(dates))
    })
    
    print(f"📊 원본 데이터 크기: {len(large_data):,}행")
    
    # 🎯 최적화 방법 1: 데이터 샘플링
    def sample_data(df, max_points=100):
        """데이터를 균등하게 샘플링"""
        if len(df) <= max_points:
            return df
        
        step = len(df) // max_points
        return df.iloc[::step].copy()
    
    sampled_data = sample_data(large_data, 50)
    print(f"🎯 샘플링 후: {len(sampled_data):,}행")
    
    # 🎯 최적화 방법 2: 집계
    def aggregate_by_month(df):
        """월별로 집계"""
        df_copy = df.copy()
        df_copy['month'] = df_copy['date'].dt.to_period('M')
        
        monthly = df_copy.groupby('month').agg({
            'value1': 'mean',
            'value2': 'mean',
            'value3': 'mean'
        }).round(0)
        
        monthly.index = monthly.index.astype(str)
        return monthly.reset_index()
    
    monthly_data = aggregate_by_month(large_data)
    print(f"🎯 월별 집계 후: {len(monthly_data):,}행")
    
    # 📤 JSON 직렬화 및 크기 비교
    serialization_results = {}
    
    # 원본 데이터
    original_json = json.dumps(large_data.to_dict('records'), default=str)
    serialization_results['original'] = len(original_json)
    
    # 샘플링된 데이터
    sampled_json = json.dumps(sampled_data.to_dict('records'), default=str)
    serialization_results['sampled'] = len(sampled_json)
    
    # 집계된 데이터
    monthly_json = json.dumps(monthly_data.to_dict('records'))
    serialization_results['monthly'] = len(monthly_json)
    
    print("\n📏 JSON 크기 비교:")
    for method, size in serialization_results.items():
        print(f"  {method:8}: {size:,} 문자 ({size/1024:.1f} KB)")
    
    # ECharts용 최종 데이터
    echarts_data = {
        'months': monthly_data['month'].tolist(),
        'value1': monthly_data['value1'].astype(int).tolist(),
        'value2': monthly_data['value2'].astype(int).tolist(),
        'value3': monthly_data['value3'].astype(int).tolist()
    }
    
    echarts_json = {
        'months_json': json.dumps(echarts_data['months'], ensure_ascii=False),
        'value1_json': json.dumps(echarts_data['value1']),
        'value2_json': json.dumps(echarts_data['value2']),
        'value3_json': json.dumps(echarts_data['value3'])
    }
    
    return echarts_json, serialization_results

echarts_optimized, size_comparison = large_chart_data_optimization()
```

---

## 성능 최적화 기법

### ⚡ JSON 직렬화 성능 비교

```python
import time
import ujson  # pip install ujson (옵션)
import orjson  # pip install orjson (옵션)

def json_performance_comparison():
    """다양한 JSON 라이브러리 성능 비교"""
    
    # 📊 테스트용 대용량 데이터 생성
    test_data = {
        'users': [
            {
                'id': i,
                'name': f'사용자{i}',
                'email': f'user{i}@example.com',
                'scores': [np.random.randint(0, 100) for _ in range(10)],
                'created_at': datetime.now().isoformat(),
                'metadata': {
                    'login_count': np.random.randint(1, 1000),
                    'last_ip': f'192.168.1.{i % 255}',
                    'preferences': {
                        'theme': 'dark' if i % 2 else 'light',
                        'language': 'ko',
                        'notifications': True
                    }
                }
            }
            for i in range(10000)  # 10,000개 사용자
        ]
    }
    
    print(f"📊 테스트 데이터 크기: {len(test_data['users']):,}개 레코드")
    
    # 🏃‍♂️ 성능 테스트 함수
    def benchmark_serialization(library_name, serialize_func, data):
        start_time = time.time()
        try:
            result = serialize_func(data)
            end_time = time.time()
            return {
                'library': library_name,
                'time': end_time - start_time,
                'size': len(result) if isinstance(result, (str, bytes)) else 0,
                'success': True
            }
        except Exception as e:
            return {
                'library': library_name,
                'time': float('inf'),
                'size': 0,
                'success': False,
                'error': str(e)
            }
    
    # 📋 테스트할 라이브러리들
    test_cases = [
        ('json (기본)', lambda data: json.dumps(data, ensure_ascii=False)),
        ('json (compact)', lambda data: json.dumps(data, ensure_ascii=False, separators=(',', ':'))),
    ]
    
    # ujson이 설치되어 있다면 테스트
    try:
        import ujson
        test_cases.append(('ujson', lambda data: ujson.dumps(data, ensure_ascii=False)))
    except ImportError:
        print("⚠️ ujson이 설치되지 않음 (pip install ujson)")
    
    # orjson이 설치되어 있다면 테스트
    try:
        import orjson
        test_cases.append(('orjson', lambda data: orjson.dumps(data).decode('utf-8')))
    except ImportError:
        print("⚠️ orjson이 설치되지 않음 (pip install orjson)")
    
    # 🏁 벤치마크 실행
    results = []
    for name, func in test_cases:
        print(f"🏃‍♂️ {name} 테스트 중...")
        result = benchmark_serialization(name, func, test_data)
        results.append(result)
    
    # 📊 결과 출력
    print("\n📊 JSON 직렬화 성능 비교:")
    print("=" * 70)
    print(f"{'라이브러리':<15} {'시간(초)':<10} {'크기(MB)':<10} {'상대속도':<10}")
    print("-" * 70)
    
    fastest_time = min(r['time'] for r in results if r['success'])
    
    for result in sorted(results, key=lambda x: x['time']):
        if result['success']:
            relative_speed = result['time'] / fastest_time
            size_mb = result['size'] / (1024 * 1024)
            print(f"{result['library']:<15} {result['time']:<10.3f} {size_mb:<10.2f} {relative_speed:<10.2f}x")
        else:
            print(f"{result['library']:<15} {'ERROR':<10} {'N/A':<10} {'N/A':<10}")
    
    return results

# 성능 테스트 실행
performance_results = json_performance_comparison()
```

### 🗜️ 압축을 활용한 최적화

```python
import gzip
import base64

def compression_optimization():
    """압축을 활용한 JSON 데이터 최적화"""
    
    # 📊 반복적인 패턴이 많은 데이터 (압축 효과 좋음)
    repetitive_data = {
        'products': [
            {
                'id': i,
                'category': '전자제품',
                'brand': '삼성전자',
                'country': '대한민국',
                'warranty': '2년',
                'shipping': '무료배송',
                'status': '판매중',
                'tags': ['인기상품', '베스트셀러', '추천상품'],
                'specs': {
                    'color': '블랙',
                    'material': '플라스틱',
                    'origin': '한국',
                    'certification': 'KC인증'
                }
            }
            for i in range(5000)
        ]
    }
    
    # 📏 원본 JSON 크기
    original_json = json.dumps(repetitive_data, ensure_ascii=False)
    original_size = len(original_json.encode('utf-8'))
    
    # 🗜️ GZIP 압축
    compressed_data = gzip.compress(original_json.encode('utf-8'))
    compressed_size = len(compressed_data)
    
    # 📦 Base64 인코딩 (웹 전송용)
    base64_encoded = base64.b64encode(compressed_data).decode('ascii')
    base64_size = len(base64_encoded)
    
    print("🗜️ 압축 최적화 결과:")
    print("=" * 50)
    print(f"원본 JSON:     {original_size:,} 바이트 ({original_size/1024:.1f} KB)")
    print(f"GZIP 압축:     {compressed_size:,} 바이트 ({compressed_size/1024:.1f} KB)")
    print(f"Base64 인코딩: {base64_size:,} 바이트 ({base64_size/1024:.1f} KB)")
    print(f"압축율:        {(1 - compressed_size/original_size)*100:.1f}%")
    print(f"전체 압축율:   {(1 - base64_size/original_size)*100:.1f}%")
    
    # 🔄 압축 해제 테스트
    def decompress_json(base64_data):
        compressed_bytes = base64.b64decode(base64_data)
        decompressed_json = gzip.decompress(compressed_bytes).decode('utf-8')
        return json.loads(decompressed_json)
    
    # 검증
    restored_data = decompress_json(base64_encoded)
    is_same = restored_data == repetitive_data
    print(f"데이터 무결성: {'✅ 성공' if is_same else '❌ 실패'}")
    
    return {
        'original_size': original_size,
        'compressed_size': compressed_size,
        'base64_size': base64_size,
        'compression_ratio': compressed_size / original_size,
        'base64_encoded': base64_encoded
    }

compression_result = compression_optimization()
```

---

## 보안 고려사항

### 🔒 JSON 직렬화 보안 이슈

```python
def json_security_considerations():
    """JSON 직렬화 시 보안 고려사항"""
    
    # ⚠️ 보안 위험 요소들
    print("🔒 JSON 직렬화 보안 고려사항:")
    print("=" * 50)
    
    # 1. 민감한 정보 노출 위험
    user_data = {
        'id': 12345,
        'username': 'john_doe',
        'email': 'john@example.com',
        'password_hash': 'hashed_password_here',  # ⚠️ 민감한 정보
        'credit_card': '1234-5678-9012-3456',    # ⚠️ 민감한 정보
        'ssn': '123-45-6789',                    # ⚠️ 민감한 정보
        'profile': {
            'name': 'John Doe',
            'age': 30,
            'city': '서울'
        }
    }
    
    print("❌ 위험한 방법 - 모든 데이터 직렬화:")
    dangerous_json = json.dumps(user_data, ensure_ascii=False, indent=2)
    print(dangerous_json)
    
    # ✅ 안전한 방법 - 화이트리스트 접근
    safe_fields = ['id', 'username', 'email', 'profile']
    safe_data = {key: user_data[key] for key in safe_fields if key in user_data}
    
    print("\n✅ 안전한 방법 - 선택적 직렬화:")
    safe_json = json.dumps(safe_data, ensure_ascii=False, indent=2)
    print(safe_json)
    
    # 2. 데이터 크기 제한
    def safe_json_serialize(data, max_size=1024*1024):  # 1MB 제한
        """안전한 JSON 직렬화 (크기 제한)"""
        try:
            json_string = json.dumps(data, ensure_ascii=False)
            if len(json_string.encode('utf-8')) > max_size:
                raise ValueError(f"JSON 크기가 제한({max_size:,} 바이트)을 초과했습니다.")
            return json_string
        except (TypeError, ValueError) as e:
            print(f"직렬화 실패: {e}")
            return None
    
    # 3. 데이터 검증
    def validate_and_serialize(data):
        """데이터 검증 후 직렬화"""
        
        # 허용된 타입만 직렬화
        allowed_types = (str, int, float, bool, list, dict, type(None))
        
        def is_serializable(obj):
            if isinstance(obj, allowed_types):
                if isinstance(obj, dict):
                    return all(isinstance(k, str) and is_serializable(v) for k, v in obj.items())
                elif isinstance(obj, list):
                    return all(is_serializable(item) for item in obj)
                return True
            return False
        
        if not is_serializable(data):
            raise ValueError("직렬화할 수 없는 타입이 포함되어 있습니다.")
        
        return json.dumps(data, ensure_ascii=False)
    
    # 테스트
    test_data = {
        'safe_string': '안전한 문자열',
        'safe_number': 42,
        'safe_list': [1, 2, '3'],
        'safe_dict': {'nested': 'value'}
    }
    
    try:
        validated_json = validate_and_serialize(test_data)
        print(f"\n✅ 검증된 JSON: {validated_json}")
    except ValueError as e:
        print(f"❌ 검증 실패: {e}")

json_security_considerations()
```

### 🛡️ Django에서의 안전한 JSON 응답

```python
# Django views.py에서의 안전한 JSON 직렬화
from django.http import JsonResponse
from django.core.serializers import serialize
from django.core.exceptions import ValidationError

class SafeJSONEncoder(json.JSONEncoder):
    """안전한 JSON 인코더"""
    
    def default(self, obj):
        # 허용되지 않는 타입들을 안전하게 처리
        if hasattr(obj, '__dict__'):
            # 객체의 __dict__에서 민감한 필드 제외
            safe_dict = {}
            exclude_fields = {'password', 'secret', 'key', 'token', 'hash'}
            
            for key, value in obj.__dict__.items():
                if not any(exclude in key.lower() for exclude in exclude_fields):
                    safe_dict[key] = value
            
            return safe_dict
        
        return super().default(obj)

def safe_json_response(request):
    """안전한 JSON 응답 예제"""
    
    try:
        # 데이터 준비
        response_data = {
            'status': 'success',
            'data': {
                'products': Product.objects.values('id', 'name', 'price')[:10]
            },
            'timestamp': datetime.now().isoformat()
        }
        
        # 안전한 JSON 응답
        return JsonResponse(
            response_data,
            encoder=SafeJSONEncoder,
            json_dumps_params={
                'ensure_ascii': False,
                'separators': (',', ':')  # 컴팩트한 출력
            }
        )
        
    except Exception as e:
        # 에러 정보는 최소한으로
        return JsonResponse({
            'status': 'error',
            'message': '요청을 처리할 수 없습니다.'
        }, status=500)
```

---

## 실전 예제 모음

### 🎯 Django + ECharts 완전 연동

```python
# views.py - 완전한 대시보드 예제
def dashboard_view(request):
    """ECharts 대시보드용 JSON 데이터 준비"""
    
    # 📊 차트 1: 월별 매출 추이
    monthly_sales = get_monthly_sales_data()  # 사용자 정의 함수
    
    # 📊 차트 2: 제품 카테고리별 판매량
    category_data = get_category_sales_data()
    
    # 📊 차트 3: 지역별 매출 히트맵
    region_data = get_region_heatmap_data()
    
    # 📊 차트 4: 실시간 접속자 수
    realtime_data = get_realtime_visitors()
    
    # JSON 직렬화
    context = {
        # 월별 매출 라인 차트
        'monthly_labels_json': json.dumps(
            [item['month'] for item in monthly_sales], 
            ensure_ascii=False
        ),
        'monthly_values_json': json.dumps(
            [float(item['total']) for item in monthly_sales]
        ),
        
        # 카테고리 파이 차트
        'category_data_json': json.dumps([
            {'name': item['category'], 'value': item['count']}
            for item in category_data
        ], ensure_ascii=False),
        
        # 지역 히트맵
        'region_heatmap_json': json.dumps([
            [item['x'], item['y'], item['value']]
            for item in region_data
        ]),
        
        # 실시간 데이터
        'realtime_visitors_json': json.dumps(realtime_data),
        
        # 대시보드 메타데이터
        'dashboard_meta_json': json.dumps({
            'last_updated': datetime.now().isoformat(),
            'total_charts': 4,
            'data_range': '2024-01-01 ~ 2024-12-31'
        }, ensure_ascii=False)
    }
    
    return render(request, 'dashboard.html', context)

# 헬퍼 함수들
def get_monthly_sales_data():
    """월별 매출 데이터 조회"""
    from django.db.models import Sum
    from django.db.models.functions import TruncMonth
    
    return list(
        Sale.objects
        .annotate(month=TruncMonth('sale_date'))
        .values('month')
        .annotate(total=Sum('total_amount'))
        .order_by('month')
        .values('month__strftime:%Y-%m', 'total')
    )

def get_category_sales_data():
    """카테고리별 판매 데이터"""
    from django.db.models import Count
    
    return list(
        Product.objects
        .values('category')
        .annotate(count=Count('id'))
        .order_by('-count')
    )

def get_region_heatmap_data():
    """지역별 히트맵 데이터"""
    regions = ['서울', '부산', '대구', '인천', '광주']
    months = list(range(12))
    
    heatmap_data = []
    for i, region in enumerate(regions):
        for j, month in enumerate(months):
            # 실제로는 데이터베이스에서 조회
            value = Sale.objects.filter(
                region=region,
                sale_date__month=month+1
            ).aggregate(total=Sum('total_amount'))['total'] or 0
            
            heatmap_data.append({
                'x': j,  # 월 인덱스
                'y': i,  # 지역 인덱스  
                'value': float(value)
            })
    
    return heatmap_data

def get_realtime_visitors():
    """실시간 접속자 데이터 (Redis나 캐시에서 조회)"""
    from django.core.cache import cache
    
    return cache.get('realtime_visitors', 0)
```

### 🌐 템플릿에서 JSON 데이터 사용

```html
<!-- dashboard.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 대시보드</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="container-fluid py-4">
        <h1 class="mb-4">📊 실시간 대시보드</h1>
        
        <!-- 차트 그리드 -->
        <div class="row g-4">
            <!-- 월별 매출 추이 -->
            <div class="col-lg-6">
                <div class="card">
                    <div class="card-header">
                        <h5>📈 월별 매출 추이</h5>
                    </div>
                    <div class="card-body">
                        <div id="monthlySalesChart" style="height: 300px;"></div>
                    </div>
                </div>
            </div>
            
            <!-- 카테고리별 판매량 -->
            <div class="col-lg-6">
                <div class="card">
                    <div class="card-header">
                        <h5>🥧 카테고리별 판매량</h5>
                    </div>
                    <div class="card-body">
                        <div id="categoryPieChart" style="height: 300px;"></div>
                    </div>
                </div>
            </div>
            
            <!-- 지역별 매출 히트맵 -->
            <div class="col-lg-8">
                <div class="card">
                    <div class="card-header">
                        <h5>🗺️ 지역별 매출 히트맵</h5>
                    </div>
                    <div class="card-body">
                        <div id="regionHeatmap" style="height: 400px;"></div>
                    </div>
                </div>
            </div>
            
            <!-- 실시간 지표 -->
            <div class="col-lg-4">
                <div class="card">
                    <div class="card-header">
                        <h5>⚡ 실시간 지표</h5>
                    </div>
                    <div class="card-body">
                        <div class="text-center">
                            <h2 class="text-primary" id="realtimeVisitors">
                                {{ realtime_visitors_json|safe }}
                            </h2>
                            <p>현재 접속자</p>
                        </div>
                        
                        <div id="gaugeChart" style="height: 200px;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 🎯 Django에서 전달받은 JSON 데이터
        const monthlyLabels = {{ monthly_labels_json|safe }};
        const monthlyValues = {{ monthly_values_json|safe }};
        const categoryData = {{ category_data_json|safe }};
        const regionHeatmapData = {{ region_heatmap_json|safe }};
        const realtimeVisitors = {{ realtime_visitors_json|safe }};
        const dashboardMeta = {{ dashboard_meta_json|safe }};
        
        // 🎨 차트 색상 팔레트
        const colorPalette = ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de'];
        
        // 📈 월별 매출 라인 차트
        const monthlySalesChart = echarts.init(document.getElementById('monthlySalesChart'));
        const monthlySalesOption = {
            tooltip: {
                trigger: 'axis',
                formatter: function(params) {
                    return `${params[0].name}<br/>매출: ${params[0].value.toLocaleString()}원`;
                }
            },
            xAxis: {
                type: 'category',
                data: monthlyLabels,
                axisLabel: { rotate: 45 }
            },
            yAxis: {
                type: 'value',
                axisLabel: {
                    formatter: function(value) {
                        return (value / 1000000) + 'M';
                    }
                }
            },
            series: [{
                name: '매출',
                type: 'line',
                data: monthlyValues,
                smooth: true,
                lineStyle: { width: 3, color: colorPalette[0] },
                areaStyle: {
                    color: {
                        type: 'linear',
                        x: 0, y: 0, x2: 0, y2: 1,
                        colorStops: [
                            {offset: 0, color: colorPalette[0] + '80'},
                            {offset: 1, color: colorPalette[0] + '10'}
                        ]
                    }
                }
            }]
        };
        monthlySalesChart.setOption(monthlySalesOption);
        
        // 🥧 카테고리 파이 차트
        const categoryPieChart = echarts.init(document.getElementById('categoryPieChart'));
        const categoryPieOption = {
            tooltip: {
                trigger: 'item',
                formatter: '{a} <br/>{b}: {c} ({d}%)'
            },
            legend: {
                orient: 'vertical',
                left: 'left'
            },
            series: [{
                name: '카테고리',
                type: 'pie',
                radius: '50%',
                data: categoryData,
                emphasis: {
                    itemStyle: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }]
        };
        categoryPieChart.setOption(categoryPieOption);
        
        // 🗺️ 지역별 히트맵
        const regionHeatmap = echarts.init(document.getElementById('regionHeatmap'));
        const regions = ['서울', '부산', '대구', '인천', '광주'];
        const months = ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'];
        
        const regionHeatmapOption = {
            tooltip: {
                position: 'top',
                formatter: function(params) {
                    return `${months[params.data[0]]} ${regions[params.data[1]]}<br/>매출: ${params.data[2].toLocaleString()}원`;
                }
            },
            grid: {
                height: '50%',
                top: '10%'
            },
            xAxis: {
                type: 'category',
                data: months,
                splitArea: { show: true }
            },
            yAxis: {
                type: 'category',
                data: regions,
                splitArea: { show: true }
            },
            visualMap: {
                min: 0,
                max: Math.max(...regionHeatmapData.map(item => item[2])),
                calculable: true,
                orient: 'horizontal',
                left: 'center',
                bottom: '15%',
                inRange: {
                    color: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffcc', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026']
                }
            },
            series: [{
                name: '매출',
                type: 'heatmap',
                data: regionHeatmapData,
                label: {
                    show: true,
                    formatter: function(params) {
                        return (params.data[2] / 1000000).toFixed(1) + 'M';
                    }
                },
                emphasis: {
                    itemStyle: {
                        shadowBlur: 10,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }]
        };
        regionHeatmap.setOption(regionHeatmapOption);
        
        // ⚡ 실시간 접속자 게이지 차트
        const gaugeChart = echarts.init(document.getElementById('gaugeChart'));
        const gaugeOption = {
            series: [{
                name: '접속자',
                type: 'gauge',
                startAngle: 180,
                endAngle: 0,
                center: ['50%', '75%'],
                radius: '90%',
                min: 0,
                max: 1000,
                splitNumber: 8,
                axisLine: {
                    lineStyle: {
                        width: 6,
                        color: [
                            [0.25, '#7CFFB2'],
                            [0.5, '#58D9F9'],
                            [0.75, '#FDDD60'],
                            [1, '#FF6E76']
                        ]
                    }
                },
                pointer: {
                    icon: 'path://M12.8,0.7l12,40.1H0.7L12.8,0.7z',
                    length: '12%',
                    width: 20,
                    offsetCenter: [0, '-60%'],
                    itemStyle: {
                        color: 'auto'
                    }
                },
                axisTick: {
                    length: 12,
                    lineStyle: {
                        color: 'auto',
                        width: 2
                    }
                },
                splitLine: {
                    length: 20,
                    lineStyle: {
                        color: 'auto',
                        width: 5
                    }
                },
                axisLabel: {
                    color: '#464646',
                    fontSize: 20,
                    distance: -60,
                    formatter: function(value) {
                        if (value === 1000) {
                            return '1K';
                        } else if (value === 750) {
                            return '750';
                        } else if (value === 500) {
                            return '500';
                        } else if (value === 250) {
                            return '250';
                        } else if (value === 0) {
                            return '0';
                        }
                        return '';
                    }
                },
                title: {
                    offsetCenter: [0, '-10%'],
                    fontSize: 20
                },
                detail: {
                    fontSize: 30,
                    offsetCenter: [0, '-35%'],
                    valueAnimation: true,
                    formatter: function(value) {
                        return Math.round(value) + '';
                    },
                    color: 'auto'
                },
                data: [{
                    value: realtimeVisitors,
                    name: '실시간 접속자'
                }]
            }]
        };
        gaugeChart.setOption(gaugeOption);
        
        // 📱 반응형 처리
        function resizeCharts() {
            monthlySalesChart.resize();
            categoryPieChart.resize();
            regionHeatmap.resize();
            gaugeChart.resize();
        }
        
        window.addEventListener('resize', resizeCharts);
        
        // 🔄 실시간 데이터 업데이트 (5초마다)
        function updateRealtimeData() {
            fetch('/api/realtime-visitors/')
                .then(response => response.json())
                .then(data => {
                    // 접속자 수 업데이트
                    document.getElementById('realtimeVisitors').textContent = data.visitors;
                    
                    // 게이지 차트 업데이트
                    gaugeChart.setOption({
                        series: [{
                            data: [{
                                value: data.visitors,
                                name: '실시간 접속자'
                            }]
                        }]
                    });
                })
                .catch(error => console.error('실시간 데이터 업데이트 실패:', error));
        }
        
        // 5초마다 실시간 데이터 업데이트
        setInterval(updateRealtimeData, 5000);
        
        // 📊 대시보드 메타데이터 표시
        console.log('대시보드 정보:', dashboardMeta);
        console.log('마지막 업데이트:', dashboardMeta.last_updated);
    </script>
</body>
</html>
```

### 🔄 API 엔드포인트 구현

```python
# API views.py
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt
from django.core.cache import cache
import json

@require_http_methods(["GET"])
def realtime_visitors_api(request):
    """실시간 접속자 수 API"""
    try:
        # Redis나 캐시에서 실시간 데이터 조회
        visitors = cache.get('realtime_visitors', 0)
        
        # 시뮬레이션: 랜덤하게 변화
        import random
        visitors += random.randint(-10, 20)
        visitors = max(0, min(1000, visitors))  # 0-1000 범위로 제한
        
        # 캐시 업데이트
        cache.set('realtime_visitors', visitors, timeout=10)
        
        return JsonResponse({
            'visitors': visitors,
            'timestamp': datetime.now().isoformat(),
            'status': 'success'
        })
        
    except Exception as e:
        return JsonResponse({
            'error': '실시간 데이터를 가져올 수 없습니다.',
            'status': 'error'
        }, status=500)

@csrf_exempt
@require_http_methods(["POST"])
def chart_data_export_api(request):
    """차트 데이터 내보내기 API"""
    try:
        # 요청 데이터 파싱
        request_data = json.loads(request.body)
        chart_type = request_data.get('chart_type')
        date_range = request_data.get('date_range', {})
        
        # 차트 타입별 데이터 준비
        if chart_type == 'monthly_sales':
            data = get_monthly_sales_data()
            filename = 'monthly_sales.json'
        elif chart_type == 'category_sales':
            data = get_category_sales_data() 
            filename = 'category_sales.json'
        elif chart_type == 'region_heatmap':
            data = get_region_heatmap_data()
            filename = 'region_heatmap.json'
        else:
            return JsonResponse({
                'error': '지원하지 않는 차트 타입입니다.',
                'status': 'error'
            }, status=400)
        
        # JSON 응답
        response_data = {
            'chart_type': chart_type,
            'data': data,
            'generated_at': datetime.now().isoformat(),
            'filename': filename,
            'record_count': len(data)
        }
        
        return JsonResponse(
            response_data,
            json_dumps_params={
                'ensure_ascii': False,
                'indent': 2
            }
        )
        
    except json.JSONDecodeError:
        return JsonResponse({
            'error': '잘못된 JSON 형식입니다.',
            'status': 'error'
        }, status=400)
    except Exception as e:
        return JsonResponse({
            'error': f'데이터 내보내기 실패: {str(e)}',
            'status': 'error'
        }, status=500)
```

### 📱 모바일 최적화 JSON

```python
def mobile_optimized_json(request):
    """모바일용 최적화된 JSON 응답"""
    
    # 📱 모바일에서는 데이터 양을 줄임
    user_agent = request.META.get('HTTP_USER_AGENT', '').lower()
    is_mobile = any(mobile in user_agent for mobile in ['mobile', 'android', 'iphone'])
    
    if is_mobile:
        # 모바일용: 데이터 포인트 제한
        monthly_data = get_monthly_sales_data()[:6]  # 최근 6개월만
        category_data = get_category_sales_data()[:5]  # 상위 5개 카테고리만
        
        # 압축된 응답
        context = {
            'monthly_data_json': json.dumps(monthly_data, separators=(',', ':')),
            'category_data_json': json.dumps(category_data, separators=(',', ':')),
            'is_mobile': True,
            'data_compressed': True
        }
    else:
        # 데스크톱용: 전체 데이터
        context = {
            'monthly_data_json': json.dumps(get_monthly_sales_data(), ensure_ascii=False, indent=2),
            'category_data_json': json.dumps(get_category_sales_data(), ensure_ascii=False, indent=2),
            'region_data_json': json.dumps(get_region_heatmap_data()),
            'is_mobile': False,
            'data_compressed': False
        }
    
    return JsonResponse(context)
```

---

## 마무리 및 베스트 프랙티스 정리

### ✅ JSON 직렬화 체크리스트

```python
def json_serialization_checklist():
    """JSON 직렬화 체크리스트"""
    
    checklist = {
        "🔧 기본 설정": [
            "✅ ensure_ascii=False로 한글 지원",
            "✅ indent 옵션으로 가독성 향상 (개발시)",
            "✅ separators=(',', ':')로 압축 (운영시)",
            "✅ 적절한 timeout 설정"
        ],
        
        "🛡️ 보안": [
            "✅ 민감한 정보 필터링",
            "✅ 데이터 크기 제한",
            "✅ 입력값 검증",
            "✅ 에러 정보 최소화"
        ],
        
        "⚡ 성능": [
            "✅ 대용량 데이터 샘플링",
            "✅ 불필요한 중첩 구조 평면화",
            "✅ 적절한 캐싱 전략",
            "✅ 압축 고려 (gzip)"
        ],
        
        "🎯 ECharts 연동": [
            "✅ 개별 데이터 직렬화",
            "✅ JavaScript 친화적 형식",
            "✅ 차트별 최적화된 구조",
            "✅ 반응형 데이터 준비"
        ],
        
        "🌐 Django 특화": [
            "✅ |safe 필터 사용",
            "✅ Custom Encoder 활용",
            "✅ 모델 직렬화 최적화",
            "✅ API 엔드포인트 표준화"
        ]
    }
    
    print("📋 JSON 직렬화 완벽 체크리스트")
    print("=" * 50)
    
    for category, items in checklist.items():
        print(f"\n{category}")
        for item in items:
            print(f"  {item}")
    
    return checklist

# 체크리스트 출력
final_checklist = json_serialization_checklist()
```

### 🎯 핵심 요약

1. **🔤 한글 처리**: `ensure_ascii=False` 필수
2. **🛡️ 보안**: 민감한 데이터 필터링과 크기 제한
3. **⚡ 성능**: 대용량 데이터 최적화와 압축 활용
4. **🎨 ECharts**: 개별 직렬화로 JavaScript 친화적 구조
5. **📱 반응형**: 디바이스별 최적화된 데이터 제공

### 🚀 다음 단계

이제 JSON 직렬화를 완벽하게 마스터했으니:
- **20.02.01 ECharts 가이드**와 결합해서 고급 차트 구현
- **실시간 데이터 업데이트** 시스템 구축
- **대용량 데이터 처리** 최적화 기법 적용
- **모바일 최적화** 및 **PWA** 기능 추가

JSON 직렬화는 모든 웹 개발의 기초입니다. 이 가이드를 통해 Django에서 JavaScript로 데이터를 안전하고 효율적으로 전달하는 모든 기법을 마스터하셨습니다! 🎉