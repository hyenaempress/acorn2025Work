# 20.03.03 Django ORM 사용 관련 완전 가이드 - 실무 패턴과 성능 최적화

## 목차
1. [Django ORM vs Raw SQL 선택 기준](#django-orm-vs-raw-sql-선택-기준)
2. [Django ORM 핵심 원칙과 패턴](#django-orm-핵심-원칙과-패턴)
3. [ORM 뷰 함수 구현](#orm-뷰-함수-구현)
4. [ORM 전용 템플릿 구성](#orm-전용-템플릿-구성)
5. [모델 설정 및 관계 정의](#모델-설정-및-관계-정의)
6. [성능 최적화 기법](#성능-최적화-기법)
7. [실무 활용 패턴](#실무-활용-패턴)
8. [트러블슈팅](#트러블슈팅)

---

## Django ORM vs Raw SQL 선택 기준

### 강사님의 실무 조언
> **"장고 ORM을 써도 되고 그냥 Raw SQL 문장을 써도 괜찮아요. 편한 걸로 하시면 됩니다."**

### 📊 선택 기준표

| 상황 | Django ORM | Raw SQL | 권장 |
|------|-----------|---------|------|
| 단순 CRUD | ✅ 매우 적합 | ⚠️ 과도함 | **ORM** |
| 복잡한 JOIN | ⚠️ 가능하지만 복잡 | ✅ 직관적 | **상황별** |
| 집계 쿼리 | ✅ 적합 | ✅ 적합 | **상황별** |
| 성능 최적화 | ⚠️ 제한적 | ✅ 완전 제어 | **Raw SQL** |
| 보안 중요 | ✅ 자동 방지 | ⚠️ 주의 필요 | **ORM** |
| 팀 협업 | ✅ 가독성 좋음 | ⚠️ SQL 지식 필요 | **ORM** |
| 빠른 개발 | ✅ 매우 빠름 | ⚠️ 시간 소요 | **ORM** |
| DB 독립성 | ✅ 완전 독립 | ❌ DB 종속 | **ORM** |

### 🎯 실무 권장 패턴

#### 1. ORM 우선 사용 케이스
```python
# ✅ 이런 경우는 ORM이 더 좋습니다
# 단순 조회
users = User.objects.filter(is_active=True)

# 기본 관계 조회
posts = Post.objects.select_related('author').filter(published=True)

# 간단한 집계
user_count = User.objects.count()
avg_age = User.objects.aggregate(avg_age=Avg('age'))
```

#### 2. Raw SQL 권장 케이스
```python
# ✅ 이런 경우는 Raw SQL이 더 효율적입니다
# 복잡한 집계 쿼리
sql = """
SELECT 
    dept.name,
    COUNT(emp.id) as emp_count,
    AVG(emp.salary) as avg_salary,
    RANK() OVER (ORDER BY AVG(emp.salary) DESC) as salary_rank
FROM departments dept
LEFT JOIN employees emp ON dept.id = emp.dept_id
GROUP BY dept.id, dept.name
HAVING COUNT(emp.id) > 5
"""

# 성능이 중요한 대용량 데이터 처리
with connection.cursor() as cursor:
    cursor.execute(sql)
    results = cursor.fetchall()
```

#### 3. 혼용 패턴
```python
# 🎯 실무에서는 이렇게 혼용합니다
def get_department_analysis(request):
    # ORM으로 기본 조회
    departments = Department.objects.filter(active=True)
    
    # Raw SQL로 복잡한 분석
    analysis_sql = """
    SELECT dept_id, complex_calculation(...)
    FROM complex_analysis_view
    WHERE conditions...
    """
    
    # 결과 조합
    return combine_results(departments, analysis_sql)
```

---

## Django ORM 핵심 원칙과 패턴

### 🔥 LAZY EVALUATION (지연 평가)
QuerySet은 실제로 데이터가 필요할 때까지 DB에 접근하지 않습니다.

```python
# 이 시점에서는 DB에 접근하지 않음
queryset = User.objects.filter(is_active=True)
queryset = queryset.order_by('username')
queryset = queryset.select_related('profile')

# 이 시점에서 실제 DB 쿼리 실행
users = list(queryset)  # 또는 for user in queryset:
```

### 📋 주요 QuerySet 메서드

#### 1. 기본 조회 메서드
```python
# 전체 조회
User.objects.all()

# 조건 필터링
User.objects.filter(is_active=True)          # WHERE is_active = True
User.objects.exclude(is_active=False)        # WHERE NOT is_active = False

# 단일 객체 조회
User.objects.get(id=1)                       # 없으면 DoesNotExist 예외
User.objects.filter(id=1).first()            # 없으면 None 반환

# 존재 여부 확인
User.objects.filter(email='test@test.com').exists()
```

#### 2. 정렬 및 제한
```python
# 정렬
User.objects.order_by('username')            # 오름차순
User.objects.order_by('-created_at')         # 내림차순
User.objects.order_by('department', '-salary')  # 다중 정렬

# 제한
User.objects.all()[:10]                      # LIMIT 10
User.objects.all()[10:20]                    # OFFSET 10 LIMIT 10
```

#### 3. 필드 룩업 (Field Lookups)
```python
# 정확 일치
User.objects.filter(username__exact='admin')
User.objects.filter(username__iexact='ADMIN')  # 대소문자 무시

# 부분 일치
User.objects.filter(username__contains='admin')      # LIKE '%admin%'
User.objects.filter(username__icontains='ADMIN')     # 대소문자 무시
User.objects.filter(username__startswith='ad')       # LIKE 'ad%'
User.objects.filter(username__endswith='min')        # LIKE '%min'

# 범위
User.objects.filter(age__gt=18)              # age > 18
User.objects.filter(age__gte=18)             # age >= 18
User.objects.filter(age__lt=65)              # age < 65
User.objects.filter(age__lte=65)             # age <= 65
User.objects.filter(age__range=(18, 65))     # BETWEEN 18 AND 65

# 리스트 포함
User.objects.filter(department__in=['IT', 'HR'])  # IN ('IT', 'HR')

# NULL 체크
User.objects.filter(phone__isnull=True)      # IS NULL
User.objects.filter(phone__isnull=False)     # IS NOT NULL

# 날짜
User.objects.filter(created_at__year=2024)
User.objects.filter(created_at__month=3)
User.objects.filter(created_at__day=15)
User.objects.filter(created_at__date='2024-03-15')
```

---

## ORM 뷰 함수 구현

### 🏢 완전한 ORM 뷰 함수

```python
# myapp/views.py - ORM 활용 버전

from django.shortcuts import render
from django.db.models import Count, Avg, Sum, Q, F, Max, Min, Case, When, IntegerField
from django.db.models import Exists, OuterRef
from django.utils.html import escape
from django.utils import timezone
from .models import Jikwon, Buser, Gogek
import pandas as pd

def ormAnalysisFunc(request):
    """Django ORM을 활용한 직원 정보 분석"""
    
    # 사용자 입력 처리 (XSS 방지)
    dept = (request.GET.get('dept') or "").strip()
    safe_dept = escape(dept)

    # =================================================================
    # 1. 기본 ORM 조회 - SELECT_RELATED로 JOIN 최적화
    # =================================================================
    
    # Raw SQL: SELECT j.*, b.busername FROM jikwon j INNER JOIN buser b ON j.busernum = b.buserno
    # ORM 버전: select_related()를 사용한 효율적인 JOIN
    jikwons_query = Jikwon.objects.select_related('busernum')
    
    # 부서 필터링 (SQL 인젝션 자동 방지)
    if dept:
        # Raw SQL: WHERE b.busername LIKE '%dept%'
        # ORM 버전: 안전한 필터링
        jikwons_query = jikwons_query.filter(
            busernum__busername__icontains=dept  # 대소문자 무시 부분 검색
        )
    
    # 정렬 (ORDER BY)
    jikwons = jikwons_query.order_by('jikwonno')
    
    # =================================================================
    # 2. 집계 함수 활용 - 부서별 상세 통계
    # =================================================================
    
    dept_stats = (
        Buser.objects
        .annotate(
            직원수=Count('jikwon'),                    # COUNT(*)
            평균연봉=Avg('jikwon__jikwonpay'),          # AVG(jikwonpay)
            총연봉=Sum('jikwon__jikwonpay'),           # SUM(jikwonpay)
            최고연봉=Max('jikwon__jikwonpay'),          # MAX(jikwonpay)
            최저연봉=Min('jikwon__jikwonpay'),          # MIN(jikwonpay)
            남성직원수=Count(
                Case(When(jikwon__jikwongen='남', then=1), 
                     output_field=IntegerField())
            ),
            여성직원수=Count(
                Case(When(jikwon__jikwongen='여', then=1), 
                     output_field=IntegerField())
            )
        )
        .filter(직원수__gt=0)                         # HAVING COUNT(*) > 0
        .order_by('-평균연봉')                        # ORDER BY 평균연봉 DESC
    )
    
    # =================================================================
    # 3. Q 객체를 활용한 복잡한 조건 쿼리
    # =================================================================
    
    # Raw SQL: WHERE (jikwonpay > 4000 AND jikwonjik = '부장') OR jikwongen = '남'
    high_performers = Jikwon.objects.filter(
        Q(jikwonpay__gt=4000, jikwonjik='부장') |     # AND 조건
        Q(jikwongen='남')                            # OR 조건
    ).select_related('busernum')
    
    # =================================================================
    # 4. F 객체를 활용한 필드 간 연산
    # =================================================================
    
    # 근속년수 계산 (데이터베이스 레벨에서 계산)
    current_year = timezone.now().year
    jikwons_with_years = Jikwon.objects.annotate(
        근속년수=current_year - F('jikwonibsail__year'),
        연봉대비효율성=F('jikwonpay') / (current_year - F('jikwonibsail__year') + 1)
    ).select_related('busernum')
    
    # =================================================================
    # 5. EXISTS와 서브쿼리 활용
    # =================================================================
    
    # 고객을 담당하는 직원만 조회
    # Raw SQL: SELECT * FROM jikwon WHERE EXISTS (SELECT 1 FROM gogek WHERE gogekdamsano = jikwonno)
    has_customers = Gogek.objects.filter(gogekdamsano=OuterRef('jikwonno'))
    jikwons_with_customers = Jikwon.objects.filter(
        Exists(has_customers)
    ).select_related('busernum')
    
    # =================================================================
    # 6. 직급별 분석 - VALUES()와 ANNOTATE() 조합
    # =================================================================
    
    position_analysis = (
        Jikwon.objects
        .values('jikwonjik')                         # GROUP BY jikwonjik
        .annotate(
            인원수=Count('jikwonno'),
            평균연봉=Avg('jikwonpay'),
            연봉합계=Sum('jikwonpay'),
            평균근속년수=Avg(current_year - F('jikwonibsail__year'))
        )
        .order_by('-평균연봉')
    )
    
    # =================================================================
    # 7. 조건부 집계 - CASE WHEN 활용
    # =================================================================
    
    gender_stats = Jikwon.objects.aggregate(
        남성직원수=Count(
            Case(When(jikwongen='남', then=1), output_field=IntegerField())
        ),
        여성직원수=Count(
            Case(When(jikwongen='여', then=1), output_field=IntegerField())
        ),
        남성평균연봉=Avg(
            Case(When(jikwongen='남', then='jikwonpay'), output_field=IntegerField())
        ),
        여성평균연봉=Avg(
            Case(When(jikwongen='여', then='jikwonpay'), output_field=IntegerField())
        ),
        고연봉직원수=Count(
            Case(When(jikwonpay__gte=5000, then=1), output_field=IntegerField())
        )
    )
    
    # =================================================================
    # 8. 데이터 처리 및 DataFrame 변환
    # =================================================================
    
    # 직원 목록 데이터 준비
    jikwon_data = []
    for j in jikwons:
        jikwon_data.append({
            '직원번호': j.jikwonno,
            '직원명': j.jikwonname,
            '부서명': j.busernum.busername if j.busernum else '미배정',
            '부서전화': j.busernum.busertel if j.busernum else '',
            '직급': j.jikwonjik or '미지정',
            '연봉': j.jikwonpay or 0,
            '성별': j.jikwongen or '미지정',
            '입사일': j.jikwonibsail.strftime('%Y-%m-%d') if j.jikwonibsail else ''
        })
    
    # DataFrame으로 변환 및 HTML 테이블 생성
    if jikwon_data:
        df_jikwon = pd.DataFrame(jikwon_data)
        join_html = df_jikwon.to_html(
            index=False,
            classes='table table-striped table-hover'
        )
    else:
        join_html = "<p class='text-center text-muted'>조건에 맞는 직원이 없습니다.</p>"
    
    # 부서별 통계 데이터 준비
    dept_data = []
    for dept_stat in dept_stats:
        dept_data.append({
            '부서명': dept_stat.busername,
            '직원수': dept_stat.직원수,
            '남성': dept_stat.남성직원수,
            '여성': dept_stat.여성직원수,
            '평균연봉': round(dept_stat.평균연봉 or 0),
            '총연봉': dept_stat.총연봉 or 0,
            '최고연봉': dept_stat.최고연봉 or 0,
            '최저연봉': dept_stat.최저연봉 or 0
        })
    
    # 부서 통계 HTML 생성
    if dept_data:
        df_dept = pd.DataFrame(dept_data)
        dept_html = df_dept.to_html(
            index=False,
            classes='table table-info table-striped'
        )
    else:
        dept_html = "<p class='text-center text-muted'>부서 데이터가 없습니다.</p>"
    
    # 직급별 분석 데이터 준비
    position_data = []
    for pos in position_analysis:
        position_data.append({
            '직급': pos['jikwonjik'] or '미지정',
            '인원수': pos['인원수'],
            '평균연봉': round(pos['평균연봉'] or 0),
            '연봉합계': pos['연봉합계'] or 0,
            '평균근속년수': round(pos['평균근속년수'] or 0, 1)
        })
    
    # 직급별 분석 HTML 생성
    if position_data:
        df_position = pd.DataFrame(position_data)
        position_html = df_position.to_html(
            index=False,
            classes='table table-success table-striped'
        )
    else:
        position_html = "<p class='text-center text-muted'>직급 데이터가 없습니다.</p>"
    
    # =================================================================
    # 9. 추가 분석 - 성과 지표
    # =================================================================
    
    # 부서별 성과 분석
    performance_analysis = (
        Buser.objects
        .annotate(
            평균연봉=Avg('jikwon__jikwonpay'),
            평균근속년수=Avg(current_year - F('jikwon__jikwonibsail__year')),
            직원수=Count('jikwon')
        )
        .filter(직원수__gt=0)
        .annotate(
            효율성점수=F('평균연봉') / F('평균근속년수')  # 연봉 대비 근속년수 효율성
        )
        .order_by('-효율성점수')
    )
    
    # 템플릿으로 전달할 컨텍스트
    context = {
        'join_html': join_html,
        'dept_html': dept_html,
        'position_html': position_html,
        'dept': safe_dept,
        'total_count': len(jikwon_data),
        'dept_count': len(dept_data),
        'gender_stats': gender_stats,
        'high_performers_count': high_performers.count(),
        'customers_staff_count': jikwons_with_customers.count(),
        'performance_analysis': performance_analysis[:5],  # 상위 5개 부서
        
        # 추가 통계
        'avg_salary': round(gender_stats.get('남성평균연봉', 0) or 0),
        'total_departments': dept_stats.count(),
        'active_positions': position_analysis.count(),
    }
    
    return render(request, 'orm_analysis.html', context)

# =================================================================
# ORM 기본 패턴 예제 모음
# =================================================================

def ormBasicExamples(request):
    """ORM 기본 사용법 예제 모음"""
    
    examples = {
        'basic_queries': {
            '전체_조회': Jikwon.objects.all(),
            '조건_필터링': Jikwon.objects.filter(jikwonjik='부장'),
            '다중_조건': Jikwon.objects.filter(jikwonjik='부장', jikwongen='남'),
            '제외_조건': Jikwon.objects.exclude(jikwonpay__lt=3000),
            '정렬': Jikwon.objects.order_by('-jikwonpay'),
        },
        
        'advanced_queries': {
            'Q_객체_활용': Jikwon.objects.filter(
                Q(jikwonpay__gte=5000) | Q(jikwonjik='대표')
            ),
            'F_객체_활용': Jikwon.objects.filter(
                jikwonpay__gt=F('busernum__id') * 1000
            ),
            '서브쿼리': Jikwon.objects.filter(
                jikwonno__in=Gogek.objects.values('gogekdamsano')
            ),
        },
        
        'aggregation': {
            '집계함수': Jikwon.objects.aggregate(
                평균연봉=Avg('jikwonpay'),
                최고연봉=Max('jikwonpay'),
                직원수=Count('jikwonno')
            ),
            '그룹별_집계': Jikwon.objects.values('jikwonjik').annotate(
                인원수=Count('jikwonno'),
                평균연봉=Avg('jikwonpay')
            ),
        }
    }
    
    return render(request, 'orm_examples.html', {'examples': examples})
```

---

## ORM 전용 템플릿 구성

### 🎨 고급 ORM 분석 템플릿

```html
<!-- templates/orm_analysis.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Django ORM 고급 분석 - 직원 정보 시스템</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .orm-badge { 
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .method-tag {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            color: #495057;
            margin: 2px;
            display: inline-block;
        }
        .sql-comparison {
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 10px;
            margin: 10px 0;
        }
        .performance-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .good { background-color: #28a745; }
        .warning { background-color: #ffc107; }
        .danger { background-color: #dc3545; }
    </style>
</head>
<body>
    <div class="container-fluid mt-4">
        <!-- 헤더 -->
        <div class="row mb-4">
            <div class="col-12">
                <h1 class="text-center mb-3">
                    <i class="bi bi-database-gear"></i> Django ORM 고급 분석 시스템
                </h1>
                <div class="text-center mb-3">
                    <span class="orm-badge">
                        <i class="bi bi-shield-check"></i> Django ORM 보안 + 성능 최적화
                    </span>
                </div>
                <p class="text-center text-muted">
                    SQL 인젝션 자동 방지 • N+1 문제 해결 • 타입 안전성 보장
                </p>
            </div>
        </div>

        <!-- 성능 지표 대시보드 -->
        <div class="row mb-4">
            <div class="col-md-3">
                <div class="card border-primary h-100">
                    <div class="card-body text-center">
                        <i class="bi bi-people-fill text-primary fs-1"></i>
                        <h5 class="card-title text-primary mt-2">총 직원</h5>
                        <h3 class="text-primary">{{ total_count }}명</h3>
                        <small class="text-muted">
                            <span class="method-tag">count()</span>
                        </small>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card border-info h-100">
                    <div class="card-body text-center">
                        <i class="bi bi-building text-info fs-1"></i>
                        <h5 class="card-title text-info mt-2">활성 부서</h5>
                        <h3 class="text-info">{{ total_departments }}개</h3>
                        <small class="text-muted">
                            <span class="method-tag">annotate()</span>
                        </small>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card border-success h-100">
                    <div class="card-body text-center">
                        <i class="bi bi-person-check text-success fs-1"></i>
                        <h5 class="card-title text-success mt-2">고객 담당</h5>
                        <h3 class="text-success">{{ customers_staff_count }}명</h3>
                        <small class="text-muted">
                            <span class="method-tag">Exists()</span>
                        </small>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card border-warning h-100">
                    <div class="card-body text-center">
                        <i class="bi bi-star-fill text-warning fs-1"></i>
                        <h5 class="card-title text-warning mt-2">고성과자</h5>
                        <h3 class="text-warning">{{ high_performers_count }}명</h3>
                        <small class="text-muted">
                            <span class="method-tag">Q()</span> 객체
                        </small>
                    </div>
                </div>
            </div>
        </div>

        <!-- 검색 폼 -->
        <div class="card mb-4">
            <div class="card-header bg-primary text-white">
                <h5 class="mb-0">
                    <i class="bi bi-search"></i> 스마트 검색 (ORM 필터링)
                </h5>
            </div>
            <div class="card-body">
                <form method="GET" class="row g-3">
                    <div class="col-md-10">
                        <input type="text" 
                               class="form-control" 
                               name="dept" 
                               value="{{ dept }}" 
                               placeholder="부서명 입력 (예: 총무부, 영업부) - 대소문자 무시 부분 검색">
                    </div>
                    <div class="col-md-2">
                        <button type="submit" class="btn btn-primary w-100">
                            <i class="bi bi-search"></i> 검색
                        </button>
                    </div>
                </form>
                <div class="sql-comparison mt-3">
                    <strong>ORM 쿼리:</strong>
                    <code>filter(busernum__busername__icontains=dept)</code><br>
                    <strong>Raw SQL 동등:</strong>
                    <code>WHERE busername LIKE '%dept%'</code>
                    <span class="performance-indicator good"></span> SQL 인젝션 자동 방지
                </div>
            </div>
        </div>

        <!-- 성별 통계 -->
        <div class="card mb-4">
            <div class="card-header bg-info text-white">
                <h5 class="mb-0">
                    <i class="bi bi-gender-ambiguous"></i> 성별 통계 (Case/When 활용)
                </h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <h6><i class="bi bi-person-fill text-primary"></i> 남성 직원</h6>
                        <p>인원: <strong>{{ gender_stats.남성직원수 }}명</strong></p>
                        <p>평균연봉: <strong>{{ gender_stats.남성평균연봉|floatformat:0 }}만원</strong></p>
                    </div>
                    <div class="col-md-4">
                        <h6><i class="bi bi-person-fill text-danger"></i> 여성 직원</h6>
                        <p>인원: <strong>{{ gender_stats.여성직원수 }}명</strong></p>
                        <p>평균연봉: <strong>{{ gender_stats.여성평균연봉|floatformat:0 }}만원</strong></p>
                    </div>
                    <div class="col-md-4">
                        <h6><i class="bi bi-trophy text-warning"></i> 고연봉자</h6>
                        <p>5000만원 이상: <strong>{{ gender_stats.고연봉직원수 }}명</strong></p>
                    </div>
                </div>
                <div class="sql-comparison">
                    <strong>사용된 ORM 메서드:</strong>
                    <span class="method-tag">aggregate()</span>
                    <span class="method-tag">Case</span>
                    <span class="method-tag">When</span>
                    <span class="method-tag">Count</span>
                    <span class="method-tag">Avg</span>
                </div>
            </div>
        </div>

        <!-- 직원 목록 -->
        <div class="card mb-4">
            <div class="card-header bg-success text-white">
                <h5 class="mb-0">
                    <i class="bi bi-table"></i> 직원 목록 (JOIN 최적화)
                </h5>
            </div>
            <div class="card-body">
                {% if total_count > 0 %}
                    <div class="table-responsive">
                        {{ join_html|safe }}
                    </div>
                    <div class="sql-comparison">
                        <strong>ORM 최적화:</strong>
                        <code>select_related('busernum')</code> - N+1 문제 해결<br>
                        <span class="performance-indicator good"></span> 단일 쿼리로 JOIN 처리
                        <span class="performance-indicator good"></span> 메모리 효율적 로딩
                    </div>
                {% else %}
                    <div class="alert alert-warning text-center">
                        <i class="bi bi-exclamation-triangle"></i>
                        <strong>검색 결과 없음</strong><br>
                        다른 검색 조건을 시도해보세요.
                    </div>
                {% endif %}
            </div>
        </div>

        <!-- 부서별 상세 통계 -->
        <div class="card mb-4">
            <div class="card-header bg-warning text-dark">
                <h5 class="mb-0">
                    <i class="bi bi-building"></i> 부서별 상세 통계
                </h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    {{ dept_html|safe }}
                </div>
                <div class="sql-comparison">
                    <strong>복잡한 집계 쿼리:</strong>
                    <span class="method-tag">annotate()</span>
                    <span class="method-tag">Count</span>
                    <span class="method-tag">Avg</span>
                    <span class="method-tag">Sum</span>
                    <span class="method-tag">Max</span>
                    <span class="method-tag">Min</span><br>
                    <span class="performance-indicator good"></span> 단일 쿼리로 모든 집계 처리
                </div>
            </div>
        </div>

        <!-- 직급별 분석 -->
        <div class="card mb-4">
            <div class="card-header bg-danger text-white">
                <h5 class="mb-0">
                    <i class="bi bi-diagram-3"></i> 직급별 분석 (GROUP BY)
                </h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    {{ position_html|safe }}
                </div>
                <div class="sql-comparison">
                    <strong>그룹별 집계:</strong>
                    <code>values('jikwonjik').annotate(...)</code><br>
                    <span class="performance-indicator good"></span> 효율적인 GROUP BY 구현
                </div>
            </div>
        </div>

        <!-- 부서 성과 순위 -->
        <div class="card mb-4">
            <div class="card-header bg-dark text-white">
                <h5 class="mb-0">
                    <i class="bi bi-trophy"></i> 부서 성과 순위 (F 객체 활용)
                </h5>
            </div>
            <div class="card-body">
                <div class="row">
                    {% for dept in performance_analysis %}
                    <div class="col-md-4 mb-3">
                        <div class="card border-primary">
                            <div class="card-body text-center">
                                <h6 class="card-title">{{ dept.busername }}</h6>
                                <p class="mb-1">직원수: {{ dept.직원수 }}명</p>
                                <p class="mb-1">평균연봉: {{ dept.평균연봉|floatformat:0 }}만원</p>
                                <p class="mb-0">효율성: {{ dept.효율성점수|floatformat:1 }}</p>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                <div class="sql-comparison">
                    <strong>F 객체 연산:</strong>
                    <code>F('평균연봉') / F('평균근속년수')</code><br>
                    <span class="performance-indicator good"></span> 데이터베이스 레벨 계산
                </div>
            </div>
        </div>

        <!-- ORM vs Raw SQL 비교 -->
        <div class="card mb-4">
            <div class="card-header bg-secondary text-white">
                <h5 class="mb-0">
                    <i class="bi bi-code-square"></i> ORM vs Raw SQL 성능 비교
                </h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <h6><i class="bi bi-check-circle text-success"></i> ORM 장점</h6>
                        <ul class="list-group list-group-flush">
                            <li class="list-group-item">
                                <span class="performance-indicator good"></span>
                                SQL 인젝션 자동 방지
                            </li>
                            <li class="list-group-item">
                                <span class="performance-indicator good"></span>
                                타입 안전성 보장
                            </li>
                            <li class="list-group-item">
                                <span class="performance-indicator good"></span>
                                데이터베이스 독립성
                            </li>
                            <li class="list-group-item">
                                <span class="performance-indicator good"></span>
                                객체지향적 접근
                            </li>
                            <li class="list-group-item">
                                <span class="performance-indicator good"></span>
                                IntelliSense 지원
                            </li>
                        </ul>
                    </div>
                    <div class="col-md-6">
                        <h6><i class="bi bi-exclamation-triangle text-warning"></i> ORM 한계</h6>
                        <ul class="list-group list-group-flush">
                            <li class="list-group-item">
                                <span class="performance-indicator warning"></span>
                                복잡한 쿼리 표현 제한
                            </li>
                            <li class="list-group-item">
                                <span class="performance-indicator warning"></span>
                                성능 튜닝 어려움
                            </li>
                            <li class="list-group-item">
                                <span class="performance-indicator warning"></span>
                                러닝 커브 존재
                            </li>
                            <li class="list-group-item">
                                <span class="performance-indicator danger"></span>
                                대용량 데이터 처리 한계
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- 사용된 ORM 기법 요약 -->
        <div class="card mb-4">
            <div class="card-header bg-info text-white">
                <h5 class="mb-0">
                    <i class="bi bi-list-check"></i> 이 페이지에서 사용된 ORM 기법들
                </h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-3">
                        <h6>기본 조회</h6>
                        <span class="method-tag">objects.all()</span>
                        <span class="method-tag">filter()</span>
                        <span class="method-tag">exclude()</span>
                        <span class="method-tag">order_by()</span>
                        <span class="method-tag">count()</span>
                    </div>
                    <div class="col-md-3">
                        <h6>관계 & 성능</h6>
                        <span class="method-tag">select_related()</span>
                        <span class="method-tag">prefetch_related()</span>
                        <span class="method-tag">Exists()</span>
                        <span class="method-tag">OuterRef()</span>
                    </div>
                    <div class="col-md-3">
                        <h6>집계 & 그룹</h6>
                        <span class="method-tag">aggregate()</span>
                        <span class="method-tag">annotate()</span>
                        <span class="method-tag">values()</span>
                        <span class="method-tag">Count/Avg/Sum</span>
                    </div>
                    <div class="col-md-3">
                        <h6>고급 기법</h6>
                        <span class="method-tag">Q()</span>
                        <span class="method-tag">F()</span>
                        <span class="method-tag">Case/When</span>
                        <span class="method-tag">__icontains</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 네비게이션 -->
        <div class="text-center mb-4">
            <div class="btn-group" role="group">
                <a href="/dbshow/" class="btn btn-outline-primary">
                    <i class="bi bi-code-slash"></i> Raw SQL 버전
                </a>
                <a href="/orm-examples/" class="btn btn-info">
                    <i class="bi bi-book"></i> ORM 기본 예제
                </a>
                <a href="/advanced-analysis/" class="btn btn-warning">
                    <i class="bi bi-graph-up"></i> 고급 분석
                </a>
                <a href="/" class="btn btn-primary">
                    <i class="bi bi-house"></i> 메인으로
                </a>
            </div>
        </div>

        <!-- 강사님 조언 -->
        <div class="alert alert-info border-left-primary">
            <div class="row align-items-center">
                <div class="col-auto">
                    <i class="bi bi-lightbulb text-primary fs-1"></i>
                </div>
                <div class="col">
                    <h6 class="alert-heading">💡 강사님의 실무 조언</h6>
                    <p class="mb-2">
                        <em>"장고 ORM을 써도 되고 그냥 Raw SQL 문장을 써도 괜찮아요. 편한 걸로 하시면 됩니다."</em>
                    </p>
                    <hr>
                    <p class="mb-0">
                        <strong>실무 권장:</strong> 기본적으로 ORM 사용, 복잡한 분석이나 성능이 중요한 경우 Raw SQL 혼용
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
```

---

## 모델 설정 및 관계 정의

### 🔧 모델 최적화 설정

```python
# myapp/models.py - ORM 최적화 버전

from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator

class Buser(models.Model):
    """부서 모델"""
    buserno = models.IntegerField(
        primary_key=True,
        verbose_name="부서번호"
    )
    busername = models.CharField(
        max_length=10,
        verbose_name="부서명",
        help_text="부서의 정식 명칭"
    )
    buserloc = models.CharField(
        max_length=10, 
        blank=True, 
        null=True,
        verbose_name="부서위치"
    )
    busertel = models.CharField(
        max_length=15, 
        blank=True, 
        null=True,
        verbose_name="부서전화번호"
    )

    class Meta:
        managed = True  # Django가 테이블 관리
        db_table = 'buser'
        verbose_name = "부서"
        verbose_name_plural = "부서들"
        ordering = ['buserno']  # 기본 정렬
        
    def __str__(self):
        return f"{self.busername} ({self.buserno})"
    
    @property
    def employee_count(self):
        """부서 직원 수 (Python 프로퍼티)"""
        return self.jikwon_set.count()
    
    def get_average_salary(self):
        """부서 평균 연봉"""
        from django.db.models import Avg
        return self.jikwon_set.aggregate(
            avg_salary=Avg('jikwonpay')
        )['avg_salary'] or 0

class Jikwon(models.Model):
    """직원 모델"""
    
    # 성별 선택지
    GENDER_CHOICES = [
        ('남', '남성'),
        ('여', '여성'),
    ]
    
    # 직급 선택지  
    POSITION_CHOICES = [
        ('사원', '사원'),
        ('대리', '대리'),
        ('과장', '과장'),
        ('차장', '차장'),
        ('부장', '부장'),
        ('대표', '대표'),
    ]
    
    jikwonno = models.IntegerField(
        primary_key=True,
        verbose_name="직원번호"
    )
    jikwonname = models.CharField(
        max_length=10,
        verbose_name="직원명"
    )
    # ForeignKey로 관계 설정
    busernum = models.ForeignKey(
        Buser,
        on_delete=models.PROTECT,  # 부서 삭제 방지
        db_column='busernum',
        related_name='jikwon_set',  # 역참조 이름
        verbose_name="소속부서"
    )
    jikwonjik = models.CharField(
        max_length=10,
        choices=POSITION_CHOICES,
        blank=True,
        null=True,
        verbose_name="직급"
    )
    jikwonpay = models.IntegerField(
        blank=True,
        null=True,
        validators=[MinValueValidator(1000), MaxValueValidator(20000)],
        verbose_name="연봉(만원)"
    )
    jikwonibsail = models.DateField(
        blank=True,
        null=True,
        verbose_name="입사일"
    )
    jikwongen = models.CharField(
        max_length=4,
        choices=GENDER_CHOICES,
        blank=True,
        null=True,
        verbose_name="성별"
    )
    jikwonrating = models.CharField(
        max_length=3,
        blank=True,
        null=True,
        verbose_name="평가등급"
    )

    class Meta:
        managed = True
        db_table = 'jikwon'
        verbose_name = "직원"
        verbose_name_plural = "직원들"
        ordering = ['jikwonno']
        # 복합 인덱스 추가
        indexes = [
            models.Index(fields=['busernum', 'jikwonjik']),
            models.Index(fields=['jikwonpay']),
            models.Index(fields=['jikwonibsail']),
        ]
        
    def __str__(self):
        return f"{self.jikwonname} ({self.jikwonjik or '미지정'})"
    
    @property
    def years_of_service(self):
        """근속년수 계산"""
        if not self.jikwonibsail:
            return 0
        from datetime import date
        today = date.today()
        return today.year - self.jikwonibsail.year
    
    @property
    def customer_count(self):
        """담당 고객 수"""
        return self.gogek_customers.count()
    
    def is_high_performer(self):
        """고성과자 여부 (연봉 4000만원 이상 또는 부장급 이상)"""
        return (self.jikwonpay and self.jikwonpay >= 4000) or \
               self.jikwonjik in ['부장', '대표']

class Gogek(models.Model):
    """고객 모델"""
    gogekno = models.IntegerField(
        primary_key=True,
        verbose_name="고객번호"
    )
    gogekname = models.CharField(
        max_length=10,
        verbose_name="고객명"
    )
    gogektel = models.CharField(
        max_length=20,
        blank=True,
        null=True,
        verbose_name="고객전화번호"
    )
    gogekjumin = models.CharField(
        max_length=14,
        blank=True,
        null=True,
        verbose_name="주민번호"
    )
    # 담당자 관계 설정
    gogekdamsano = models.ForeignKey(
        Jikwon,
        on_delete=models.SET_NULL,  # 담당자 삭제 시 NULL 처리
        db_column='gogekdamsano',
        blank=True,
        null=True,
        related_name='gogek_customers',
        verbose_name="담당직원"
    )

    class Meta:
        managed = True
        db_table = 'gogek'
        verbose_name = "고객"
        verbose_name_plural = "고객들"
        ordering = ['gogekno']
        
    def __str__(self):
        담당자 = self.gogekdamsano.jikwonname if self.gogekdamsano else '미배정'
        return f"{self.gogekname} (담당: {담당자})"

class Board(models.Model):
    """게시판 모델"""
    num = models.IntegerField(
        primary_key=True,
        verbose_name="게시글번호"
    )
    author = models.CharField(
        max_length=10,
        blank=True,
        null=True,
        verbose_name="작성자"
    )
    title = models.CharField(
        max_length=50,
        blank=True,
        null=True,
        verbose_name="제목"
    )
    content = models.TextField(  # CharField에서 TextField로 변경
        blank=True,
        null=True,
        verbose_name="내용"
    )
    bwrite = models.DateTimeField(  # DateField에서 DateTimeField로 변경
        auto_now_add=True,
        verbose_name="작성일시"
    )
    readcnt = models.PositiveIntegerField(  # IntegerField에서 PositiveIntegerField로
        default=0,
        verbose_name="조회수"
    )

    class Meta:
        managed = True
        db_table = 'board'
        verbose_name = "게시글"
        verbose_name_plural = "게시글들"
        ordering = ['-bwrite']  # 최신순 정렬
        
    def __str__(self):
        return f"{self.title} - {self.author}"

class Sangdata(models.Model):
    """상품 데이터 모델"""
    code = models.IntegerField(
        primary_key=True,
        verbose_name="상품코드"
    )
    sang = models.CharField(
        max_length=20,
        blank=True,
        null=True,
        verbose_name="상품명"
    )
    su = models.PositiveIntegerField(
        blank=True,
        null=True,
        verbose_name="수량"
    )
    dan = models.PositiveIntegerField(
        blank=True,
        null=True,
        verbose_name="단가"
    )

    class Meta:
        managed = True
        db_table = 'sangdata'
        verbose_name = "상품"
        verbose_name_plural = "상품들"
        ordering = ['code']
        
    def __str__(self):
        return f"{self.sang} ({self.code})"
    
    @property
    def total_price(self):
        """총 금액 계산"""
        if self.su and self.dan:
            return self.su * self.dan
        return 0
```

---

## 성능 최적화 기법

### ⚡ N+1 문제 해결

#### 1. SELECT_RELATED (1:1, N:1 관계)
```python
# ❌ N+1 문제 발생
jikwons = Jikwon.objects.all()
for jikwon in jikwons:
    print(jikwon.busernum.busername)  # 각각에 대해 별도 쿼리 실행

# ✅ SELECT_RELATED로 해결
jikwons = Jikwon.objects.select_related('busernum').all()
for jikwon in jikwons:
    print(jikwon.busernum.busername)  # 단일 JOIN 쿼리로 해결
```

#### 2. PREFETCH_RELATED (1:N, M:N 관계)
```python
# ❌ N+1 문제 발생
departments = Buser.objects.all()
for dept in departments:
    print(dept.jikwon_set.count())  # 각 부서마다 별도 쿼리

# ✅ PREFETCH_RELATED로 해결
departments = Buser.objects.prefetch_related('jikwon_set').all()
for dept in departments:
    print(dept.jikwon_set.count())  # 미리 로드된 데이터 사용
```

### 🎯 쿼리 최적화 패턴

#### 1. ONLY/DEFER - 필요한 필드만 조회
```python
# 필요한 필드만 조회
jikwons = Jikwon.objects.only('jikwonname', 'jikwonpay')

# 특정 필드 제외
jikwons = Jikwon.objects.defer('content', 'large_field')
```

#### 2. VALUES/VALUES_LIST - 딕셔너리/튜플로 조회
```python
# 딕셔너리 형태로 조회
results = Jikwon.objects.values('jikwonname', 'jikwonpay')

# 튜플 형태로 조회
results = Jikwon.objects.values_list('jikwonname', 'jikwonpay')

# 플랫 리스트로 조회
names = Jikwon.objects.values_list('jikwonname', flat=True)
```

#### 3. BULK 연산 - 대량 데이터 처리
```python
# 대량 생성
jikwons = [
    Jikwon(jikwonname=f'직원{i}', jikwonpay=3000)
    for i in range(1000)
]
Jikwon.objects.bulk_create(jikwons, batch_size=100)

# 대량 업데이트
Jikwon.objects.filter(jikwonjik='사원').update(jikwonpay=3500)

# 대량 삭제
Jikwon.objects.filter(jikwonpay__lt=2000).delete()
```

### 📊 쿼리 성능 모니터링

```python
from django.db import connection
from django.conf import settings

def monitor_queries(func):
    """쿼리 모니터링 데코레이터"""
    def wrapper(*args, **kwargs):
        queries_before = len(connection.queries)
        result = func(*args, **kwargs)
        queries_after = len(connection.queries)
        
        if settings.DEBUG:
            print(f"함수 {func.__name__}: {queries_after - queries_before}개 쿼리 실행")
            for query in connection.queries[queries_before:]:
                print(f"  {query['time']}s: {query['sql']}")
        
        return result
    return wrapper

@monitor_queries
def expensive_operation():
    """비용이 많이 드는 작업"""
    return list(Jikwon.objects.select_related('busernum').all())
```

---

## 실무 활용 패턴

### 🚀 고급 ORM 패턴

#### 1. 동적 필터링
```python
def dynamic_filter_view(request):
    """동적 필터링 구현"""
    queryset = Jikwon.objects.select_related('busernum')
    
    # 조건부 필터 적용
    if request.GET.get('department'):
        queryset = queryset.filter(
            busernum__busername__icontains=request.GET['department']
        )
    
    if request.GET.get('position'):
        queryset = queryset.filter(jikwonjik=request.GET['position'])
    
    if request.GET.get('min_salary'):
        queryset = queryset.filter(
            jikwonpay__gte=int(request.GET['min_salary'])
        )
    
    # 정렬 조건
    sort_by = request.GET.get('sort', 'jikwonno')
    if sort_by in ['jikwonno', 'jikwonname', 'jikwonpay']:
        queryset = queryset.order_by(sort_by)
    
    return queryset
```

#### 2. 복잡한 집계 쿼리
```python
def complex_aggregation():
    """복잡한 집계 분석"""
    from django.db.models import Case, When, Count, Avg, Q, F
    
    # 부서별, 직급별, 성별 교차 분석
    analysis = (
        Jikwon.objects
        .values('busernum__busername', 'jikwonjik', 'jikwongen')
        .annotate(
            인원수=Count('jikwonno'),
            평균연봉=Avg('jikwonpay'),
            # 조건부 집계
            신입사원수=Count(
                Case(
                    When(
                        Q(jikwonibsail__year__gte=2020) & Q(jikwonjik='사원'),
                        then=1
                    ),
                    output_field=IntegerField()
                )
            ),
            # 비율 계산
            고연봉비율=Count(
                Case(When(jikwonpay__gte=5000, then=1), output_field=IntegerField())
            ) * 100.0 / Count('jikwonno')
        )
        .filter(인원수__gt=0)
        .order_by('busernum__busername', 'jikwonjik')
    )
    
    return analysis
```

#### 3. 서브쿼리와 윈도우 함수
```python
def advanced_subquery():
    """고급 서브쿼리 활용"""
    from django.db.models import Subquery, OuterRef, Window, F, Rank
    
    # 각 부서별 최고 연봉자 조회
    highest_paid_per_dept = (
        Jikwon.objects
        .filter(busernum=OuterRef('busernum'))
        .order_by('-jikwonpay')
        .values('jikwonpay')[:1]
    )
    
    result = Jikwon.objects.annotate(
        dept_max_salary=Subquery(highest_paid_per_dept),
        is_highest_paid=Case(
            When(jikwonpay=F('dept_max_salary'), then=True),
            default=False,
            output_field=models.BooleanField()
        )
    ).filter(is_highest_paid=True)
    
    return result
```

### 🔧 실무 팁과 주의사항

#### 1. 트랜잭션 관리
```python
from django.db import transaction

@transaction.atomic
def safe_bulk_operation():
    """안전한 대량 작업"""
    try:
        # 여러 작업을 하나의 트랜잭션으로
        Jikwon.objects.filter(jikwonjik='사원').update(jikwonpay=F('jikwonpay') + 500)
        
        # 관련 데이터 업데이트
        for dept in Buser.objects.all():
            dept.last_updated = timezone.now()
            dept.save()
            
    except Exception as e:
        # 롤백 자동 실행
        raise e

# 세이브포인트 사용
@transaction.atomic
def complex_operation_with_savepoint():
    """복잡한 작업에서 세이브포인트 활용"""
    
    # 첫 번째 작업
    Jikwon.objects.create(jikwonname='신규직원', jikwonpay=3000)
    
    # 세이브포인트 생성
    savepoint = transaction.savepoint()
    
    try:
        # 위험한 작업
        risky_operation()
        transaction.savepoint_commit(savepoint)
    except Exception:
        # 세이브포인트로 롤백 (첫 번째 작업은 유지)
        transaction.savepoint_rollback(savepoint)
```

#### 2. 캐싱 전략
```python
from django.core.cache import cache
from django.views.decorators.cache import cache_page

@cache_page(60 * 15)  # 15분 캐싱
def cached_department_stats(request):
    """부서 통계 캐싱"""
    cache_key = 'department_stats'
    stats = cache.get(cache_key)
    
    if stats is None:
        stats = (
            Buser.objects
            .annotate(
                직원수=Count('jikwon_set'),
                평균연봉=Avg('jikwon_set__jikwonpay')
            )
            .filter(직원수__gt=0)
        )
        cache.set(cache_key, stats, 60 * 60)  # 1시간 캐싱
    
    return render(request, 'department_stats.html', {'stats': stats})

# 쿼리셋 캐싱
def get_active_employees():
    """활성 직원 목록 캐싱"""
    cache_key = 'active_employees'
    employees = cache.get(cache_key)
    
    if employees is None:
        employees = list(
            Jikwon.objects
            .select_related('busernum')
            .filter(jikwonpay__isnull=False)
            .order_by('jikwonno')
        )
        cache.set(cache_key, employees, 60 * 30)  # 30분
    
    return employees
```

#### 3. 데이터베이스 연결 풀링
```python
# settings.py에서 연결 설정 최적화
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mydb',
        'USER': 'root',
        'PASSWORD': '970506',
        'HOST': '127.0.0.1',
        'PORT': '3306',
        'OPTIONS': {
            'charset': 'utf8mb4',
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
            # 연결 풀 설정
            'CONN_MAX_AGE': 600,  # 연결 유지 시간 (초)
            'CONN_HEALTH_CHECKS': True,  # 연결 상태 체크
            # 성능 최적화
            'read_timeout': 20,
            'write_timeout': 20,
        },
    }
}

# 읽기 전용 DB 설정 (선택사항)
DATABASE_ROUTERS = ['myapp.routers.DatabaseRouter']

# myapp/routers.py
class DatabaseRouter:
    """읽기/쓰기 DB 라우터"""
    
    def db_for_read(self, model, **hints):
        """읽기 작업은 읽기 전용 DB로"""
        return 'replica'
    
    def db_for_write(self, model, **hints):
        """쓰기 작업은 마스터 DB로"""
        return 'default'
```

---

## 트러블슈팅

### 🚨 자주 발생하는 문제와 해결책

#### 1. 마이그레이션 관련 문제

```bash
# 문제: 기존 테이블과 충돌
# 해결: --fake-initial 옵션 사용
python manage.py migrate --fake-initial

# 문제: 마이그레이션 파일 충돌
# 해결: 마이그레이션 리셋
python manage.py migrate myapp zero
python manage.py makemigrations myapp
python manage.py migrate myapp

# 문제: ForeignKey 관계 오류
# 해결: 데이터 정합성 확인 후 마이그레이션
python manage.py shell
>>> from myapp.models import *
>>> # 데이터 정합성 체크
>>> invalid_relations = Jikwon.objects.filter(busernum__isnull=True)
>>> print(invalid_relations.count())
```

#### 2. 성능 문제 해결

```python
# 문제: N+1 쿼리 문제
# 해결 전 (느림)
def slow_view():
    jikwons = Jikwon.objects.all()
    for j in jikwons:
        print(j.busernum.busername)  # 매번 DB 접근

# 해결 후 (빠름)
def fast_view():
    jikwons = Jikwon.objects.select_related('busernum').all()
    for j in jikwons:
        print(j.busernum.busername)  # 미리 로드된 데이터 사용

# 문제: 메모리 부족 (대량 데이터)
# 해결: iterator() 사용
def memory_efficient_view():
    # 큰 QuerySet을 청크 단위로 처리
    for jikwon in Jikwon.objects.iterator(chunk_size=1000):
        process_jikwon(jikwon)
```

#### 3. 쿼리 최적화 문제

```python
# 문제: 복잡한 집계 쿼리가 느림
# 해결: Raw SQL과 ORM 혼용
def optimized_complex_query():
    # ORM으로 기본 필터링
    base_query = Jikwon.objects.filter(jikwonpay__isnull=False)
    
    # 복잡한 부분은 Raw SQL
    raw_sql = """
    SELECT 
        b.busername,
        COUNT(*) as emp_count,
        AVG(j.jikwonpay) as avg_salary,
        RANK() OVER (ORDER BY AVG(j.jikwonpay) DESC) as salary_rank
    FROM jikwon j
    INNER JOIN buser b ON j.busernum = b.buserno
    WHERE j.jikwonpay IS NOT NULL
    GROUP BY b.buserno, b.busername
    HAVING COUNT(*) >= 2
    ORDER BY salary_rank
    """
    
    with connection.cursor() as cursor:
        cursor.execute(raw_sql)
        results = cursor.fetchall()
    
    return results

# 문제: 동일한 쿼리 반복 실행
# 해결: 메모이제이션 적용
from functools import lru_cache

@lru_cache(maxsize=128)
def cached_department_list():
    """부서 목록 캐싱"""
    return list(Buser.objects.all().values('buserno', 'busername'))
```

#### 4. 데이터 무결성 문제

```python
# 문제: 외래키 제약 조건 위반
# 해결: 데이터 검증 후 처리
def safe_employee_creation(dept_id, employee_data):
    """안전한 직원 생성"""
    try:
        # 부서 존재 확인
        department = Buser.objects.get(buserno=dept_id)
        
        # 직원 생성
        employee = Jikwon.objects.create(
            busernum=department,
            **employee_data
        )
        return employee
        
    except Buser.DoesNotExist:
        raise ValueError(f"부서 번호 {dept_id}가 존재하지 않습니다.")
    except Exception as e:
        raise ValueError(f"직원 생성 중 오류: {str(e)}")

# 문제: 중복 데이터 처리
# 해결: get_or_create 사용
def ensure_unique_employee(employee_data):
    """중복 방지 직원 생성"""
    employee, created = Jikwon.objects.get_or_create(
        jikwonno=employee_data['jikwonno'],
        defaults=employee_data
    )
    
    if not created:
        # 기존 데이터 업데이트
        for key, value in employee_data.items():
            setattr(employee, key, value)
        employee.save()
    
    return employee, created
```

---

## 실무 권장 사항

### 🎯 ORM vs Raw SQL 선택 가이드

#### 언제 ORM을 사용할까?

**✅ ORM 권장 상황:**
1. **기본 CRUD 작업**
   ```python
   # 생성, 조회, 수정, 삭제가 간단한 경우
   user = User.objects.create(name='홍길동')
   users = User.objects.filter(active=True)
   user.email = 'new@email.com'
   user.save()
   ```

2. **보안이 중요한 경우**
   ```python
   # SQL 인젝션 자동 방지
   search_term = request.GET.get('q')  # 사용자 입력
   results = Post.objects.filter(title__icontains=search_term)  # 안전
   ```

3. **팀 협업에서 일관성이 중요한 경우**
   ```python
   # 모든 개발자가 동일한 방식으로 작성
   active_employees = Employee.objects.filter(is_active=True)
   ```

4. **프로토타이핑 및 빠른 개발**
   ```python
   # 빠른 개발이 필요한 초기 단계
   def quick_analysis():
       return Employee.objects.aggregate(
           avg_salary=Avg('salary'),
           count=Count('id')
       )
   ```

#### 언제 Raw SQL을 사용할까?

**⚡ Raw SQL 권장 상황:**
1. **복잡한 집계 및 분석 쿼리**
   ```python
   # 복잡한 비즈니스 로직이 포함된 경우
   sql = """
   SELECT 
       d.name,
       COUNT(e.id) as emp_count,
       AVG(e.salary) as avg_salary,
       RANK() OVER (PARTITION BY d.region ORDER BY AVG(e.salary) DESC) as rank
   FROM departments d
   LEFT JOIN employees e ON d.id = e.dept_id
   GROUP BY d.id, d.name, d.region
   HAVING COUNT(e.id) > 5
   """
   ```

2. **성능이 중요한 대용량 처리**
   ```python
   # 수백만 건의 데이터 처리
   with connection.cursor() as cursor:
       cursor.execute("""
           UPDATE employees 
           SET salary = salary * 1.1 
           WHERE performance_rating = 'A'
           AND hire_date < %s
       """, [cutoff_date])
   ```

3. **데이터베이스 특화 기능 사용**
   ```python
   # 특정 DB의 고급 기능 활용
   cursor.execute("""
       SELECT * FROM employees 
       WHERE MATCH(skills) AGAINST (%s IN BOOLEAN MODE)
   """, [search_term])
   ```

### 💡 혼용 패턴 (Best Practice)

```python
def hybrid_analysis_view(request):
    """ORM과 Raw SQL의 효과적인 혼용"""
    
    # 1. ORM으로 기본 필터링 (안전성)
    base_employees = Employee.objects.filter(
        is_active=True,
        department__is_active=True
    ).select_related('department')
    
    # 2. 사용자 조건 동적 추가 (ORM의 유연성)
    if request.GET.get('dept'):
        base_employees = base_employees.filter(
            department__name__icontains=request.GET['dept']
        )
    
    # 3. 복잡한 분석은 Raw SQL (성능)
    analysis_sql = """
    SELECT 
        dept_id,
        dept_name,
        employee_count,
        avg_salary,
        salary_std,
        performance_score
    FROM complex_analysis_view
    WHERE dept_id IN %s
    """
    
    dept_ids = list(base_employees.values_list('department_id', flat=True))
    
    with connection.cursor() as cursor:
        cursor.execute(analysis_sql, [tuple(dept_ids)])
        analysis_results = cursor.fetchall()
    
    # 4. 결과 조합 및 반환
    return render(request, 'analysis.html', {
        'employees': base_employees,
        'analysis': analysis_results
    })
```

### 🔥 성능 최적화 체크리스트

#### ORM 성능 최적화
- [ ] `select_related()` 사용으로 N+1 문제 해결
- [ ] `prefetch_related()` 로 역방향 관계 최적화
- [ ] `only()`, `defer()` 로 필요한 필드만 조회
- [ ] `exists()` 로 불필요한 데이터 로딩 방지
- [ ] `iterator()` 로 메모리 효율적 대용량 처리
- [ ] `bulk_create()`, `bulk_update()` 로 대량 처리 최적화

#### 데이터베이스 설계 최적화
- [ ] 적절한 인덱스 생성
- [ ] 외래키 제약 조건 설정
- [ ] 파티셔닝 고려 (대용량 데이터)
- [ ] 정규화/비정규화 균형

#### 캐싱 전략
- [ ] 쿼리 결과 캐싱
- [ ] 템플릿 프래그먼트 캐싱
- [ ] Redis/Memcached 활용

---

## 마무리: 강사님의 실무 철학

### 🎓 핵심 메시지
> **"패턴을 읽어야 돼요. 명령을 외우라는 얘기가 아니야 패턴을 읽으세요."**

> **"장고 ORM을 써도 되고 그냥 Raw SQL 문장을 써도 괜찮아요. 편한 걸로 하시면 됩니다."**

### 🚀 실무 개발자로 성장하기

1. **도구의 장단점 이해**: ORM과 Raw SQL 각각의 특성을 파악하고 상황에 맞게 선택
2. **성능 감각 기르기**: 쿼리 실행 계획을 보고 병목점을 찾는 능력
3. **보안 의식**: SQL 인젝션, XSS 등 웹 보안 위협에 대한 이해
4. **협업 고려**: 팀원들이 이해하기 쉬운 코드 작성
5. **지속적인 학습**: 새로운 ORM 기능과 데이터베이스 기술 습득

### 🏆 최종 권장 패턴

```python
# 실무에서 권장하는 Django 뷰 패턴
from django.shortcuts import render
from django.db.models import Count, Avg, Q, F
from django.db import connection
from django.core.cache import cache
from django.utils.html import escape

def production_ready_view(request):
    """실무에 바로 적용 가능한 뷰 패턴"""
    
    # 1. 안전한 사용자 입력 처리
    search_term = escape(request.GET.get('search', '').strip())
    dept_filter = escape(request.GET.get('dept', '').strip())
    
    # 2. 기본은 ORM 사용 (안전성, 가독성)
    employees = Employee.objects.select_related('department')
    
    # 3. 동적 필터링 (유연성)
    if search_term:
        employees = employees.filter(
            Q(name__icontains=search_term) |
            Q(email__icontains=search_term)
        )
    
    if dept_filter:
        employees = employees.filter(
            department__name__icontains=dept_filter
        )
    
    # 4. 캐싱 활용 (성능)
    cache_key = f"dept_stats_{dept_filter}"
    dept_stats = cache.get(cache_key)
    
    if dept_stats is None:
        # 5. 복잡한 분석은 상황에 따라 Raw SQL 고려
        if len(employees) > 10000:  # 대용량 데이터
            # Raw SQL 사용
            with connection.cursor() as cursor:
                cursor.execute(complex_analysis_sql, params)
                dept_stats = cursor.fetchall()
        else:
            # ORM 사용
            dept_stats = employees.values('department__name').annotate(
                count=Count('id'),
                avg_salary=Avg('salary')
            )
        
        cache.set(cache_key, dept_stats, 300)  # 5분 캐싱
    
    # 6. 명확한 컨텍스트 반환
    context = {
        'employees': employees[:100],  # 페이징 고려
        'dept_stats': dept_stats,
        'search_term': search_term,
        'total_count': employees.count(),
    }
    
    return render(request, 'employees.html', context)
```

Django ORM은 강력한 도구이지만, **상황에 맞는 선택**이 가장 중요합니다. 기본적으로는 ORM의 안전성과 편의성을 활용하되, 성능이나 복잡성 때문에 필요하다면 Raw SQL을 주저하지 말고 사용하는 것이 실무의 지혜입니다.

**"편한 걸로 하되, 그 선택의 이유를 명확히 아는 개발자"**가 되시길 바랍니다! 🎯