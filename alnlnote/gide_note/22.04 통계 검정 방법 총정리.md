# 통계 검정 방법 선택 가이드 ⭐


# 22.04 통계 검정 방법 총정리 - 가이드 ⭐

## 🎯 이 챕터가 필요한 이유

22.03 가설 검정에서는 **기본 개념과 절차**를 다뤘지만, 실제로 **"어떤 검정을 언제 써야 하는가?"**는 여전히 막막합니다. 

이 챕터에서는 **실무에서 바로 적용 가능한 검정 선택 가이드**를 제공합니다.

---

## 📊 22.04.01 데이터 타입과 검정 선택 완전 가이드

## 📊 통계 검정 선택 매트릭스

| 독립변수 (X) | 종속변수 (Y) | 그룹 수 | 표본 관계 | 검정 방법 | Python 함수 |
|-------------|-------------|--------|----------|----------|------------|
| **없음** | 범주형 | - | - | 카이제곱 적합도 검정 | `scipy.stats.chisquare()` |
| **없음** | 연속형 | - | - | 일표본 t검정 | `scipy.stats.ttest_1samp()` |
| 범주형 | 범주형 | 2+ | 독립 | 카이제곱 독립성 검정 | `scipy.stats.chi2_contingency()` |
| 범주형 | 연속형 | 2 | 독립 | 독립표본 t검정 | `scipy.stats.ttest_ind()` |
| 범주형 | 연속형 | 2 | 대응 | 대응표본 t검정 | `scipy.stats.ttest_rel()` |
| 범주형 | 연속형 | 3+ | 독립 | 일원분산분석 (ANOVA) | `scipy.stats.f_oneway()` |
| 범주형 | 연속형 | 3+ | 대응 | 반복측정 ANOVA | `statsmodels.stats.anova` |
| 연속형 | 연속형 | - | - | 상관분석 | `scipy.stats.pearsonr()` |
| 연속형 | 연속형 | - | - | 회귀분석 | `sklearn.linear_model` |

### 🚨 가정 위반 시 대안

| 위반된 가정 | 원래 검정 | 대안 검정 | Python 함수 |
|-----------|---------|---------|------------|
| 정규성 | t검정 | Mann-Whitney U | `scipy.stats.mannwhitneyu()` |
| 정규성 | ANOVA | Kruskal-Wallis | `scipy.stats.kruskal()` |
| 등분산성 | t검정 | Welch's t-test | `ttest_ind(equal_var=False)` |
| 독립성 | t검정/ANOVA | 혼합효과모델 | `statsmodels.MixedLM()` |

---

## 🎯 요약: 실무에서 바로 써먹는 5단계 가이드

> **"통계는 어렵지 않아요. 순서만 제대로 따라가면 됩니다!"**

### 🚀 **1단계: 연구질문 명확화 - "내가 뭘 알고 싶은 거지?"**

**여기서 90%가 결정됩니다!** 질문이 애매하면 아무리 복잡한 통계를 써도 의미 없어요.

**🗣️ 실제 상황에서 이렇게 생각해보세요:**

> **"우리 회사 신제품이 기존 제품보다 정말 좋은가?"** 
→ 이건 아직 애매해요. 뭐가 "좋다"는 건지 구체적이지 않죠.

> **"신제품 고객 만족도가 기존 제품보다 높은가?"**
→ 이제 좀 나아졌어요. 하지만 여전히 "높다"가 애매하네요.

> **"신제품 사용자의 평균 만족도 점수(1-10점)가 기존 제품 사용자보다 통계적으로 유의하게 높은가?"**
→ 완벽! 이제 측정 가능하고 검정 가능한 질문이 되었습니다.

**🎯 이 단계에서 꼭 해야 할 것들:**
- **독립변수 명확히 하기**: "제품 종류(신제품 vs 기존제품)" - 이게 그룹을 나누는 기준
- **종속변수 명확히 하기**: "만족도 점수" - 이게 우리가 측정하려는 결과
- **구체적인 가설 설정**: "신제품 평균 만족도 > 기존제품 평균 만족도"

**💡 팁**: 동료에게 설명했을 때 "아, 그래서 뭘 확인하려는 거야?"라는 말이 안 나와야 성공!

---

### 📊 **2단계: 데이터 타입 확인 - "내 데이터가 어떻게 생겼지?"**

**이게 제일 헷갈리는 부분이에요!** 숫자로 되어 있다고 다 연속형이 아니거든요.

**🗣️ 실무에서 자주 겪는 착각들:**

> **"성별을 1(남), 2(여)로 코딩했으니까 연속형이야!"** 
→ ❌ 아니에요! 1과 2 사이에 1.5가 의미가 있나요? 없죠! 이건 범주형입니다.

> **"만족도를 1(매우불만)~5(매우만족)로 했으니까 연속형이야!"**
→ 🤔 이건 좀 애매해요. 순서는 있지만 1과 2 사이의 간격이 정확히 동일한지 보장할 수 없어요. 보통은 연속형으로 근사해서 쓰긴 하지만...

> **"나이는 숫자니까 당연히 연속형이지!"**
→ ✅ 맞아요! 25.5세, 30.2세처럼 의미 있는 값들이 가능하죠.

**🎯 간단한 판별법:**
1. **"이 변수에 평균을 구하는 게 의미가 있나?"**
   - 만족도 평균: 3.2점 → 의미 있음 (연속형으로 취급 가능)
   - 성별 평균: 1.6 → 의미 없음 (범주형)

2. **"중간값이 실제로 존재할 수 있나?"**
   - 키 175.5cm → 가능 (연속형)
   - 자녀수 2.3명 → 불가능하지만 평균으론 가능 (연속형으로 취급)
   - 혈액형 "A와 B 사이" → 불가능 (범주형)

**💡 그룹 개수도 중요해요:**
- 2그룹 (남 vs 여) → t검정
- 3그룹 이상 (A학과 vs B학과 vs C학과) → ANOVA

**🔄 대응표본 vs 독립표본:**
- **대응표본**: 같은 사람의 전후 비교 (약 복용 전후 혈압)
- **독립표본**: 다른 사람들 간 비교 (남자 키 vs 여자 키)

---

### 🎯 **3단계: 검정 방법 선택 - "이제 뭘 써야 하지?"**

**앞에서 매트릭스 보셨죠? 이제 기계적으로 따라가면 됩니다!**

**🗣️ 실제로 이렇게 생각해보세요:**

> **"아, 독립변수가 범주형(제품종류)이고 종속변수가 연속형(만족도)이네? 그리고 2그룹이고... 그럼 독립표본 t검정이구나!"**

**⚠️ 하지만 잠깐! 함정이 있어요:**

**표본 크기 확인:**
- 각 그룹에 최소 30명씩은 있나요? 
- 너무 적으면 비모수 검정을 고려해야 해요.

**특수 상황 체크:**
- 혹시 시간에 따른 변화를 보는 건 아닌가요? (반복측정)
- 여러 번 측정한 데이터인가요? (다층 데이터)
- 결측치가 너무 많지는 않나요?

**💡 실무 팁:** 
- 확신이 안 서면 **여러 방법으로 검정**해보세요! 
- SciPy로 기본 t검정 → Statsmodels로 세부 확인 → 비모수 검정으로 재확인
- 결과가 비슷하게 나오면 안심하고 쓰면 돼요.

---

### 🔍 **4단계: 가정 확인 - "내 데이터가 이 검정을 써도 되나?"**

**이거 안 하고 바로 검정하는 사람이 80%예요!** 그런데 가정 위반하면 결과를 믿을 수 없어요.

**🗣️ 각 가정을 쉽게 이해해보면:**

**🎲 정규성 - "내 데이터가 종 모양으로 생겼나?"**
```python
# 이렇게 확인해보세요
import matplotlib.pyplot as plt
plt.hist(data)  # 히스토그램이 종 모양인가?
plt.show()

from scipy.stats import shapiro
stat, p = shapiro(data)  # p > 0.05면 정규분포!
```

> **"히스토그램 봤는데 왼쪽으로 쏠려있어요!"**
→ 정규성 위반. log 변환하거나 비모수 검정 쓰세요.

**⚖️ 등분산성 - "두 그룹의 퍼진 정도가 비슷한가?"**
```python
# 박스플롯으로 눈으로 확인
import seaborn as sns
sns.boxplot(x='그룹', y='값', data=df)  # 박스 크기가 비슷한가?

from scipy.stats import levene
stat, p = levene(group1, group2)  # p > 0.05면 등분산!
```

> **"한 그룹은 값이 다 비슷한데 다른 그룹은 엄청 퍼져있어요!"**
→ 등분산성 위반. Welch's t-test 쓰세요 (equal_var=False)

**🔗 독립성 - "데이터들이 서로 영향 안 주나?"**
- 같은 학교에서 뽑은 학생들? → 독립성 의심
- 같은 가족 구성원들? → 독립성 위반
- 시간 순서대로 측정한 데이터? → 자기상관 가능성

**💡 실무에서는:**
- **가정 위반이 심하지 않으면** 그냥 써도 돼요 (robust)
- **심하게 위반하면** 비모수 검정이나 변환 고려
- **확신이 안 서면** 전문가나 커뮤니티에 물어보세요!

---

### 📈 **5단계: 결과 해석 - "이제 뭘 말해줘야 하지?"**

**통계 결과를 비즈니스 언어로 번역하는 단계예요!**

**🗣️ 실제 보고할 때 이렇게 말하세요:**

**❌ 이렇게 말하지 마세요:**
> "t-statistic이 2.34이고 p-value가 0.021입니다."

**✅ 이렇게 말하세요:**
> "신제품의 고객 만족도가 기존 제품보다 통계적으로 유의하게 높습니다(p<0.05). 구체적으로 신제품은 평균 7.8점, 기존 제품은 7.2점으로 0.6점 차이가 납니다. 이는 실무적으로도 의미 있는 차이로 판단됩니다."

**🎯 꼭 포함해야 할 요소들:**

1. **방향성**: "높다/낮다", "차이가 있다/없다"
2. **통계적 유의성**: "p<0.05로 통계적으로 유의함"
3. **구체적 수치**: "평균 7.8점 vs 7.2점"
4. **실무적 의미**: "고객들이 체감할 수 있는 차이"
5. **신뢰구간**: "95% 신뢰구간 [0.2, 1.0]점 차이"

**📊 시각화도 꼭!**
```python
# 이런 그래프로 보여주세요
sns.boxplot(x='제품종류', y='만족도', data=df)
plt.title('제품별 고객 만족도 비교')
plt.ylabel('만족도 (1-10점)')
```

**⚠️ 절대 하지 말아야 할 해석:**
- ❌ "p=0.049니까 간신히 유의하네요" → 경계선 언급 금지
- ❌ "통계적으로 유의하니까 효과가 크다" → 유의성 ≠ 중요성
- ❌ "이 결과로 모든 고객이 만족할 거다" → 과도한 일반화

**💡 마지막 팁:**
- **효과크기도 꼭 보고하세요**: Cohen's d = 0.5 (중간 효과)
- **한계점도 언급하세요**: "이 연구는 20-30대 직장인 대상으로 한정됨"
- **다음 단계 제안하세요**: "더 정확한 확인을 위해 대규모 A/B 테스트 추천"

---

## 🚨 **현실에서 자주 겪는 함정들 (경험담)**

### 😅 **"숫자면 다 연속형인 줄 알았어요"**
> 실제 사례: 고객 ID를 1,2,3,4...로 매겼는데 이걸로 평균을 구하려고 했던 신입 분석가

### 🤦‍♀️ **"p-value만 보고 끝!"**
> 실제 사례: p=0.03이 나왔는데 실제 차이는 0.001%... 통계적으론 유의하지만 실무적으론 무의미

### 😱 **"가정 확인? 그런 거 있었나요?"**
> 실제 사례: 명백히 비정규분포 데이터에 t검정 써서 완전히 잘못된 결론 도출

### 🤯 **"데이터 많으면 다 유의하게 나와요!"**
> 실제 사례: 100만 건 데이터에서 아무 의미 없는 0.1% 차이도 p<0.001로 유의하게...

**💡 이런 실수들 피하려면:**
- 체크리스트를 종교처럼 따르세요!
- 의심스러우면 다른 방법으로도 확인해보세요!
- 동료나 전문가에게 검토받으세요!
- 비즈니스 상식과 비교해보세요!

**🎯 마지막 조언:**
> 통계는 도구일 뿐이에요. 가장 중요한 건 **"이 결과가 실제로 의미가 있는가?"**를 항상 생각하는 것입니다. 숫자에 매몰되지 말고, 사람과 비즈니스를 생각하세요!

---

## 🚀 다음 단계: 이제 각 검정을 깊이 있게!

이 **22.04 검정 방법 총정리**로 기초를 탄탄히 한 후, 다음 챕터들에서 각 검정을 실전에서 완벽히 활용할 수 있도록 깊이 있게 다뤄보겠습니다:

- **22.05 카이제곱 검정 완전 가이드**: 범주형 데이터 분석의 모든 것
- **22.06 t검정 완전 가이드**: 평균 비교의 핵심 도구  
- **22.07 ANOVA 완전 가이드**: 다중 그룹 비교의 강력한 방법

**이제 어떤 상황에서든 올바른 통계 검정을 자신 있게 선택할 수 있습니다!** 🎯

###자세히 보기 

### 🔍 **Step 1: 데이터 타입 정확히 파악하기**

#### **독립변수 (X) 타입 판별**
```python
def identify_independent_variable(data_description):
    """독립변수 타입을 정확히 식별하는 가이드"""
    
    variable_types = {
        "명목척도(범주형)": {
            "특징": "순서가 없는 카테고리",
            "예시": ["성별(남/여)", "혈액형(A/B/O/AB)", "학과(컴공/경영/의학)", "브랜드(삼성/LG/애플)"],
            "주의점": "숫자로 코딩되어도 범주형일 수 있음 (예: 1=남, 2=여)",
            "Python확인": "df['컬럼'].dtype == 'object' 또는 unique() 개수가 적음"
        },
        
        "서열척도(순서형)": {
            "특징": "순서는 있지만 간격이 일정하지 않음",
            "예시": ["만족도(매우불만/불만/보통/만족/매우만족)", "학점(A/B/C/D/F)", "소득수준(상/중/하)"],
            "주의점": "범주형으로 취급하거나 연속형으로 근사 처리",
            "Python확인": "pd.Categorical 또는 ordered=True 설정"
        },
        
        "연속형(수치형)": {
            "특징": "무한히 많은 값, 사칙연산 가능",
            "예시": ["나이", "키", "몸무게", "소득", "온도", "시간"],
            "주의점": "정수여도 연속형일 수 있음 (예: 나이, 점수)",
            "Python확인": "df['컬럼'].dtype in ['int64', 'float64']"
        }
    }
    
    for var_type, details in variable_types.items():
        print(f"\n📊 {var_type}")
        print("-" * 30)
        for key, value in details.items():
            if isinstance(value, list):
                print(f"   {key}: {', '.join(value)}")
            else:
                print(f"   {key}: {value}")
    
    return variable_types
```

#### **종속변수 (Y) 타입 판별**
```python
def identify_dependent_variable():
    """종속변수 타입별 특징과 주의사항"""
    
    dependent_types = {
        "이진 범주형": {
            "형태": "성공/실패, 합격/불합격, 구매/미구매",
            "값": "0과 1, True/False",
            "적합한검정": "로지스틱 회귀, 카이제곱 검정",
            "Python예": "df['구매여부'].value_counts()  # [0, 1] 또는 [False, True]"
        },
        
        "다중 범주형": {
            "형태": "선호 브랜드, 직업 유형, 질병 종류",
            "값": "3개 이상의 카테고리",
            "적합한검정": "다항 로지스틱 회귀, 카이제곱 검정",
            "Python예": "df['선호브랜드'].nunique() >= 3"
        },
        
        "연속형": {
            "형태": "점수, 매출액, 반응시간, 혈압",
            "값": "실수값, 측정 가능한 수치",
            "적합한검정": "t검정, ANOVA, 회귀분석",
            "Python예": "df['점수'].describe()  # 평균, 표준편차 의미 있음"
        }
    }
    
    print("🎯 종속변수 타입별 가이드")
    print("=" * 40)
    
    for dep_type, details in dependent_types.items():
        print(f"\n📊 {dep_type}")
        for key, value in details.items():
            print(f"   {key}: {value}")
    
    return dependent_types
```

### 🗺️ **Step 2: 검정 선택 매트릭스 2.0**

#### **완전한 검정 선택 테이블**
```python
def complete_test_selection_matrix():
    """포괄적인 통계 검정 선택 가이드"""
    
    test_matrix = {
        # 독립변수가 없는 경우 (단일 변수 분석)
        "단일변수_범주형": {
            "검정": "카이제곱 적합도 검정 (Chi-square Goodness of fit)",
            "목적": "관측 빈도가 기대 빈도와 같은가?",
            "예시": "주사위가 공정한가? 각 면이 1/6 확률로 나오는가?",
            "H0": "관측 빈도 = 기대 빈도",
            "Python": "scipy.stats.chisquare(observed, expected)",
            "가정": "기대빈도 ≥ 5 (모든 범주에서)"
        },
        
        "단일변수_연속형": {
            "검정": "일표본 t검정 (One-sample t-test)",
            "목적": "표본 평균이 특정 값과 같은가?",
            "예시": "우리 반 평균 키가 170cm인가?",
            "H0": "μ = μ₀ (특정 값)",
            "Python": "scipy.stats.ttest_1samp(data, population_mean)",
            "가정": "정규성, 독립성"
        },
        
        # 범주형 독립변수 × 범주형 종속변수
        "범주형_X_범주형": {
            "검정": "카이제곱 독립성/동질성 검정",
            "목적": "두 범주형 변수가 독립인가?",
            "예시": "성별과 선호 브랜드가 관련 있는가?",
            "H0": "두 변수는 독립이다",
            "Python": "scipy.stats.chi2_contingency(crosstab)",
            "가정": "기대빈도 ≥ 5 (모든 셀의 80% 이상)"
        },
        
        # 범주형 독립변수 × 연속형 종속변수  
        "범주형2그룹_X_연속형": {
            "검정": "독립표본 t검정 (Independent t-test)",
            "목적": "두 그룹의 평균이 같은가?",
            "예시": "남녀 평균 키 차이가 있는가?",
            "H0": "μ₁ = μ₂",
            "Python": "scipy.stats.ttest_ind(group1, group2)",
            "가정": "정규성, 등분산성, 독립성"
        },
        
        "범주형3그룹이상_X_연속형": {
            "검정": "일원분산분석 (One-way ANOVA)",
            "목적": "여러 그룹의 평균이 모두 같은가?",
            "예시": "학과별(컴공/경영/의학) 평균 성적이 같은가?",
            "H0": "μ₁ = μ₂ = μ₃ = ... = μₖ",
            "Python": "scipy.stats.f_oneway(group1, group2, group3, ...)",
            "가정": "정규성, 등분산성, 독립성"
        },
        
        # 연속형 독립변수 × 연속형 종속변수
        "연속형_X_연속형": {
            "검정": "상관분석, 회귀분석",
            "목적": "두 연속형 변수 간 관계가 있는가?",
            "예시": "공부시간과 성적 간 관계가 있는가?",
            "H0": "ρ = 0 (상관관계 없음)",
            "Python": "scipy.stats.pearsonr(x, y) 또는 sklearn.linear_model",
            "가정": "선형성, 정규성, 등분산성"
        },
        
        # 특수한 경우들
        "대응표본": {
            "검정": "대응표본 t검정 (Paired t-test)",
            "목적": "같은 대상의 전후 차이가 있는가?",
            "예시": "약물 복용 전후 혈압 차이가 있는가?",
            "H0": "μd = 0 (차이의 평균 = 0)",
            "Python": "scipy.stats.ttest_rel(before, after)",
            "가정": "차이값의 정규성"
        },
        
        "비모수검정": {
            "검정": "Mann-Whitney U, Kruskal-Wallis",
            "목적": "정규성 가정 위반 시 대안",
            "예시": "정규분포하지 않는 데이터의 그룹 비교",
            "H0": "분포가 같다",
            "Python": "scipy.stats.mannwhitneyu(), scipy.stats.kruskal()",
            "가정": "분포 모양 유사성"
        }
    }
    
    print("🗺️ 완전한 통계 검정 선택 매트릭스")
    print("=" * 60)
    
    for scenario, details in test_matrix.items():
        print(f"\n📊 {scenario}")
        print("-" * 40)
        for key, value in details.items():
            print(f"   {key}: {value}")
    
    return test_matrix
```

---

## 🚦 22.04.02 실무 검정 선택 플로우차트

### 🔄 **단계별 의사결정 트리**

```python
def statistical_test_flowchart():
    """실무용 통계 검정 선택 플로우차트"""
    
    def step1_question():
        print("🚦 Step 1: 독립변수가 있나요?")
        print("=" * 40)
        print("   독립변수 있음 → Step 2로")
        print("   독립변수 없음 → 단일변수 분석")
        print("     ├─ 범주형 → 카이제곱 적합도 검정")
        print("     └─ 연속형 → 일표본 t검정")
    
    def step2_question():
        print("\n🚦 Step 2: 독립변수 타입은?")
        print("=" * 40)
        print("   범주형 → Step 3으로")
        print("   연속형 → Step 4로")
    
    def step3_question():
        print("\n🚦 Step 3: 종속변수 타입은?")
        print("=" * 40)
        print("   범주형 → 카이제곱 독립성 검정")
        print("   연속형 → Step 3-1로")
        print("")
        print("   🚦 Step 3-1: 독립변수 그룹 개수는?")
        print("     2그룹 → t검정 (독립/대응 확인)")
        print("     3그룹 이상 → ANOVA")
    
    def step4_question():
        print("\n🚦 Step 4: 연속형 X 연속형")
        print("=" * 40)
        print("   상관분석 → Pearson correlation")
        print("   예측모델 → 회귀분석")
    
    def assumptions_check():
        print("\n⚠️  최종 체크: 가정 확인")
        print("=" * 40)
        print("   정규성 위반 → 비모수 검정 고려")
        print("   등분산성 위반 → Welch's t-test 고려")
        print("   독립성 위반 → 반복측정 설계 고려")
    
    # 전체 플로우차트 실행
    step1_question()
    step2_question()  
    step3_question()
    step4_question()
    assumptions_check()
    
    # 실무 체크리스트
    checklist = {
        "✅ 데이터 확인": [
            "결측치와 이상치 처리 완료?",
            "각 변수의 타입 정확히 파악?",
            "표본 크기가 충분한가?"
        ],
        "✅ 가정 확인": [
            "정규성 검정 (Shapiro-Wilk, K-S test)",
            "등분산성 검정 (Levene's test)", 
            "독립성 확인 (데이터 수집 방법)"
        ],
        "✅ 해석 준비": [
            "효과크기 계산 준비",
            "실무적 의미 해석 계획",
            "추가 분석 필요성 검토"
        ]
    }
    
    print("\n📋 실무 체크리스트")
    print("=" * 30)
    
    for category, items in checklist.items():
        print(f"\n{category}")
        for item in items:
            print(f"   □ {item}")
    
    return checklist
```

### 🎯 **실제 상황별 검정 선택 예제**

```python
def real_world_scenarios():
    """실무에서 자주 만나는 상황별 검정 선택"""
    
    scenarios = {
        "🛒 전자상거래": {
            "상황1": {
                "문제": "A/B 테스트: 새 버튼 색깔이 클릭률을 높이는가?",
                "독립변수": "버튼색깔 (기존/신규) - 범주형",
                "종속변수": "클릭 여부 (0/1) - 범주형",
                "선택검정": "카이제곱 독립성 검정",
                "Python": "chi2_contingency([[클릭안함_기존, 클릭함_기존], [클릭안함_신규, 클릭함_신규]])"
            },
            "상황2": {
                "문제": "남녀별 평균 구매금액 차이가 있는가?",
                "독립변수": "성별 (남/여) - 범주형",
                "종속변수": "구매금액 - 연속형",
                "선택검정": "독립표본 t검정",
                "Python": "ttest_ind(남성구매금액, 여성구매금액)"
            }
        },
        
        "🏥 의료/제약": {
            "상황1": {
                "문제": "신약이 기존약보다 효과적인가?",
                "독립변수": "약물종류 (기존/신규) - 범주형",
                "종속변수": "치료효과점수 - 연속형",
                "선택검정": "독립표본 t검정",
                "Python": "ttest_ind(기존약그룹, 신약그룹)"
            },
            "상황2": {
                "문제": "약물 복용 전후 혈압 변화가 있는가?",
                "독립변수": "시점 (복용전/복용후) - 범주형",
                "종속변수": "혈압 - 연속형",
                "특징": "같은 환자의 전후 측정",
                "선택검정": "대응표본 t검정",
                "Python": "ttest_rel(복용전혈압, 복용후혈압)"
            }
        },
        
        "🎓 교육": {
            "상황1": {
                "문제": "교육방법별(강의/토론/실습) 학습효과 차이가 있는가?",
                "독립변수": "교육방법 (3가지) - 범주형",
                "종속변수": "시험점수 - 연속형",
                "선택검정": "일원분산분석 (ANOVA)",
                "Python": "f_oneway(강의그룹점수, 토론그룹점수, 실습그룹점수)"
            },
            "상황2": {
                "문제": "공부시간과 성적 간 관계가 있는가?",
                "독립변수": "공부시간 - 연속형",
                "종속변수": "성적 - 연속형",
                "선택검정": "상관분석, 회귀분석",
                "Python": "pearsonr(공부시간, 성적) 또는 LinearRegression()"
            }
        },
        
        "📊 마케팅": {
            "상황1": {
                "문제": "광고 채널별 고객만족도 분포가 다른가?",
                "독립변수": "광고채널 (TV/온라인/인쇄) - 범주형",
                "종속변수": "만족도 (매우불만~매우만족) - 서열형",
                "선택검정": "카이제곱 독립성 검정 또는 Kruskal-Wallis",
                "Python": "chi2_contingency(pd.crosstab(채널, 만족도))"
            }
        }
    }
    
    print("🎯 실무 상황별 검정 선택 가이드")
    print("=" * 50)
    
    for domain, cases in scenarios.items():
        print(f"\n{domain}")
        print("-" * 30)
        
        for case_name, details in cases.items():
            print(f"\n  📌 {case_name}")
            for key, value in details.items():
                print(f"     {key}: {value}")
    
    return scenarios
```

---

## ⚙️ 22.04.03 각 검정의 가정과 조건들

### 🔍 **가정 위반 시 대처법**

```python
def assumption_checking_guide():
    """통계 검정 가정 확인 및 위반 시 대처 가이드"""
    
    assumptions = {
        "정규성 (Normality)": {
            "확인방법": [
                "Shapiro-Wilk test (n < 50)",
                "Kolmogorov-Smirnov test (n ≥ 50)",
                "Q-Q plot 시각적 확인",
                "히스토그램 및 boxplot"
            ],
            "Python코드": """
# 정규성 검정
from scipy.stats import shapiro, kstest
statistic, p_value = shapiro(data)  # n < 50
statistic, p_value = kstest(data, 'norm')  # n ≥ 50

# 시각적 확인
import matplotlib.pyplot as plt
import scipy.stats as stats
stats.probplot(data, dist="norm", plot=plt)
plt.show()
""",
            "위반시대처": [
                "비모수 검정 사용 (Mann-Whitney U, Kruskal-Wallis)",
                "데이터 변환 (log, sqrt, Box-Cox)",
                "표본크기 증가 (중심극한정리 활용)",
                "부트스트랩 방법 사용"
            ]
        },
        
        "등분산성 (Homoscedasticity)": {
            "확인방법": [
                "Levene's test",
                "Bartlett's test",
                "잔차 vs 예측값 산점도"
            ],
            "Python코드": """
from scipy.stats import levene, bartlett

# 등분산성 검정
statistic, p_value = levene(group1, group2)  # 더 robust
statistic, p_value = bartlett(group1, group2)  # 정규성 가정

# 시각적 확인
plt.scatter(predicted_values, residuals)
plt.xlabel('Predicted Values')
plt.ylabel('Residuals')
""",
            "위반시대처": [
                "Welch's t-test 사용 (equal_var=False)",
                "비모수 검정 사용",
                "데이터 변환",
                "가중회귀분석 (WLS)"
            ]
        },
        
        "독립성 (Independence)": {
            "확인방법": [
                "데이터 수집 과정 검토",
                "Durbin-Watson test (시계열)",
                "잔차의 자기상관 확인"
            ],
            "Python코드": """
from statsmodels.stats.diagnostic import durbin_watson

# 독립성 검정 (시계열 데이터)
dw_statistic = durbin_watson(residuals)
# 2에 가까우면 독립성 만족

# 클러스터링 데이터 확인
# 같은 학교, 같은 병원 등에서 수집된 데이터
""",
            "위반시대처": [
                "혼합효과모델 (Mixed Effects Model)",
                "클러스터 표준오차 사용",
                "반복측정 ANOVA",
                "시계열 분석 방법"
            ]
        }
    }
    
    print("⚙️ 통계 검정 가정 확인 가이드")
    print("=" * 45)
    
    for assumption, details in assumptions.items():
        print(f"\n🔍 {assumption}")
        print("-" * 30)
        
        for key, value in details.items():
            if key == "Python코드":
                print(f"\n   💻 {key}:")
                print(value)
            elif isinstance(value, list):
                print(f"\n   📋 {key}:")
                for item in value:
                    print(f"      • {item}")
            else:
                print(f"\n   📝 {key}: {value}")
    
    return assumptions
```

---

## 💻 22.04.04 Python 도구별 구현 가이드

### 🛠️ **라이브러리별 특징과 활용법**

```python
def python_libraries_comparison():
    """Python 통계 라이브러리 비교 및 활용 가이드"""
    
    libraries = {
        "SciPy.stats": {
            "장점": ["가장 기본적", "간단한 사용법", "대부분의 검정 포함"],
            "단점": ["결과 해석 정보 부족", "고급 기능 제한"],
            "주요함수": [
                "ttest_1samp(), ttest_ind(), ttest_rel()",
                "chi2_contingency(), chisquare()",
                "f_oneway(), pearsonr()"
            ],
            "예제코드": """
from scipy.stats import ttest_ind
t_stat, p_value = ttest_ind(group1, group2)
print(f"t-statistic: {t_stat:.4f}, p-value: {p_value:.4f}")
"""
        },
        
        "Statsmodels": {
            "장점": ["자세한 통계 정보", "회귀분석 강점", "R과 유사한 결과"],
            "단점": ["복잡한 문법", "학습곡선 가파름"],
            "주요함수": [
                "ols(), logit(), anova_lm()",
                "ttest_ind(), levene(), shapiro()"
            ],
            "예제코드": """
import statsmodels.api as sm
from statsmodels.formula.api import ols

# ANOVA 예제
model = ols('점수 ~ C(그룹)', data=df).fit()
anova_table = sm.stats.anova_lm(model, typ=2)
print(anova_table)
"""
        },
        
        "Pingouin": {
            "장점": ["사용하기 쉬움", "한번에 많은 정보", "효과크기 자동 계산"],
            "단점": ["상대적으로 신생", "일부 고급 기능 부족"],
            "주요함수": [
                "ttest(), anova(), chi2_independence()",
                "corr(), partial_corr()"
            ],
            "예제코드": """
import pingouin as pg

# 간단한 t-test (효과크기 포함)
result = pg.ttest(group1, group2)
print(result)  # Cohen's d도 함께 출력
"""
        }
    }
    
    print("💻 Python 통계 라이브러리 비교")
    print("=" * 45)
    
    for lib_name, details in libraries.items():
        print(f"\n📚 {lib_name}")
        print("-" * 25)
        
        for key, value in details.items():
            if key == "예제코드":
                print(f"\n   💻 {key}:")
                print(value)
            elif isinstance(value, list):
                print(f"\n   📋 {key}:")
                for item in value:
                    print(f"      • {item}")
            else:
                print(f"\n   📝 {key}: {value}")
    
    # 추천 사용법
    recommendations = {
        "초보자": "Pingouin → SciPy",
        "회귀분석 중심": "Statsmodels",
        "빠른 검정": "SciPy",
        "논문용 분석": "Statsmodels + Pingouin"
    }
    
    print(f"\n🎯 상황별 추천 라이브러리:")
    for situation, recommendation in recommendations.items():
        print(f"   {situation}: {recommendation}")
    
    return libraries
```

### 🎨 **검정 결과 시각화 템플릿**

```python
def visualization_templates():
    """통계 검정 결과 시각화 템플릿"""
    
    print("🎨 검정 결과 시각화 템플릿")
    print("=" * 40)
    
    templates = {
        "t검정 결과 시각화": """
import matplotlib.pyplot as plt
import seaborn as sns

# 두 그룹 비교 시각화
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# 박스플롯
sns.boxplot(data=df, x='그룹', y='값', ax=ax1)
ax1.set_title('그룹별 분포 비교')

# 히스토그램
df[df['그룹'] == 'A']['값'].hist(alpha=0.5, label='Group A', ax=ax2)
df[df['그룹'] == 'B']['값'].hist(alpha=0.5, label='Group B', ax=ax2)
ax2.legend()
ax2.set_title('그룹별 히스토그램')

plt.tight_layout()
plt.show()
""",
        
        "ANOVA 결과 시각화": """
# 바이올린 플롯으로 다중 그룹 비교
plt.figure(figsize=(10, 6))
sns.violinplot(data=df, x='그룹', y='값')
plt.title('그룹별 분포 비교 (ANOVA)')

# 사후 검정 결과 추가
# from scipy.stats import tukey_hsd
# tukey_result = tukey_hsd(group1, group2, group3)
plt.show()
""",
        
        "카이제곱 검정 시각화": """
# 교차표 히트맵
crosstab = pd.crosstab(df['변수1'], df['변수2'])
plt.figure(figsize=(8, 6))
sns.heatmap(crosstab, annot=True, fmt='d', cmap='Blues')
plt.title('변수1 × 변수2 교차표')
plt.show()

# 스택 바 차트
crosstab_pct = pd.crosstab(df['변수1'], df['변수2'], normalize='index')
crosstab_pct.plot(kind='bar', stacked=True)
plt.title('변수1별 변수2 구성비')
plt.show()
""",
        
        "상관분석 시각화": """
# 산점도 + 회귀선
plt.figure(figsize=(8, 6))
sns.scatterplot(data=df, x='변수1', y='변수2')
sns.regplot(data=df, x='변수1', y='변수2', scatter=False, color='red')
plt.title(f'상관계수: {correlation:.3f}')
plt.show()

# 상관계수 히트맵
correlation_matrix = df.corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
plt.title('상관계수 매트릭스')
plt.show()
"""
    }
    
    for viz_type, code in templates.items():
        print(f"\n📊 {viz_type}")
        print("-" * 30)
        print(code)
    
    return templates
```
