# 파이썬 파일 시스템 완전 정리 📁

> **판다스 파일 I/O를 배우기 전에** 파이썬 기본 파일 시스템부터 차근차근 정리해보자!

---

## 🎯 **학습 목표**

1. **파이썬 기본 파일 입출력** 완전 이해
2. **모듈과 객체 저장** 방법 익히기  
3. **데이터베이스 연동** 기본기 다지기
4. **웹 스크래핑** 파일 처리 응용

---

## 📚 **1. 모듈(Module) 시스템**

### 🔧 **import를 이용한 모듈 활용**

파이썬에서 **모듈은 함수들과 변수들을 모아놓은 것**입니다. 한번 만들어두면 `import`만 하면 언제든 재사용 가능해요!

```python
# sys 모듈을 이용한 명령행 인수 처리
import sys

# 명령행에서 전달받은 인수들
args = sys.argv[0:]  # argv[0]은 스크립트 이름, 나머지는 인수들

print("전달받은 인수들:")
for i, arg in enumerate(args):
    print(f"{i}: {arg}")

# 실행 예시: python script.py 파라미터1 파라미터2
# 결과:
# 0: script.py
# 1: 파라미터1  
# 2: 파라미터2
```

**💡 DOS 명령어와 비교**
- DOS `type` 명령: 파일 내용 확인
- 파이썬 `sys` 모듈: 더 강력한 시스템 제어 기능

---

## 📝 **2. 파일 입출력 함수**

### 🗂️ **파일 열기 모드**

이미지에서 보셨듯이, 파이썬은 3가지 주요 모드로 파일을 다룹니다:

| 모드 | 영어 이름 | 설명 | 특징 |
|------|----------|------|------|
| `"r"` | read mode | 읽기 모드 | 파일의 처음부터 읽는다 |
| `"w"` | write mode | 쓰기 모드 | 파일의 처음부터 쓴다. 기존 내용 삭제됨 |
| `"a"` | append mode | 추가 모드 | 파일의 끝에 쓴다. 파일이 없으면 생성됨 |
| `"r+"` | 읽기+쓰기 모드 | 읽고 쓸 수 있는 모드 | seek()가 호출되어야 함 |

### 📖 **기본 파일 입출력 패턴**

```python
# 기본 패턴: 열기 → 작업 → 닫기
# 1. 파일 열기
fp = open("파일명", "모드")

# 2. 파일 작업 (읽기/쓰기)
# ... 작업 수행 ...

# 3. 파일 닫기 (중요!)
fp.close()
```

### ✍️ **파일 쓰기 실습**

```python
# 파일에 내용 쓰기
fp = open("io_test.txt", "w")

for i in range(1, 5):
    content = f"{i}번째 라인~\n"
    fp.write(content)
 
fp.close()

print("파일 저장 완료!")
```

### 📚 **파일 읽기 방법들**

```python
# 방법 1: 한 줄씩 읽기
fp = open("io_test.txt", "r")
while True:
    data = fp.readline()
    if not data:  # 파일 끝에 도달
        break
    print(data.strip())  # \n 제거하고 출력
fp.close()

# 방법 2: 모든 줄을 리스트로 읽기
fp = open("io_test.txt", "r")
lines = fp.readlines()
for line in lines:
    print(line.strip())
fp.close()

# 방법 3: 전체 파일을 문자열로 읽기
fp = open("io_test.txt", "r")
data = fp.read()
print(data)
fp.close()
```

### 📌 **with문 사용 (권장!)**

```python
# with문을 사용하면 자동으로 파일이 닫혀요!
with open("io_test.txt", "w") as fp:
    fp.write("with문을 이용한 파일 입출력 테스트")

# fp.close() 자동 호출됨! 😍
```

### 🔍 **split() 함수 활용**

```python
# 파일의 각 단어를 분리해서 처리
with open("proverbs.txt", "r") as infile:
    for line in infile:
        line = line.rstrip()  # 오른쪽 공백 제거
        word_list = line.split()  # 공백으로 분리
        for word in word_list:
            print(word)
```

### 📋 **파일 복사 프로그램**

```python
# 사용자로부터 파일명 입력받아 복사하기
def copy_file():
    # 입력 파일 이름과 출력 파일 이름을 받는다
    infilename = input("입력 파일 이름: ")
    outfilename = input("출력 파일 이름: ")

    try:
        # 입력과 출력을 위한 파일을 연다
        with open(infilename, "r") as infile:
            with open(outfilename, "w") as outfile:
                # 전체 파일을 읽어서 쓴다
                content = infile.read()
                outfile.write(content)
        
        print("파일 복사 완료!")
        
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")
    except Exception as e:
        print(f"오류 발생: {e}")
```

---

## 🎮 **3. 실전 프로젝트: 행맨 게임**

```python
import random

def hangman_game():
    # 단어 파일에서 랜덤 선택
    with open("words.txt", "r", encoding='utf-8') as infile:
        lines = infile.readlines()
        word = random.choice(lines).strip()

    guesses = ''
    turns = 10

    print("🎮 행맨 게임을 시작합니다!")
    print(f"단어 길이: {len(word)}글자")

    while turns > 0:
        failed = 0
        
        # 현재 상태 출력
        for char in word:
            if char in guesses:
                print(char, end="")
            else:
                print("_", end="")
                failed += 1
        
        if failed == 0:
            print("\n🎉 축하합니다! 정답을 맞혔습니다!")
            break
        
        print(f"\n남은 기회: {turns}")
        guess = input("글자를 입력하세요: ")
        guesses += guess
        
        if guess not in word:
            turns -= 1
            print("❌ 틀렸습니다!")
            if turns == 0:
                print(f"💀 게임 오버! 정답은 '{word}'였습니다.")

# 게임 실행
hangman_game()
```

---

## 🗃️ **4. 객체 입출력 (Pickle)**

### 🥒 **pickle 모듈 기본 사용법**

**pickle은 파이썬 객체를 파일로 저장하고 불러오는 모듈**입니다.

```python
import pickle

# 게임 설정 딕셔너리
game_option = {
    "Sound": 8,
    "VideoQuality": "HIGH", 
    "Money": 100000,
    "WeaponList": ["gun", "missile", "knife"]
}

# 객체를 파일로 저장 (직렬화)
with open("save.p", "wb") as file:  # 바이너리 쓰기 모드
    pickle.dump(game_option, file)

print("게임 데이터 저장 완료!")

# 파일에서 객체 불러오기 (역직렬화)  
with open("save.p", "rb") as file:  # 바이너리 읽기 모드
    loaded_data = pickle.load(file)

print("불러온 데이터:", loaded_data)
```

### 👥 **사용자 정의 객체 pickle 처리**

```python
import pickle

class Person:
    def __init__(self, id, name, age):
        self.id = id
        self.name = name
        self.age = age
    
    def get_data(self):
        return f"{self.id}, {self.name}, {self.age}"
    
    # pickle 커스터마이징 (선택사항)
    def __getstate__(self):
        """직렬화 전 호출"""
        state = self.__dict__.copy()
        print(f"저장 중: {self.name}")
        return state
    
    def __setstate__(self, state):
        """역직렬화 후 호출"""
        self.__dict__.update(state)
        print(f"복원됨: {self.name}")

# 객체들을 리스트로 만들기
people = [
    Person('hong', 'gildong', 33),
    Person('kim', 'gilsoon', 23), 
    Person('lee', 'soonsin', 43)
]

# 객체 리스트 저장
with open("people.pickle", "wb") as f:
    pickle.dump(people, f)

# 객체 리스트 불러오기
with open("people.pickle", "rb") as f:
    loaded_people = pickle.load(f)

print("복원된 사람들:")
for person in loaded_people:
    print(person.get_data())
```

### 🔄 **pickle의 dumps/loads 메서드**

```python
# 파일이 아닌 바이트 객체로 변환
people_bytes = pickle.dumps(people)  # 바이트로 직렬화
print(f"바이트 크기: {len(people_bytes)}")

# 바이트에서 객체로 복원
restored_people = pickle.loads(people_bytes)  # 바이트에서 역직렬화

for person in restored_people:
    print(person.get_data())
```

---

## 🌐 **5. JSON 모듈**

### 📋 **JSON vs Pickle 비교**

| 특징 | Pickle | JSON |
|------|--------|------|
| **형식** | 바이너리 | 텍스트 |
| **언어 호환성** | 파이썬 전용 | 모든 언어 |
| **사용자 정의 클래스** | ✅ 지원 | ❌ 제한적 |
| **웹 API** | ❌ 부적합 | ✅ 표준 |
| **파일 크기** | 작음 | 상대적으로 큼 |

### 🗂️ **JSON 기본 사용법**

```python
import json

# 파이썬 딕셔너리
person_data = {
    'id': 'kim',
    'name': '김범준', 
    'age': 60,
    'skills': ['Python', 'JSON', 'API']
}

# 딕셔너리 → JSON 문자열
json_string = json.dumps(person_data, ensure_ascii=False, indent=2)
print("JSON 문자열:")
print(json_string)

# JSON 문자열 → 딕셔너리  
parsed_data = json.loads(json_string)
print("파싱된 데이터:", parsed_data)

# 파일로 저장/불러오기
with open("person.json", "w", encoding='utf-8') as f:
    json.dump(person_data, f, ensure_ascii=False, indent=2)

with open("person.json", "r", encoding='utf-8') as f:
    loaded_data = json.load(f)
    print("파일에서 불러온 데이터:", loaded_data)
```

### 🔄 **Python ↔ JSON 타입 변환**

```python
# Python 타입과 JSON 타입 매핑
type_mapping = {
    'dict': 'object',
    'list/tuple': 'array', 
    'str': 'string',
    'int': 'number (int)',
    'float': 'number (real)',
    'True': 'true',
    'False': 'false', 
    'None': 'null'
}

print("Python → JSON 타입 변환:")
for py_type, json_type in type_mapping.items():
    print(f"  {py_type:12} → {json_type}")
```

---

## ⚡ **6. Marshal 모듈 (빠른 임시 저장)**

```python
import marshal

# marshal은 속도가 빠르지만 제한적
data = [
    {'name': '홍길순', 'height': 170, 'weight': 60},
    {'name': '홍길동', 'height': 200, 'weight': 80}
]

# 빠른 저장 (pickle보다 몇 배 빠름)
with open('data.marshal', 'wb') as f:
    marshal.dump(data, f)

# 빠른 불러오기
with open('data.marshal', 'rb') as f:
    loaded_data = marshal.load(f)

print("Marshal 데이터:", loaded_data)
```

**⚠️ Marshal 사용 시 주의사항:**
- 객체 중복 처리 ❌
- 사용자 정의 데이터 처리 ❌  
- 버전별 호환성 ❌
- **임시 저장용으로만 사용** 권장

---

## 🗄️ **7. SQLite 데이터베이스**

### 💾 **SQLite 기본 명령어**

```bash
# SQLite 실행
sqlite3 mydb.db

# 기본 명령어들
.quit          # 종료
.database      # 데이터베이스 목록
.tables        # 테이블 목록
.schema 테이블명  # 테이블 구조
.help          # 도움말
.header on     # 헤더 표시
.mode column   # 컬럼 모드
```

### 🏗️ **테이블 생성과 데이터 조작**

```sql
-- 테이블 생성
CREATE TABLE person (
    no INTEGER PRIMARY KEY,  -- 자동 증가
    id VARCHAR(20),
    name VARCHAR(20), 
    age INTEGER
);

-- 데이터 입력
INSERT INTO person(id, name, age) VALUES('hong', 'gildong', 33);
INSERT INTO person(id, name, age) VALUES('kim', 'gilsoon', 25);

-- 데이터 조회
SELECT * FROM person;

-- 데이터 수정
UPDATE person SET age = 35 WHERE id = 'hong';

-- 데이터 삭제
DELETE FROM person WHERE id = 'kim';
```

### 🐍 **Python에서 SQLite 사용**

```python
import sqlite3

def sqlite_example():
    # 데이터베이스 연결 (파일이 없으면 생성)
    conn = sqlite3.connect('test.db')
    
    try:
        # 테이블 생성
        create_sql = '''
        CREATE TABLE IF NOT EXISTS person(
            no INTEGER PRIMARY KEY,
            id VARCHAR(20),
            name VARCHAR(20),
            age INTEGER
        )
        '''
        
        cursor = conn.cursor()
        cursor.execute(create_sql)
        
        # 데이터 입력 (안전한 방법)
        insert_sql = '''INSERT INTO person(id, name, age) VALUES(?, ?, ?)'''
        
        # 단일 데이터 입력
        cursor.execute(insert_sql, ('park', 'gildong', 34))
        
        # 다중 데이터 입력
        people_data = [
            ('kim', 'gisu', 11),
            ('cho', 'gildong', 21), 
            ('nam', 'gildong', 31)
        ]
        cursor.executemany(insert_sql, people_data)
        
        # 데이터 조회
        cursor.execute('SELECT * FROM person')
        
        print("=== 전체 데이터 ===")
        for row in cursor.fetchall():
            print(f"번호: {row[0]}, ID: {row[1]}, 이름: {row[2]}, 나이: {row[3]}")
        
        # 변경사항 저장
        conn.commit()
        print("데이터 저장 완료!")
        
    except sqlite3.Error as e:
        print(f"SQLite 오류: {e}")
        conn.rollback()
        
    finally:
        cursor.close()
        conn.close()

# 실행
sqlite_example()
```

---

## 🌐 **8. MySQL 데이터베이스**

### ⚙️ **MySQL 기본 명령어**

```bash
# MySQL 접속
mysql -hlocalhost -uroot -p비밀번호 데이터베이스명

# 데이터베이스 관리
SHOW DATABASES;           # DB 목록 보기
CREATE DATABASE mydb;     # DB 생성
DROP DATABASE mydb;       # DB 삭제  
USE mydb;                # DB 선택
```

### 🏗️ **테이블 생성**

```sql
-- 기존 테이블 삭제 (있다면)
DROP TABLE IF EXISTS person;

-- 새 테이블 생성
CREATE TABLE IF NOT EXISTS person(
    idx INT NOT NULL AUTO_INCREMENT,
    name VARCHAR(20),
    phone VARCHAR(20),
    PRIMARY KEY(idx)
);
```

### 🐍 **Python에서 MySQL 사용 (PyMySQL)**

```python
import pymysql

def mysql_example():
    # MySQL 연결
    conn = pymysql.connect(
        user='root',
        password='12345',  
        host='localhost',
        db='test',
        charset='utf8'
    )
    
    try:
        cursor = conn.cursor()
        
        # 데이터 입력
        def insert_data(name, phone):
            sql = "INSERT INTO person (name, phone) VALUES(%s, %s)"
            cursor.execute(sql, (name, phone))
            conn.commit()
            print(f"✅ {name} 데이터 입력 완료")
        
        # 데이터 조회
        def select_data(name=None):
            if name:
                sql = "SELECT * FROM person WHERE name=%s"
                cursor.execute(sql, name)
            else:
                sql = "SELECT * FROM person"
                cursor.execute(sql)
                
            results = cursor.fetchall()
            print("=== 조회 결과 ===")
            for row in results:
                print(f"ID: {row[0]}, 이름: {row[1]}, 전화: {row[2]}")
        
        # 데이터 수정
        def update_data(idx, name, phone):
            sql = "UPDATE person SET name=%s, phone=%s WHERE idx=%s"
            cursor.execute(sql, (name, phone, idx))
            conn.commit()
            print(f"✅ ID {idx} 데이터 수정 완료")
        
        # 데이터 삭제
        def delete_data(idx):
            sql = "DELETE FROM person WHERE idx=%s"
            cursor.execute(sql, (idx,))
            conn.commit()
            print(f"✅ ID {idx} 데이터 삭제 완료")
        
        # 실제 사용 예시
        insert_data('홍길동', '010-1111-1111')
        insert_data('김철수', '010-2222-2222')
        select_data()
        
        update_data(1, '홍길순', '010-9999-9999') 
        select_data()
        
        delete_data(2)
        select_data()
        
    except pymysql.Error as e:
        print(f"MySQL 오류: {e}")
        conn.rollback()
        
    finally:
        cursor.close()
        conn.close()

# 실행
mysql_example()
```

---

## 🎯 **9. 실무 활용 예제: 메모장 프로그램**

```python
from tkinter import *
from tkinter import filedialog, messagebox

class SimpleMemo:
    def __init__(self):
        self.window = Tk()
        self.window.title("간단한 메모장")
        self.window.geometry("800x600")
        
        # 텍스트 영역
        self.text = Text(self.window, height=30, width=80)
        self.text.pack(fill=BOTH, expand=True)
        
        # 메뉴 생성
        self.create_menu()
    
    def create_menu(self):
        menubar = Menu(self.window)
        self.window.config(menu=menubar)
        
        # 파일 메뉴
        file_menu = Menu(menubar, tearoff=0)
        menubar.add_cascade(label="파일", menu=file_menu)
        file_menu.add_command(label="열기", command=self.open_file)
        file_menu.add_command(label="저장", command=self.save_file)
        file_menu.add_separator()
        file_menu.add_command(label="종료", command=self.exit_program)
        
        # 도움말 메뉴
        help_menu = Menu(menubar, tearoff=0)
        menubar.add_cascade(label="도움말", menu=help_menu) 
        help_menu.add_command(label="정보", command=self.show_about)
    
    def open_file(self):
        file = filedialog.askopenfile(parent=self.window, mode='r', 
                                     filetypes=[("텍스트 파일", "*.txt"), 
                                               ("모든 파일", "*.*")])
        if file:
            content = file.read()
            self.text.delete(1.0, END)
            self.text.insert(1.0, content)
            file.close()
    
    def save_file(self):
        file = filedialog.asksaveasfile(parent=self.window, mode='w',
                                       defaultextension=".txt",
                                       filetypes=[("텍스트 파일", "*.txt"),
                                                 ("모든 파일", "*.*")])
        if file:
            content = self.text.get(1.0, END + '-1c')
            file.write(content)
            file.close()
    
    def exit_program(self):
        if messagebox.askokcancel("종료", "정말 종료하시겠습니까?"):
            self.window.destroy()
    
    def show_about(self):
        messagebox.showinfo("정보", "간단한 메모장 프로그램\n파이썬 파일 I/O 예제")
    
    def run(self):
        self.window.mainloop()

# 메모장 실행
if __name__ == "__main__":
    memo = SimpleMemo()
    memo.run()
```

---

## 📋 **10. 파일 형식별 선택 가이드**

### 🎯 **상황별 권장 파일 형식**

```python
# 상황별 파일 형식 선택 가이드

scenarios = {
    "설정 파일 저장": {
        "권장": "JSON",
        "이유": "사람이 읽기 쉽고, 다른 언어와 호환",
        "예시": "config.json"
    },
    
    "파이썬 객체 임시 저장": {
        "권장": "Pickle", 
        "이유": "빠르고 모든 파이썬 객체 지원",
        "예시": "cache.pickle"
    },
    
    "웹 API 데이터": {
        "권장": "JSON",
        "이유": "웹 표준, 자바스크립트 호환", 
        "예시": "api_response.json"
    },
    
    "대용량 숫자 데이터": {
        "권장": "CSV + Pandas",
        "이유": "범용적이고 빠른 처리",
        "예시": "big_data.csv"
    },
    
    "구조화된 데이터": {
        "권장": "SQLite/MySQL",
        "이유": "관계형 데이터, 복잡한 쿼리",
        "예시": "database.db"
    }
}

for situation, info in scenarios.items():
    print(f"📌 {situation}")
    print(f"   권장: {info['권장']}")  
    print(f"   이유: {info['이유']}")
    print(f"   예시: {info['예시']}\n")
```

---

## 🚨 **11. 자주 발생하는 문제와 해결책**

### 1️⃣ **인코딩 문제**

```python
def safe_file_read(filepath):
    """안전한 파일 읽기 - 여러 인코딩 시도"""
    encodings = ['utf-8', 'utf-8-sig', 'cp949', 'euc-kr']
    
    for encoding in encodings:
        try:
            with open(filepath, 'r', encoding=encoding) as f:
                content = f.read()
                print(f"✅ 성공: {encoding}")
                return content
        except UnicodeDecodeError:
            print(f"❌ 실패: {encoding}")
            continue
    
    print("모든 인코딩 시도 실패")
    return None
```

### 2️⃣ **파일 존재 여부 확인**

```python
import os

def safe_file_operation(filepath, operation='read'):
    """안전한 파일 작업"""
    
    if operation == 'read':
        if not os.path.exists(filepath):
            print(f"파일이 존재하지 않습니다: {filepath}")
            return None
            
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return f.read()
        except Exception as e:
            print(f"파일 읽기 오류: {e}")
            return None
    
    elif operation == 'write':
        # 디렉토리가 없으면 생성
        directory = os.path.dirname(filepath)
        if directory and not os.path.exists(directory):
            os.makedirs(directory)
            print(f"디렉토리 생성: {directory}")
        
        return filepath
```

### 3️⃣ **메모리 효율적인 대용량 파일 처리**

```python
def process_large_file(filepath, chunk_size=1024):
    """대용량 파일을 청크 단위로 처리"""
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            line_count = 0
            
            while True:
                lines = f.readlines(chunk_size)
                if not lines:
                    break
                
                # 청크 단위로 처리
                for line in lines:
                    line_count += 1
                    # 여기서 각 줄 처리
                    process_line(line.strip())
                
                print(f"처리된 줄 수: {line_count}")
        
        print(f"총 {line_count}줄 처리 완료")
        
    except Exception as e:
        print(f"파일 처리 오류: {e}")

def process_line(line):
    """각 줄을 처리하는 함수"""
    # 실제 처리 로직
    pass
```

---

## 🎓 **12. 핵심 요약**

### ✅ **꼭 기억할 포인트**

1. **파일 모드 선택**
   - `'r'`: 읽기 전용 
   - `'w'`: 쓰기 (기존 내용 삭제)
   - `'a'`: 추가 (기존 내용 유지)
   - `'rb'/'wb'`: 바이너리 모드

2. **안전한 파일 처리**
   - `with` 문 사용으로 자동 close
   - 예외 처리로 안정성 확보
   - 인코딩 명시적 지정

3. **객체 저장 방식 선택**
   - **Pickle**: 파이썬 전용, 모든 객체 지원
   - **JSON**: 범용적, 웹 친화적
   - **Marshal**: 빠르지만 제한적

4. **데이터베이스 활용**
   - **SQLite**: 간단한 로컬 DB
   - **MySQL**: 본격적인 서버 DB
   - 파라미터화 쿼리로 보안 강화

### 🚀 **다음 단계**

이제 **파이썬 기본 파일 시스템**을 완전히 이해했으니, **판다스의 강력한 파일 I/O 기능**을 배울 준비가 됐습니다!

판다스에서는 이런 기본기를 바탕으로:
- 더 빠른 CSV 처리
- Excel 다중 시트 지원  
- 대용량 데이터 청크 처리
- 웹 스크래핑과 연동

등의 고급 기능들을 제공합니다. 🔥

---

*파이썬 파일 시스템의 모든 것을 담았습니다. 이제 판다스로 넘어가 볼까요?* 🐼