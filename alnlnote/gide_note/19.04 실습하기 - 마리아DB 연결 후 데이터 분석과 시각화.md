# 19.04 실습하기 - 마리아DB 연결 후 데이터 분석과 시각화

## 📋 목차
1. [기본 환경 설정](#기본-환경-설정)
2. [문제 7-a: 종합적인 데이터 분석](#문제-7-a-종합적인-데이터-분석)
3. [문제 7-b: pivot_table과 시각화](#문제-7-b-pivot_table과-시각화)
4. [문제 7-c: 로그인 시스템 구현](#문제-7-c-로그인-시스템-구현)
5. [통합 실습 코드](#통합-실습-코드)

---

## 기본 환경 설정

### 필수 라이브러리 import
```python
import MySQLdb
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sys
import pickle
import csv

# 한글 폰트 설정
plt.rc('font', family='malgun gothic')      # 한글이 깨질 수 있어서 반드시 지정
plt.rcParams['axes.unicode_minus'] = False  # 음수가 깨질 수 있기 때문에 설정

# 설정 파일 읽기
try:
    with open('./mymaria.dat', 'rb') as obj:
        config = pickle.load(obj)                   # 피클스로 접속정보 불러오기
except Exception as error:
    print('readError! : fail to read myMaria', error)  # 접속정보 불러오기 실패 예외처리
    sys.exit()
```

---

## 문제 7-a: 종합적인 데이터 분석

> **문제**: MariaDB에 저장된 jikwon, buser, gogek 테이블을 이용하여 아래의 문제에 답하시오.

### 1. 사번 이름 부서명 연봉, 직급을 읽어 DataFrame 작성

```python
try:
    # 데이터베이스 연결
    connect = MySQLdb.connect(**config)     # 피클스로 불러온 정보 언패킹(**)
    cursor = connect.cursor()
    
    # SQL 문법을 활용해서 jikwon 테이블에 buser 테이블 이너조인
    sql = """
        SELECT jikwonno, jikwonname, busername, jikwonpay, jikwonjik
        FROM jikwon INNER JOIN buser
        ON jikwon.busernum = buser.buserno
    """
    cursor.execute(sql)
    
    # DataFrame 생성 (칼럼명 한글로 지정)
    myDf = pd.DataFrame(cursor.fetchall(), 
                       columns=['사번', '이름', '부서명', '연봉', '직급'])
    print("=== 사번 이름 부서명 연봉 직급 DataFrame ===")
    print(myDf.head())
```

### 2. DataFrame의 자료를 파일로 저장

```python
    # CSV 파일로 저장 (UTF-8 인코딩으로 한글 문제 해결)
    with open('employee_data.csv', mode='w', encoding='utf-8') as obj:
        writer = csv.writer(obj)
        cursor.execute(sql)  # 커서 재실행
        for r in cursor:
            writer.writerow(r)
    
    # pandas to_csv 메서드로도 저장 가능
    myDf.to_csv('employee_pandas.csv', encoding='utf-8', index=False)
    print("✅ 파일 저장 완료: employee_data.csv, employee_pandas.csv")
```

### 3. 부서명별 연봉의 합, 연봉의 최대/최소값 출력

```python
    print("\n=== 부서명별 연봉 통계 ===")
    
    # 각 부서별로 필터링해서 계산
    departments = ['총무부', '영업부', '전산부', '관리부']
    
    for dept in departments:
        filteredDf = myDf[myDf['부서명'] == dept]   # 부서별 필터링
        total_pay = filteredDf['연봉'].sum()
        min_pay = filteredDf['연봉'].min()
        max_pay = filteredDf['연봉'].max()
        
        print(f'{dept} - 연봉합계: {total_pay:,}, 최소: {min_pay:,}, 최대: {max_pay:,}')
    
    # 또는 groupby를 사용한 간단한 방법
    print("\n=== groupby 활용 ===")
    print("부서별 연봉 합계:")
    print(myDf.groupby('부서명')['연봉'].sum())
    print("\n부서별 연봉 최대값:")
    print(myDf.groupby('부서명')['연봉'].max())
    print("\n부서별 연봉 최소값:")
    print(myDf.groupby('부서명')['연봉'].min())
```

### 4. 부서명, 직급으로 교차 테이블(빈도표) 작성

```python
    print("\n=== 부서명-직급 교차 테이블 ===")
    # crosstab으로 두 변수의 빈도표 생성
    ctab = pd.crosstab(myDf['부서명'], myDf['직급'])
    print(ctab)
```

### 5. 직원별 담당 고객자료 출력

```python
    print("\n=== 직원별 담당 고객자료 ===")
    
    # gogek 테이블에서 고객 정보 가져오기
    sql2 = """
        SELECT gogekno, gogekname, gogektel, gogekdamsano
        FROM gogek
    """
    cursor.execute(sql2)
    myDf2 = pd.DataFrame(cursor.fetchall(), 
                        columns=['고객번호', '고객명', '고객전화', '사번'])
    
    # 직원 정보와 고객 정보를 outer join으로 합치기
    myDf3 = pd.merge(myDf, myDf2, on='사번', how='outer')
    
    # NaN 값을 '담당 고객 X'로 대체
    myDf3['고객명'].fillna('담당 고객 X', inplace=True)
    myDf3['고객번호'].fillna('', inplace=True)
    myDf3['고객전화'].fillna('', inplace=True)
    
    print(myDf3[['이름', '고객번호', '고객명', '고객전화']])
```

### 6. 부서명별 연봉의 평균으로 가로 막대 그래프 작성

```python
    print("\n=== 부서명별 연봉 평균 가로 막대 그래프 ===")
    
    # 부서별 연봉 평균 계산
    moneyData = myDf.groupby(['부서명'])['연봉'].mean()
    
    plt.figure(figsize=(10, 6))
    plt.barh(moneyData.index, moneyData.values)     # 가로 막대그래프
    plt.title('부서명별 연봉의 평균')
    plt.xlabel('평균 연봉 (만원)')
    plt.ylabel('부서명')
    
    # 값 표시
    for i, v in enumerate(moneyData.values):
        plt.text(v, i, f'{v:,.0f}', va='center')
    
    plt.tight_layout()
    plt.show()

except Exception as error:
    print('MariaDB 처리 오류:', error)
finally:
    if 'connect' in locals():
        connect.close()
```

---

## 문제 7-b: pivot_table과 시각화

> **문제**: MariaDB에 저장된 jikwon 테이블을 이용하여 아래의 문제에 답하시오.

### 설정 및 연결

```python
# 설정 정보 (또는 피클 파일 사용)
config = {
    'host': '127.0.0.1',
    'user': 'root',
    'password': 'your_password',
    'database': 'mydb',
    'port': 3306,
    'charset': 'utf8'
}

try:
    conn = MySQLdb.connect(**config)
    cursor = conn.cursor()
    
    # JOIN 쿼리로 데이터 가져오기
    sql = '''
        SELECT jikwonname, busername, jikwonjik, jikwongen, jikwonpay
        FROM jikwon INNER JOIN buser
        ON jikwon.busernum = buser.buserno
    '''
    cursor.execute(sql)
    
    df2 = pd.DataFrame(cursor.fetchall(),
                      columns=['jikwonname', 'busername', 'jikwonjik', 'jikwongen', 'jikwonpay'])
```

### 1. pivot_table을 사용하여 성별 연봉의 평균 출력

```python
    print("=== pivot_table로 성별 연봉 평균 ===")
    
    # pivot_table 사용
    gender_pay_pivot = df2.pivot_table(index='jikwongen', values='jikwonpay', aggfunc='mean')
    print(gender_pay_pivot)
    
    # 또는 직접 계산
    man = df2[df2['jikwongen'] == '남']
    woman = df2[df2['jikwongen'] == '여']
    
    mean_manYpay = round(man['jikwonpay'].mean(), 2)
    mean_womanYpay = round(woman['jikwonpay'].mean(), 2)
    
    print(f'남성 직원 평균 연봉: {mean_manYpay:,}')
    print(f'여성 직원 평균 연봉: {mean_womanYpay:,}')
```

### 2. 성별 연봉의 평균으로 시각화 - 세로 막대 그래프

```python
    print("\n=== 성별 연봉 평균 세로 막대 그래프 ===")
    
    labels = ['남성 직원 평균 연봉', '여성 직원 평균 연봉']
    values = [mean_manYpay, mean_womanYpay]
    
    plt.figure(figsize=(8, 6))
    bars = plt.bar(labels, values, color=['skyblue', 'pink'])
    plt.title('성별 연봉 평균 비교')
    plt.ylabel('연봉 (만원)')
    plt.xticks(rotation=45)
    
    # 막대 위에 값 표시
    for bar, value in zip(bars, values):
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 50,
                f'{value:,.0f}', ha='center')
    
    plt.tight_layout()
    plt.show()
```

### 3. 부서명, 성별로 교차 테이블 작성

```python
    print("\n=== 부서명-성별 교차 테이블 ===")
    
    # crosstab으로 빈도 계산
    ctab2 = pd.crosstab(df2['busername'], df2['jikwongen'], margins=True)
    print(ctab2)
    
    print("\n=== 처음 3개 행 데이터 확인 ===")
    print(df2.head(3))

except Exception as e:
    print('처리 오류:', e)
finally:
    if 'conn' in locals():
        conn.close()
```

---

## 문제 7-c: 로그인 시스템 구현

> **문제**: 키보드로 사번, 직원명을 입력받아 로그인에 성공하면 console에 아래와 같이 출력하시오.  
> **조건**: `try ~ except MySQLdb.OperationalError as e:` 사용

```python
import MySQLdb
import pandas as pd

# 데이터베이스 연결 설정
conn = MySQLdb.connect(
    host='127.0.0.1',
    user='root',
    password='1234',
    database='mydb',
    port=3306,
    charset='utf8'
)

try:    
    cursor = conn.cursor()
    
    # 사용자 입력 받기
    no = int(input('사원번호 입력: '))
    name = input('이름 입력: ')

    # 로그인 확인 쿼리 (보안을 위한 매개변수화 쿼리)
    sql_login = """
        SELECT jikwonno, jikwonname
        FROM jikwon
        WHERE jikwonname = %s AND jikwonno = %s 
    """
    cursor.execute(sql_login, (name, no))
    result = cursor.fetchone()
    
    if result:  # 로그인 성공
        print('🎉 로그인 성공!')
        
        # 전체 직원 정보 조회
        sql_all = """
            SELECT jikwonno, jikwonname, buser.busername, jikwonjik, buser.busertel, jikwongen
            FROM jikwon INNER JOIN buser
            ON jikwon.busernum = buser.buserno
        """
        cursor.execute(sql_all)
        
        # DataFrame으로 변환하여 출력
        df = pd.DataFrame(cursor.fetchall(), columns=[
            '사번', '직원명', '부서명', '직급', '부서전화', '성별'
        ])
        
        print("\n=== 전체 직원 정보 ===")
        print(df.to_string(index=False))  # 인덱스 없이 출력
        print(f'\n👥 인원수: {df["사번"].count()}명')
        
    else:
        print('❌ 로그인 실패! 사번과 이름을 확인해주세요.')

except MySQLdb.OperationalError as e:  # DB접속, 인증, 네트워크 문제
    print(f'❌ 데이터베이스 연결 오류: {e}')
    print('💡 확인사항: 서버 상태, 네트워크, 인증 정보')

except ValueError as e:  # 사번 입력 오류
    print(f'❌ 입력 오류: 사번은 숫자로 입력해주세요. ({e})')

except Exception as e:  # 기타 모든 예외
    print(f'❌ 예상치 못한 오류 발생: {e}')

finally:
    # 리소스 정리
    if 'cursor' in locals():
        cursor.close()
    if 'conn' in locals():
        conn.close()
    print("🔌 데이터베이스 연결 종료")
```

---

## 통합 실습 코드

### 전체 통합 실행 코드

```python
import MySQLdb
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sys
import pickle
import csv

# 한글 폰트 설정
plt.rc('font', family='malgun gothic')
plt.rcParams['axes.unicode_minus'] = False

# 설정 파일 읽기
try:
    with open('./mymaria.dat', 'rb') as obj:
        config = pickle.load(obj)
except Exception as e:
    print("❌ 설정 파일 읽기 오류:", e)
    sys.exit()

try:
    # 데이터베이스 연결
    conn = MySQLdb.connect(**config)
    cursor = conn.cursor()
    
    # 기본 SQL 쿼리
    sql = """
    SELECT jikwonno, jikwonname, busername, jikwonjik, jikwongen, jikwonpay 
    FROM jikwon 
    INNER JOIN buser ON jikwon.busernum = buser.buserno
    """
    
    # =================================================================
    # 문제 7-a: 종합적인 데이터 분석
    # =================================================================
    print("🔍 === 문제 7-a: 종합적인 데이터 분석 ===")
    
    # 1. DataFrame 작성
    cursor.execute(sql)
    df1 = pd.DataFrame(cursor.fetchall(),
                       columns=['번호', '이름', '부서', '직급', '성별', '연봉'])
    print("\n📊 사번 이름 부서명 연봉 직급 DataFrame:")
    print(df1.head(3))
    
    # 2. 파일 저장
    df1.to_csv('jikwon_data.csv', encoding='utf-8', index=False)
    print("💾 파일 저장 완료: jikwon_data.csv")
    
    # 3. 부서명별 연봉 통계
    print("\n💰 부서명별 연봉 통계:")
    print("연봉 합계:")
    print(df1.groupby('부서')['연봉'].sum())
    print("\n연봉 최대값:")
    print(df1.groupby('부서')['연봉'].max())
    print("\n연봉 최소값:")
    print(df1.groupby('부서')['연봉'].min())
    
    # 4. 교차 테이블
    print("\n📋 부서명-직급 교차 테이블:")
    ctab = pd.crosstab(df1['부서'], df1['직급'], margins=True)
    print(ctab)
    
    # 5. 담당 고객 정보 (간소화 버전)
    print(f"\n👥 전체 직원 수: {len(df1)}명")
    
    # 6. 부서명별 연봉 평균 가로 막대 그래프
    plt.figure(figsize=(10, 6))
    dept_avg = df1.groupby('부서')['연봉'].mean()
    plt.barh(dept_avg.index, dept_avg.values)
    plt.title('부서명별 연봉의 평균')
    plt.xlabel('평균 연봉 (만원)')
    plt.show()
    
    # =================================================================
    # 문제 7-b: pivot_table과 시각화
    # =================================================================
    print("\n🔍 === 문제 7-b: pivot_table과 시각화 ===")
    
    # 1. pivot_table로 성별 연봉 평균
    print("\n📊 성별 연봉 평균 (pivot_table):")
    gender_pivot = df1.pivot_table(index='성별', values='연봉', aggfunc='mean')
    print(gender_pivot)
    
    # 2. 성별 연봉 평균 세로 막대 그래프
    plt.figure(figsize=(8, 6))
    gender_pivot.plot(kind='bar', rot=0)
    plt.title('성별 연봉 평균')
    plt.ylabel('연봉 (만원)')
    plt.show()
    
    # 3. 부서명-성별 교차 테이블
    print("\n📋 부서명-성별 교차 테이블:")
    ctab2 = pd.crosstab(df1['부서'], df1['성별'], margins=True)
    print(ctab2)
    
    # =================================================================
    # 문제 7-c: 로그인 시스템 (선택적 실행)
    # =================================================================
    print("\n🔍 === 문제 7-c: 로그인 시스템 ===")
    print("💡 로그인 테스트를 원하시면 아래 주석을 해제하세요.")
    
    """
    # 로그인 시스템 코드 (사용자 입력 필요)
    try:
        jikwonno = input('사번: ')
        jikwonname = input('직원명: ')
        
        sql_login = "SELECT * FROM jikwon WHERE jikwonno=%s AND jikwonname=%s"
        cursor.execute(sql_login, (jikwonno, jikwonname))
        
        if cursor.fetchone():
            print("✅ 로그인 성공!")
            print(df1.to_string(index=False))
            print(f"인원수: {len(df1)} 명")
        else:
            print("❌ 로그인 실패!")
            
    except MySQLdb.OperationalError as e:
        print(f"❌ 데이터베이스 오류: {e}")
    """

except Exception as e:
    print(f"❌ SQL 실행 오류: {e}")

finally:
    if 'conn' in locals():
        conn.close()
    print("🔌 데이터베이스 연결 종료")

print("\n🎉 모든 실습이 완료되었습니다!")
print("💡 각 문제별로 세부 코드를 참고하여 개별 실행해보세요.")
```

---

## 💡 실습 핵심 포인트

### ✅ 강사님이 강조한 중요한 기술들

1. **안전한 DB 연결**
   - pickle로 설정 정보 관리
   - try-except-finally로 예외 처리
   - 리소스 정리 (cursor.close(), conn.close())
   - **강사님**: "열었으면 닫아라! 메모리 누수를 막는 방법이다!"

2. **SQL과 pandas 연동**
   - `pd.read_sql()`: 가장 효율적인 방법
   - `pd.DataFrame(cursor.fetchall())`: 수동 제어
   - JOIN을 활용한 복잡한 쿼리
   - **강사님**: "데이터를 처리하는 사람들에게 SQL은 필수다!"

3. **데이터 분석 기법**
   - `groupby()`: 그룹별 집계
   - `crosstab()`: 교차표/빈도표
   - `pivot_table()`: 피벗 테이블
   - `merge()`: DataFrame 조인
   - **강사님**: "방법이 한 가지만 있는 건 아니다. 여러 가지 방법을 써가지고 만들어 낼 수 있으면 된다!"

4. **시각화 기법**
   - 가로/세로 막대그래프
   - 한글 폰트 설정 (malgun gothic)
   - 값 표시 및 레이블링
   - **강사님**: "웹으로 출력하려면 Django를 사용해야 합니다"

5. **보안 고려사항**
   - 매개변수화 쿼리 (`%s` 사용)
   - SQL 인젝션 방지
   - 설정 정보 분리

### 🎯 강사님의 실무 조언

#### 시험 및 평가 기준
- **강사님**: "문제를 복붙해가지고 내가 직접 돌려본다. 안 돌아가면 0점이야!"
- **중요**: 소스 코드는 반드시 실행 가능해야 함
- 돌아가는데 모양이 이상하면 부분 점수 (50% 정도)

#### 외부 출력의 중요성
- **강사님**: "실무에서 출력할 때는 외부로 출력하는 게 가장 일반적이다"
- 콘솔 출력은 연습용, 실제로는 웹 출력이 목표
- "전 세계 모든 사람들이 통신 가능한 기기에 접근만 한다면 얼마든지 우리가 만든 내용을 볼 수 있다"

#### SQL 문법의 중요성
- **강사님**: "우리 데이터를 처리하는 사람들에게 SQL은 필수다"
- SELECT는 필수, INSERT/UPDATE/DELETE는 상대적으로 덜 중요
- CREATE, ALTER는 거의 안 씀
- 서브쿼리, JOIN은 잘 다뤄야 함

#### 리소스 관리
- **강사님**: "사용이 끝난 객체는 더 이상 메모리상에 존재할 이유가 없다"
- 특히 실무에서는 매우 중요
- cursor.close(), conn.close() 반드시 실행

### 🚀 실무 활용도

이 실습에서 다룬 패턴들은 **실무에서 매일 사용**하는 핵심 기술들입니다:

- **ETL 파이프라인**: DB → DataFrame → 분석 → 리포트
- **대시보드 개발**: 실시간 데이터 조회 및 시각화  
- **사용자 인증 시스템**: 로그인/권한 관리
- **정기 리포트**: 자동화된 분석 및 차트 생성
- **데이터 품질 관리**: 교차표를 통한 데이터 검증

### 📋 다음 단계 로드맵

#### 1. 웹 출력 단계 (Django 연동)
```python
# 강사님 예고: "다음엔 출력 방향을 바꿔서 웹으로"
print("🌐 다음 실습 내용:")
print("- Django 게시판과 DB 연동")
print("- HTML 템플릿으로 데이터 출력")
print("- 동적 차트 생성 (Chart.js)")
print("- 실시간 대시보드 구축")
```

#### 2. 고급 분석 기법
- **통계 분석**: 가설검정, 회귀분석
- **머신러닝**: 예측 모델 구축
- **시계열 분석**: 트렌드 예측
- **텍스트 마이닝**: 자연어 처리

#### 3. 성능 최적화
- **인덱스 활용**: 쿼리 성능 개선
- **배치 처리**: 대용량 데이터 처리
- **캐싱 전략**: 응답 속도 향상
- **비동기 처리**: 동시성 개선

### 🎓 강사님의 마지막 조언

**강사님**: "여러분들이 DB를 잘 다룰 줄 알고 자유롭게 잘 다룰 줄 알아야 데이터를 어디서 수집하든 DB에 넣었다 뺐다를 잘하셔야 된다. 요즘은 프로그래밍 해본 사람이 잘하지."

**핵심 메시지**:
- DB 조작 능력이 데이터 분석의 기본
- 실무에서는 웹 출력이 표준
- 코드는 반드시 실행 가능해야 함
- 리소스 관리가 매우 중요

**축하합니다! 이제 MariaDB와 pandas를 활용한 실무급 데이터 분석 시스템을 구축할 수 있습니다!** 🎯