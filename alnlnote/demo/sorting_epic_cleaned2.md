# 🏆 정렬 대서사시: 완전체 정렬 대전

## 📊 전체 등장인물 소개

| 영웅 | ⏰ 시간복잡도 | 💾 공간복잡도 | 소속 | 역할 | 특징 |
|------|-------------|-------------|------|------|------|
| 🎯 셀렉터 | O(n²) | **O(1)** | 기본 용사군 | 전사 | 착실한 주인공, 메모리 절약형 |
| 🚀 인서터 | O(n²) | **O(1)** | 기본 용사군 | 마법사 | 지혜로운 조언자, 상황 적응력 |
| 🫧 버블러 | O(n²) | **O(1)** | 기본 용사군 | 탱커 | 순수한 열혈, 끈기의 상징 |
| 🌈 **셸리** | **O(n^1.25)** | **O(1)** | **치유 교단** | **힐러** | **점진적 개선의 현자** |
| ⚡ 머저 | O(n log n) | **O(n)** | 용사군 | 마왕 | 분할정복의 제왕, 안정성 |
| 🌪️ **퀵스터** | **O(n log n)** | **O(log n)** | **의문의 용병** | **용병** | **속도와 효율의 균형** |
| 🏹 **히퍼** | **O(n log n)** | **O(1)** | **천공 도시** | **궁수** | **정확무오한 정밀 사격** |
| 🖤 **카운터** | **O(n + k)** | **O(k)** | **마왕군** | **흑주술사** | **범위 제한 조건부 사기** |
| 🔮 **래딕스** | **O(d×(n+k))** | **O(n + k)** | **마왕군** | **대마도사** | **자릿수 분해 조건부 사기** |
| 🎭 **버킷** | **O(n + k)** | **O(n + k)** | **마왕군** | **선동가** | **균등분포 조건부 사기** |
| 🔄 **엑스터널** | **O(n log n)** | **O(M)** | **각성 용사군** | **외부정렬 마스터** | **거대 데이터 전문** |
| 🔄 **리플레이서** | **O(n log M)** | **O(M)** | **각성 용사군** | **대치선택 마스터** | **런 최적화 전문** |
| 🔄 **폴리페이저** | **O(n log n)** | **O(1)** | **각성 용사군** | **다단계합병 마스터** | **테이프 정렬 전문** |

---

## 🌟 제1막: 기본 용사군 vs 고급 전술가들

### 🎯 셀렉터 (Selection Sort) - "완벽주의 전사"
```python
def 셀렉터의_완벽주의_정렬(적들):
    """완벽주의 전사 셀렉터의 확실한 선택 정렬"""
    for i in range(len(적들)):
        최약체_위치 = i
        for j in range(i+1, len(적들)):
            if 적들[j] < 적들[최약체_위치]:
                최약체_위치 = j
        적들[i], 적들[최약체_위치] = 적들[최약체_위치], 적들[i]
    return 적들
```
**⏰ 시간복잡도**: O(n²) **💾 공간복잡도**: O(1)
**🎯 특징**: 메모리 효율적, 안정적이지만 느림

### 🚀 인서터 (Insertion Sort) - "적응의 달인"
```python
def 인서터의_적응형_정렬(적들):
    """적응의 달인 마법사 인서터의 삽입 정렬"""
    for i in range(1, len(적들)):
        현재_적 = 적들[i]
        j = i - 1
        while j >= 0 and 적들[j] > 현재_적:
            적들[j + 1] = 적들[j]
            j -= 1
        적들[j + 1] = 현재_적
    return 적들
```
**⏰ 시간복잡도**: O(n²) **💾 공간복잡도**: O(1)
**🎯 특징**: 부분정렬된 데이터에 효율적

### 🫧 버블러 (Bubble Sort) - "끈질긴 탱커"
```python
def 버블러의_끈질긴_정렬(적들):
    """끈질긴 탱커 버블러의 버블 정렬"""
    n = len(적들)
    for i in range(n):
        for j in range(0, n-i-1):
            if 적들[j] > 적들[j+1]:
                적들[j], 적들[j+1] = 적들[j+1], 적들[j]
    return 적들
```
**⏰ 시간복잡도**: O(n²) **💾 공간복잡도**: O(1)
**🎯 특징**: 교육용, 단순하지만 비효율적

### 🌈 셸리 (Shell Sort) - "점진적 개선의 현자"
```python
def 셸리의_점진적_개선_정렬(적들):
    """점진적 개선의 현자 셸리의 셸 정렬"""
    n = len(적들)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = 적들[i]
            j = i
            while j >= gap and 적들[j-gap] > temp:
                적들[j] = 적들[j-gap]
                j -= gap
            적들[j] = temp
        gap //= 2
    return 적들
```
**⏰ 시간복잡도**: O(n^1.25) **💾 공간복잡도**: O(1)
**🎯 특징**: 삽입정렬의 개선판

### ⚡ 머저 (Merge Sort) - "분할정복의 제왕"
```python
def 머저의_분할정복_정렬(적들):
    """분할정복의 제왕 머저의 병합 정렬"""
    if len(적들) <= 1:
        return 적들
    
    mid = len(적들) // 2
    left = 머저의_분할정복_정렬(적들[:mid])
    right = 머저의_분할정복_정렬(적들[mid:])
    
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
**⏰ 시간복잡도**: O(n log n) **💾 공간복잡도**: O(n)
**🎯 특징**: 안정 정렬, 예측 가능한 성능

### 🌪️ 퀵스터 (Quick Sort) - "스피드 용병"
```python
def 퀵스터의_고속_정렬(적들):
    """스피드 용병 퀵스터의 퀵 정렬"""
    if len(적들) <= 1:
        return 적들
    
    pivot = 적들[len(적들) // 2]
    left = [x for x in 적들 if x < pivot]
    middle = [x for x in 적들 if x == pivot]
    right = [x for x in 적들 if x > pivot]
    
    return 퀵스터의_고속_정렬(left) + middle + 퀵스터의_고속_정렬(right)
```
**⏰ 시간복잡도**: O(n log n) 평균 **💾 공간복잡도**: O(log n)
**🎯 특징**: 평균적으로 가장 빠름

### 🏹 히퍼 (Heap Sort) - "정밀 사격 궁수"
```python
def 히퍼의_정밀_사격_정렬(적들):
    """정밀 사격 궁수 히퍼의 힙 정렬"""
    import heapq
    
    # 최대 힙 구현을 위해 음수로 변환
    heap = [-x for x in 적들]
    heapq.heapify(heap)
    
    result = []
    while heap:
        result.append(-heapq.heappop(heap))
    
    return result
```
**⏰ 시간복잡도**: O(n log n) **💾 공간복잡도**: O(1)
**🎯 특징**: 메모리 효율적, 항상 O(n log n)

---

## 🔥 제2막: 마왕군의 침입

### 🖤 카운터 (Counting Sort) - "범위 제한의 흑주술사"
```python
def 카운터의_사악한_범위조작술(제한된_희생양들, 최대값):
    """흑주술사 카운터의 데이터 범위 악용 흑마법"""
    
    # 사악한 카운팅 테이블 생성
    악마의_카운터 = [0] * (최대값 + 1)
    
    # 희생양들의 영혼을 수집 (카운팅)
    for 희생양 in 제한된_희생양들:
        악마의_카운터[희생양] += 1
    
    # 사악한 누적 조작
    for i in range(1, len(악마의_카운터)):
        악마의_카운터[i] += 악마의_카운터[i-1]
    
    # 강제 배치
    조작된_결과 = [0] * len(제한된_희생양들)
    for 희생양 in reversed(제한된_희생양들):
        감옥_위치 = 악마의_카운터[희생양] - 1
        조작된_결과[감옥_위치] = 희생양
        악마의_카운터[희생양] -= 1
    
    return 조작된_결과
```
**⏰ 시간복잡도**: O(n + k) **💾 공간복잡도**: O(k)
**😈 조건**: 범위가 제한적이어야 함

### 🔮 래딕스 (Radix Sort) - "자릿수 분해의 대마도사"
```python
def 래딕스의_사악한_자릿수_분해술(거대한_희생양들):
    """대마도사 래딕스의 자릿수 분해 혼란술"""
    
    최대값 = max(거대한_희생양들)
    자릿수 = len(str(최대값))
    현재_희생양들 = 거대한_희생양들.copy()
    
    # 각 자릿수별로 분해하여 조작
    for 현재자릿수 in range(자릿수):
        현재_희생양들 = 자릿수별_흑주술(현재_희생양들, 현재자릿수)
    
    return 현재_희생양들

def 자릿수별_흑주술(희생양들, 자릿수_위치):
    """특정 자릿수에 대해 흑주술 적용"""
    악마의_카운터 = [0] * 10  # 0~9 숫자
    
    # 해당 자릿수 추출해서 영혼 수집
    for 숫자 in 희생양들:
        자릿수값 = (숫자 // (10 ** 자릿수_위치)) % 10
        악마의_카운터[자릿수값] += 1
    
    # 누적 조작
    for i in range(1, 10):
        악마의_카운터[i] += 악마의_카운터[i-1]
    
    # 강제 재배치
    조작된_결과 = [0] * len(희생양들)
    for 숫자 in reversed(희생양들):
        자릿수값 = (숫자 // (10 ** 자릿수_위치)) % 10
        감옥_위치 = 악마의_카운터[자릿수값] - 1
        조작된_결과[감옥_위치] = 숫자
        악마의_카운터[자릿수값] -= 1
    
    return 조작된_결과
```
**⏰ 시간복잡도**: O(d × (n + k)) **💾 공간복잡도**: O(n + k)
**😈 조건**: 자릿수가 존재하는 데이터여야 함

### 🎭 버킷 (Bucket Sort) - "분할정복의 선동가"
```python
def 버킷의_사악한_분할정복술(균등분포_희생양들, 분할_구역수=None):
    """선동가 버킷의 영토 분할 각개격파 전술"""
    
    if 분할_구역수 is None:
        분할_구역수 = len(균등분포_희생양들)
    
    # 사악한 감옥 구역들 준비
    감옥_구역들 = [[] for _ in range(분할_구역수)]
    최소값 = min(균등분포_희생양들)
    최대값 = max(균등분포_희생양들)
    영토_범위 = 최대값 - 최소값
    
    # 희생양들을 감옥 구역별로 강제 분배
    for 희생양 in 균등분포_희생양들:
        if 희생양 == 최대값:
            감옥_번호 = 분할_구역수 - 1
        else:
            감옥_번호 = int((희생양 - 최소값) / 영토_범위 * 분할_구역수)
        감옥_구역들[감옥_번호].append(희생양)
    
    # 각 감옥 내에서 개별 지배 (정렬)
    for i, 감옥 in enumerate(감옥_구역들):
        if 감옥:
            감옥_구역들[i] = sorted(감옥)
    
    # 모든 감옥을 하나의 제국으로 통합
    사악한_제국 = []
    for 감옥 in 감옥_구역들:
        if 감옥:
            사악한_제국.extend(감옥)
    
    return 사악한_제국
```
**⏰ 시간복잡도**: O(n + k) 평균, O(n²) 최악 **💾 공간복잡도**: O(n + k)
**😈 조건**: 균등분포여야 최대 효과

---

## ⚔️ 제3막: 용사군의 극적 반격

### 💥 마왕군 약점 공격

#### 🎯 셀렉터의 "범위 무한대 공격"
```python
def 셀렉터의_범위_파괴_공격():
    """카운터의 약점을 찌르는 범위 무한대 공격"""
    무한대_범위_데이터 = [1, 1000000000, 5, 999999999, 3]
    # 카운터: 10억 크기 배열 필요 → 메모리 부족!
    # 셀렉터: O(1) 공간으로 여유롭게 처리
    return sorted(무한대_범위_데이터, key=lambda x: x)
```

#### 🌪️ 퀵스터의 "자릿수 없음 공격"
```python
def 퀵스터의_자릿수_파괴_공격():
    """래딕스의 약점을 찌르는 혼합 타입 공격"""
    자릿수_없는_데이터 = [3.14, "hello", 42, "apple", 1.41, "zebra"]
    # 래딕스: 자릿수 처리 복잡 → 혼란
    # 퀵스터: 비교 가능하면 모든 타입 OK
    return sorted(자릿수_없는_데이터, key=str)
```

#### ⚡ 머저의 "불균등 분포 공격"
```python
def 머저의_분포_파괴_공격():
    """버킷의 약점을 찌르는 불균등 분포 공격"""
    불균등_데이터 = [0.001, 0.002, 0.003, 0.004, 0.005]
    # 버킷: 한 구역에 몰림 → O(n²) 퇴화
    # 머저: 어떤 분포든 항상 O(n log n)
    return 머저의_분할정복_정렬(불균등_데이터)
```

### 📊 현실적 통계 공격
```
🔥 마왕군 조건 만족률:
- 제한된 범위 데이터: 5%
- 완벽한 자릿수 데이터: 10%
- 균등분포 데이터: 3%
- 총합: 18%

⚔️ 용사군 범용 처리율:
- 일반적인 혼합 데이터: 82%
- 어떤 조건에서도 안정적 처리 가능

🏆 결론: 조건부 사기 < 범용적 신뢰성
```

---

## 🌟 제4막: 각성 용사군의 등장

### 🔄 엑스터널 (External Sort) - "디스크의 마스터"
```python
def 엑스터널의_거대데이터_정렬(거대한_파일, 메모리_제한=1000):
    """디스크 마스터 엑스터널의 외부 정렬 기법"""
    
    if len(거대한_파일) <= 메모리_제한:
        return sorted(거대한_파일)
    
    # 1단계: 청크로 나누어 정렬된 런 생성
    런_파일들 = []
    for i in range(0, len(거대한_파일), 메모리_제한):
        청크 = 거대한_파일[i:i+메모리_제한]
        정렬된_청크 = sorted(청크)
        런_파일들.append(정렬된_청크)
    
    # 2단계: K-way 머지로 런들 합병
    return k방향_머지(런_파일들)

def k방향_머지(런들):
    """여러 정렬된 런을 하나로 합병"""
    import heapq
    
    런_상태 = [(런[0], 0, 런_인덱스) for 런_인덱스, 런 in enumerate(런들) if 런]
    heapq.heapify(런_상태)
    
    결과 = []
    while 런_상태:
        값, 위치, 런_인덱스 = heapq.heappop(런_상태)
        결과.append(값)
        
        if 위치 + 1 < len(런들[런_인덱스]):
            다음_값 = 런들[런_인덱스][위치 + 1]
            heapq.heappush(런_상태, (다음_값, 위치 + 1, 런_인덱스))
    
    return 결과
```
**⏰ 시간복잡도**: O(n log n) **💾 공간복잡도**: O(M)
**🎯 특징**: 메모리보다 큰 데이터도 정렬 가능

### 🔄 리플레이서 (Replacement Selection) - "적응의 신"
```python
def 리플레이서의_대치선택_마법(데이터_스트림, 메모리_크기=5):
    """적응의 신 리플레이서의 대치 선택 런 생성"""
    
    import heapq
    
    스트림_인덱스 = 0
    런들 = []
    
    # 초기 메모리 히프 구성
    메모리_히프 = []
    for _ in range(min(메모리_크기, len(데이터_스트림))):
        heapq.heappush(메모리_히프, 데이터_스트림[스트림_인덱스])
        스트림_인덱스 += 1
    
    런_번호 = 0
    
    while 메모리_히프 or 스트림_인덱스 < len(데이터_스트림):
        현재_런 = []
        동결된_값들 = []
        마지막_출력값 = -1
        
        while 메모리_히프:
            최소값 = heapq.heappop(메모리_히프)
            
            if 최소값 >= 마지막_출력값:
                현재_런.append(최소값)
                마지막_출력값 = 최소값
                
                if 스트림_인덱스 < len(데이터_스트림):
                    새값 = 데이터_스트림[스트림_인덱스]
                    스트림_인덱스 += 1
                    
                    if 새값 >= 마지막_출력값:
                        heapq.heappush(메모리_히프, 새값)
                    else:
                        동결된_값들.append(새값)
            else:
                동결된_값들.append(최소값)
        
        런들.append(현재_런)
        
        if 동결된_값들:
            메모리_히프 = 동결된_값들.copy()
            heapq.heapify(메모리_히프)
        
        런_번호 += 1
        if 런_번호 > len(데이터_스트림):
            break
    
    return 런들
```
**⏰ 시간복잡도**: O(n log M) **💾 공간복잡도**: O(M)
**🎯 특징**: 메모리 크기보다 평균 2배 긴 런 생성 가능

### 🔄 폴리페이저 (Polyphase Merge) - "끈질긴 다단계 합병"
```python
def 폴리페이저의_다단계_합병(런들_리스트, 테이프_수=3):
    """끈질긴 폴리페이저의 다단계 합병 전술"""
    
    # 테이프들 초기화 (마지막 테이프는 출력용)
    테이프들 = [[] for _ in range(테이프_수)]
    입력_테이프들 = 테이프들[:-1]
    출력_테이프 = 테이프들[-1]
    
    # 런들을 입력 테이프들에 분배
    for i, 런 in enumerate(런들_리스트):
        테이프_번호 = i % len(입력_테이프들)
        입력_테이프들[테이프_번호].append(런)
    
    단계 = 0
    
    # 모든 런이 하나로 합쳐질 때까지 반복
    while sum(len(테이프) for 테이프 in 입력_테이프들) > 1:
        단계 += 1
        
        # 각 테이프에서 하나씩 런을 가져와 합병
        while any(테이프 for 테이프 in 입력_테이프들):
            합병할_런들 = []
            
            for 테이프 in 입력_테이프들:
                if 테이프:
                    합병할_런들.append(테이프.pop(0))
            
            if 합병할_런들:
                합병된_런 = k방향_런_합병(합병할_런들)
                출력_테이프.append(합병된_런)
        
        # 테이프 순환
        if len(출력_테이프) > 1:
            새로운_런들 = 출력_테이프.copy()
            출력_테이프.clear()
            
            for 테이프 in 입력_테이프들:
                테이프.clear()
            
            for i, 런 in enumerate(새로운_런들):
                테이프_번호 = i % len(입력_테이프들)
                입력_테이프들[테이프_번호].append(런)
    
    # 최종 결과 반환
    if 출력_테이프:
        return 출력_테이프[0]
    else:
        for 테이프 in 입력_테이프들:
            if 테이프:
                return 테이프[0]

def k방향_런_합병(런들):
    """여러 정렬된 런을 하나로 합병"""
    import heapq
    
    힙 = []
    런_포인터들 = [0] * len(런들)
    
    for i, 런 in enumerate(런들):
        if 런:
            heapq.heappush(힙, (런[0], i))
    
    결과 = []
    
    while 힙:
        값, 런_인덱스 = heapq.heappop(힙)
        결과.append(값)
        
        런_포인터들[런_인덱스] += 1
        if 런_포인터들[런_인덱스] < len(런들[런_인덱스]):
            다음_값 = 런들[런_인덱스][런_포인터들[런_인덱스]]
            heapq.heappush(힙, (다음_값, 런_인덱스))
    
    return 결과
```
**⏰ 시간복잡도**: O(n log n) **💾 공간복잡도**: O(1)
**🎯 특징**: 테이프 기반 외부 정렬, 최소 메모리

---

## 🏆 최종 결전 시나리오

### 📱 시나리오 1: 모바일 게임 (메모리 512MB)
```
🎮 상황: 플레이어 점수 정렬 (10만 명)

🏆 1순위: 🏹 히퍼 (O(n log n) + O(1) 공간)
🥈 2순위: 🌪️ 퀵스터 (평균 최고 속도)
🥉 3순위: 🌈 셸리 (메모리 절약 + 개선 성능)

❌ 부적합: 마왕군 (점수 범위 제한 없음)
❌ 부적합: 각성군 (메모리에 충분히 들어감)
```

### 