# 13. 판다스 연습문제 완전 정리

> **강의 출처**: 데이터 분석 기초 - Pandas DataFrame 연습문제  
> **주제**: DataFrame 생성, 조작, 병합, 그룹화, 피봇테이블  
> **난이도**: ⭐⭐⭐ (중급)

---

## 🎯 학습 목표

- DataFrame의 다양한 생성 방법 익히기
- 인덱싱과 슬라이싱 마스터하기
- 데이터 병합(merge)과 연결(concat) 이해하기
- 그룹화와 피봇테이블 활용법 학습하기

---

## 📚 기본 환경 설정

```python
import pandas as pd
import numpy as np
from pandas import Series, DataFrame
import random

# 재현가능한 결과를 위한 시드 설정
np.random.seed(42)
```

---

## 📋 문제 1: 표준정규분포 DataFrame

### 문제 설명
표준정규분포를 따르는 9×4 형태의 DataFrame을 생성하고 기본 조작을 수행하시오.

### 1-a) DataFrame 생성
```python
print("=" * 50)
print("문제 1: 표준정규분포 DataFrame 기본 조작")
print("=" * 50)

# 표준정규분포를 따르는 9행 4열 DataFrame 생성
df1 = DataFrame(np.random.randn(9, 4))
print("a) 9×4 DataFrame 생성:")
print(df1)
```

**💡 해설**: 
- `np.random.randn(9, 4)`: 평균=0, 표준편차=1인 정규분포에서 36개 값 생성
- `DataFrame()`: 2차원 numpy 배열을 DataFrame으로 변환
- 기본 컬럼명: 0, 1, 2, 3 / 기본 인덱스: 0~8

### 1-b) 컬럼명 지정
```python
# 컬럼명을 No1, No2, No3, No4로 변경
df1.columns = ['No1', 'No2', 'No3', 'No4']
print("\nb) 컬럼명 지정 후:")
print(df1)
```

**💡 해설**: 
- `df.columns`: DataFrame의 컬럼명을 변경하는 속성
- 리스트로 새로운 컬럼명들을 1:1 대응하여 할당

### 1-c) 평균 계산
```python
# 각 컬럼의 평균 구하기 (axis=0: 행 방향으로 계산)
print("\nc) 각 컬럼의 평균:")
print(df1.mean(axis=0))
```

**💡 해설**: 
- `mean(axis=0)`: 각 컬럼별 평균 계산
- `axis=0`: 행 방향(↓)으로 계산 (컬럼별 결과)
- `axis=1`: 열 방향(→)으로 계산 (행별 결과)

---

## 📋 문제 2: 기본 DataFrame 조작

### 문제 설명
간단한 DataFrame을 만들고 다양한 인덱싱 및 연산을 수행하시오.

### 2-a) DataFrame 생성
```python
print("\n" + "=" * 50)
print("문제 2: 기본 DataFrame 조작")
print("=" * 50)

# 딕셔너리를 이용한 DataFrame 생성
data2 = {'numbers': [10, 20, 30, 40]}
index2 = ['a', 'b', 'c', 'd']
df2 = DataFrame(data2, index=index2)
print("a) DataFrame 생성:")
print(df2)
```

**💡 해설**: 
- 딕셔너리의 키가 컬럼명이 됨
- `index` 파라미터로 행 인덱스 지정

### 2-b) 단일 행 선택
```python
# c 행의 값 가져오기
print("\nb) c 행의 값:")
print(df2.loc['c'])
print("타입:", type(df2.loc['c']))  # pandas.core.series.Series
```

**💡 해설**: 
- `loc['c']`: 라벨 기반 인덱싱으로 'c' 행 선택
- 결과는 Series 객체로 반환

### 2-c) 다중 행 선택
```python
# a, d 행들의 값 가져오기
print("\nc) a, d 행들의 값:")
print(df2.loc[['a', 'd']])
print("타입:", type(df2.loc[['a', 'd']]))  # pandas.core.frame.DataFrame
```

**💡 해설**: 
- `loc[['a', 'd']]`: 리스트를 사용한 다중 행 선택
- 결과는 DataFrame 객체로 반환

### 2-d) 컬럼 집계
```python
# numbers 컬럼의 합 구하기
print("\nd) numbers의 합:")
total = df2['numbers'].sum()
print(f"합계: {total}")
print("합계 검증:", 10+20+30+40)
```

**💡 해설**: 
- `df['컬럼명']`: 특정 컬럼을 Series로 추출
- `.sum()`: Series의 모든 값을 더하는 집계 함수

### 2-e) 원소별 연산
```python
# numbers의 값들을 각각 제곱
print("\ne) numbers 제곱 연산:")
df2['numbers_squared'] = df2['numbers'] ** 2
print(df2)
```

**💡 해설**: 
- `**` 연산자: 제곱 연산
- Series에 연산을 적용하면 모든 원소에 브로드캐스팅됨

### 2-f) 새 컬럼 추가
```python
# float 컬럼 추가
df2['floats'] = [1.5, 2.5, 3.5, 4.5]
print("\nf) float 컬럼 추가:")
print(df2)
```

### 2-g) Series를 이용한 컬럼 추가
```python
# Series 클래스를 사용한 names 컬럼 추가
names_series = Series(['오정', '팔계', '오공', '길동'], 
                     index=['a', 'b', 'c', 'd'])
df2['names'] = names_series
print("\ng) names 컬럼 추가 (Series 사용):")
print(df2)
```

**💡 해설**: 
- Series 객체로 컬럼을 추가하면 인덱스가 일치하는 위치에 값이 할당됨
- 일치하지 않는 인덱스는 NaN으로 처리

---

## 📋 문제 3: 랜덤 정수형 DataFrame

### 문제 설명
난수를 이용한 DataFrame을 생성하고 고급 조작을 수행하시오.

### 3-1) 랜덤 정수형 DataFrame 생성
```python
print("\n" + "=" * 50)
print("문제 3: 랜덤 정수형 DataFrame 고급 조작")
print("=" * 50)

# 5×3 형태의 랜덤 정수형 DataFrame 생성 (1~20 범위)
df3 = DataFrame(np.random.randint(1, 21, size=(5, 3)))
print("1) 5×3 랜덤 정수형 DataFrame:")
print(df3)
print("형태:", df3.shape)
```

**💡 해설**: 
- `np.random.randint(1, 21, size=(5, 3))`: 1~20 범위의 정수 난수
- `size=(5, 3)`: 5행 3열 배열 생성

### 3-2) 컬럼명과 인덱스 설정
```python
# 컬럼명과 행 인덱스 설정
df3.columns = ['A', 'B', 'C']
df3.index = ['r1', 'r2', 'r3', 'r4', 'r5']
print("\n2) 컬럼명과 인덱스 설정:")
print(df3)
```

### 3-3) 불린 인덱싱
```python
# A 컬럼의 값이 10보다 큰 행만 출력
print("\n3) A 컬럼의 값이 10보다 큰 행:")
condition = df3['A'] > 10
print("조건:", condition)
print("결과:")
print(df3[condition])
```

**💡 해설**: 
- `df3['A'] > 10`: 불린 Series 생성 (True/False)
- `df3[condition]`: 조건이 True인 행들만 선택

### 3-4) 컬럼 간 연산으로 새 컬럼 생성
```python
# D 컬럼 추가 (A + B)
df3['D'] = df3['A'] + df3['B']
print("\n4) D 컬럼 추가 (A + B):")
print(df3)
```

**💡 해설**: 
- 두 Series 간의 덧셈은 같은 인덱스끼리 원소별로 계산됨

### 3-5) 행 제거 (원본 수정)
```python
# r3 행 제거 (원본 변경)
df3.drop('r3', inplace=True)
print("\n5) r3 행 제거 후:")
print(df3)
```

**💡 해설**: 
- `drop()`: 행 또는 열 제거 함수
- `inplace=True`: 원본 DataFrame을 직접 수정
- `inplace=False` (기본값): 새로운 DataFrame 반환, 원본 보존

### 3-6) 새 행 추가
```python
# r6 행 추가
df3.loc['r6'] = [15, 10, 2, 25]
print("\n6) r6 행 추가:")
print(df3)
```

**💡 해설**: 
- `loc['새인덱스']`: 존재하지 않는 인덱스에 값을 할당하면 새 행이 추가됨
- 리스트의 값들이 각 컬럼에 순서대로 할당

---

## 📋 문제 4: 실무 활용 - 재고 관리 시스템

### 문제 설명
딕셔너리 데이터로 재고 관리 DataFrame을 만들고 실무적인 조작을 수행하시오.

### 4-1) 딕셔너리로 DataFrame 생성
```python
print("\n" + "=" * 50)
print("문제 4: 실무 활용 - 재고 관리 시스템")
print("=" * 50)

# 재고 정보 딕셔너리
data = {
    'product': ['Mouse', 'Keyboard', 'Monitor', 'Laptop'],
    'price':   [12000,   25000,     150000,    900000],
    'stock':   [10,      5,         2,         3]
}

df4 = DataFrame(data, index=['p1', 'p2', 'p3', 'p4'])
print("1) 재고 정보 DataFrame:")
print(df4)
```

### 4-2) 계산된 컬럼 추가
```python
# total 컬럼 추가 (price × stock)
df4['total'] = df4['price'] * df4['stock']
print("\n2) total 컬럼 추가 (price × stock):")
print(df4)
```

**💡 해설**: 
- 두 컬럼 간의 곱셈으로 새로운 컬럼 생성
- 각 행별로 가격 × 재고 = 총가격 계산

### 4-3) 컬럼명 한글화
```python
# 컬럼명을 한글로 변경
df4.rename(columns={
    'product': '상품명',
    'price': '가격',
    'stock': '재고',
    'total': '총가격'
}, inplace=True)
print("\n3) 컬럼명 한글 변경:")
print(df4)
```

**💡 해설**: 
- `rename()`: 컬럼명 또는 인덱스명 변경 함수
- `columns` 파라미터: 딕셔너리로 {기존명: 새이름} 매핑

### 4-4) 조건부 데이터 필터링
```python
# 재고가 3 이하인 행 추출
print("\n4) 재고가 3 이하인 행:")
low_stock = df4[df4['재고'] <= 3]
print(low_stock)
print(f"\n재고 부족 상품 수: {len(low_stock)}개")
```

### 4-5) 인덱싱 방법 비교
```python
# p2 행 추출하는 두 가지 방법
print("\n5) p2 행 추출 방법 비교:")

print("방법 1 - loc (라벨 기반):")
print(df4.loc['p2'])

print("\n방법 2 - iloc (위치 기반):")
print(df4.iloc[1])  # p2는 두 번째 행 (인덱스 1)
```

**💡 해설**: 
- `loc[]`: 라벨(이름) 기반 인덱싱
- `iloc[]`: 정수 위치 기반 인덱싱
- p1(0), p2(1), p3(2), p4(3) 순서

### 4-6) 원본 보존 삭제
```python
# p3 행 삭제 (원본 변경 없이)
df4_without_p3 = df4.drop('p3')
print("\n6) p3 행 삭제 (원본 보존):")
print("삭제 결과:")
print(df4_without_p3)

print("\n원본 확인 (변경되지 않음):")
print(df4)
```

**💡 해설**: 
- `inplace=False` (기본값): 원본은 보존하고 새로운 DataFrame 반환
- 데이터 안전성을 위해 중요한 개념

### 4-7) 동적 행 추가
```python
# p5 행 추가 (USB메모리)
new_product_data = ['USB메모리', 15000, 10, 15000 * 10]
df4.loc['p5'] = new_product_data
print("\n7) p5 행 추가 (USB메모리):")
print(df4)

# 총 재고 가치 계산
total_value = df4['총가격'].sum()
print(f"\n전체 재고 총 가치: {total_value:,}원")
```

---

## 📋 고급 기능: 데이터 병합과 그룹화

### 데이터 병합 (Merge)

```python
print("\n" + "=" * 50)
print("고급 기능: 데이터 병합 (Merge)")
print("=" * 50)

# 두 개의 DataFrame 생성
df_left = DataFrame({
    'key': ['A', 'B', 'C'],
    'data1': [1, 2, 3]
})

df_right = DataFrame({
    'key': ['A', 'B', 'D'],
    'data2': [4, 5, 6]
})

print("Left DataFrame:")
print(df_left)
print("\nRight DataFrame:")
print(df_right)

# 다양한 조인 방법
print("\n1) Inner Join (교집합):")
inner_merged = pd.merge(df_left, df_right, on='key', how='inner')
print(inner_merged)

print("\n2) Outer Join (합집합):")
outer_merged = pd.merge(df_left, df_right, on='key', how='outer')
print(outer_merged)

print("\n3) Left Join:")
left_merged = pd.merge(df_left, df_right, on='key', how='left')
print(left_merged)
```

### 피봇 테이블 (Pivot Table)

```python
print("\n" + "=" * 50)
print("고급 기능: 피봇 테이블")
print("=" * 50)

# 샘플 데이터 생성
sales_data = DataFrame({
    'city': ['강남', '강북', '강남', '강북', '강남', '강북'],
    'year': [2020, 2020, 2021, 2021, 2022, 2022],
    'population': [3.1, 2.8, 3.3, 2.9, 3.5, 3.0],
    'sales': [100, 80, 110, 85, 120, 90]
})

print("원본 데이터:")
print(sales_data)

# 피봇 테이블 생성
pivot_table = sales_data.pivot_table(
    index='city',           # 행 인덱스
    columns='year',         # 열
    values='population',    # 값
    aggfunc='mean'         # 집계 함수
)

print("\n피봇 테이블 (도시별/연도별 인구):")
print(pivot_table)
```

### 그룹화 연산 (GroupBy)

```python
print("\n" + "=" * 50)
print("고급 기능: 그룹화 연산")
print("=" * 50)

# 도시별 그룹화
city_groups = sales_data.groupby('city')

print("1) 도시별 평균:")
print(city_groups.mean())

print("\n2) 도시별 합계:")
print(city_groups.sum())

print("\n3) 도시별 다중 통계:")
print(city_groups.agg(['mean', 'sum', 'count']))
```

---

## 🔧 실무 팁 모음

### 1. 데이터 품질 체크
```python
print("\n" + "=" * 50)
print("실무 팁: 데이터 품질 체크")
print("=" * 50)

# DataFrame 기본 정보
print("1) DataFrame 기본 정보:")
print(f"- 형태: {df4.shape}")
print(f"- 컬럼 수: {len(df4.columns)}")
print(f"- 행 수: {len(df4)}")

print("\n2) 결측값 확인:")
print(df4.isnull().sum())

print("\n3) 데이터 타입 확인:")
print(df4.dtypes)

print("\n4) 기술통계량:")
print(df4.describe())
```

### 2. 메모리 사용량 최적화
```python
print("\n메모리 사용량:")
print(df4.info(memory_usage='deep'))
```

### 3. 조건부 데이터 처리
```python
# 복합 조건 처리
print("\n복합 조건 (가격 > 50000 AND 재고 < 5):")
complex_condition = (df4['가격'] > 50000) & (df4['재고'] < 5)
print(df4[complex_condition])

# 조건에 따른 값 변경
df4_copy = df4.copy()
df4_copy.loc[df4_copy['재고'] < 5, '재고'] = 999
print("\n재고 < 5인 항목을 999로 변경:")
print(df4_copy)
```

---

## 📊 성능 최적화 가이드

### 1. 벡터화 연산 활용
```python
# ❌ 느린 방법: 반복문
result = []
for idx, row in df4.iterrows():
    result.append(row['가격'] * row['재고'])

# ✅ 빠른 방법: 벡터화
result = df4['가격'] * df4['재고']
```

### 2. 메모리 효율적인 데이터 타입
```python
# 정수 컬럼의 데이터 타입 최적화
df4['재고'] = df4['재고'].astype('int16')  # int64 → int16
df4['가격'] = df4['가격'].astype('int32')  # int64 → int32
```

### 3. 인덱싱 성능
```python
import time

# 성능 비교: loc vs iloc
start_time = time.time()
for _ in range(1000):
    _ = df4.loc['p2']
loc_time = time.time() - start_time

start_time = time.time()
for _ in range(1000):
    _ = df4.iloc[1]
iloc_time = time.time() - start_time

print(f"loc 시간: {loc_time:.4f}초")
print(f"iloc 시간: {iloc_time:.4f}초")
print(f"성능 차이: {loc_time/iloc_time:.2f}배")
```

---

## 🎯 학습 체크포인트

### 초급 레벨 ✅
- [ ] DataFrame 생성 (딕셔너리, numpy 배열)
- [ ] 기본 인덱싱 (loc, iloc)
- [ ] 컬럼 추가/삭제
- [ ] 불린 인덱싱
- [ ] 기본 통계 함수

### 중급 레벨 ✅
- [ ] 데이터 병합 (merge, concat)
- [ ] 그룹화 연산 (groupby)
- [ ] 피봇 테이블
- [ ] 조건부 데이터 처리
- [ ] 데이터 타입 변환

### 고급 레벨 🚀
- [ ] 대용량 데이터 처리
- [ ] 메모리 최적화
- [ ] 성능 튜닝
- [ ] 복잡한 데이터 변환
- [ ] 시계열 데이터 처리

---

## 🔗 추천 학습 자료

### 공식 문서
- [Pandas Documentation](https://pandas.pydata.org/docs/)
- [10 minutes to pandas](https://pandas.pydata.org/docs/user_guide/10min.html)

### 실습 플랫폼
- [Kaggle Learn - Pandas](https://www.kaggle.com/learn/pandas)
- [DataCamp - Pandas](https://www.datacamp.com/courses/data-manipulation-with-python)

### 도서
- "Python for Data Analysis" (Wes McKinney)
- "Effective Pandas" (Matt Harrison)

---

## ⚡ 핵심 요약

### 반드시 기억할 개념들
1. **DataFrame vs Series**: 2차원 vs 1차원
2. **loc vs iloc**: 라벨 기반 vs 위치 기반
3. **inplace 파라미터**: 원본 수정 vs 새 객체 반환
4. **불린 인덱싱**: 조건을 이용한 데이터 필터링
5. **벡터화 연산**: 반복문 대신 판다스 함수 활용

### 실무에서 자주 사용하는 패턴들
```python
# 1. 조건부 필터링
filtered_data = df[df['column'] > threshold]

# 2. 그룹별 집계
grouped_stats = df.groupby('category').agg({'value': ['mean', 'sum']})

# 3. 결측값 처리
df.fillna(df.mean(), inplace=True)

# 4. 데이터 타입 변환
df['column'] = df['column'].astype('category')

# 5. 다중 조건
complex_filter = df[(df['A'] > 10) & (df['B'] < 5)]
```

---

**🎉 축하합니다! 판다스 연습문제를 완주하셨습니다.**

이제 실제 데이터셋으로 분석 프로젝트를 시작할 준비가 되었습니다. 
계속해서 연습하고 실전에 적용해보세요! 💪