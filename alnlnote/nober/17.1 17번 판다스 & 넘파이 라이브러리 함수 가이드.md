# 판다스 & 넘파이 라이브러리 함수가이드

## 📋 개요

17번 예제에서 사용된 모든 pandas와 numpy 함수들을 카테고리별로 정리하고, 실제 사용 예제와 함께 상세히 설명합니다.

---

## 🐼 Pandas 함수 완전 가이드

### 1. 데이터 읽기/쓰기 (I/O)

#### `pd.read_csv()`
```python
# 기본 사용법
df = pd.read_csv('파일명.csv')

# 고급 옵션
df = pd.read_csv('파일명.csv', 
                dtype=str,           # 모든 컬럼을 문자열로
                index_col=False,     # 인덱스 컬럼 사용 안함
                encoding='utf-8-sig', # 한글 인코딩
                na_values=['N/A', '-']) # 결측값 지정

# 실제 예제
df = pd.read_csv('네이버코스피.csv', dtype=str, index_col=False)
print(f"데이터 형태: {df.shape}")  # (행수, 열수)
```

#### `.to_csv()`, `.to_excel()`
```python
# CSV 저장
df.to_csv('저장파일.csv', 
          index=False,           # 인덱스 제외
          encoding='utf-8-sig')  # 한글 지원

# Excel 저장 (단일 시트)
df.to_excel('보고서.xlsx', index=False, sheet_name='데이터')

# Excel 저장 (다중 시트)
with pd.ExcelWriter('다중시트.xlsx', engine='openpyxl') as writer:
    df.to_excel(writer, sheet_name='전체데이터', index=False)
    df_top10.to_excel(writer, sheet_name='상위10개', index=False)
```

---

### 2. 데이터 구조 확인

#### `.shape`, `.head()`, `.tail()`, `.info()`
```python
# 데이터 형태 확인
print(f"데이터 크기: {df.shape}")        # (행수, 열수)
print(f"행 수: {len(df)}")              # 총 행 수
print(f"열 수: {len(df.columns)}")      # 총 열 수

# 데이터 미리보기
df.head()      # 처음 5개 행
df.head(3)     # 처음 3개 행
df.tail()      # 마지막 5개 행

# 데이터 정보 요약
df.info()      # 컬럼명, 데이터 타입, 결측값 정보
```

#### `.describe()`, `.columns`
```python
# 통계 요약 (숫자형 컬럼만)
print(df.describe())
"""
결과 예시:
       현재가          시가총액
count  1500.00        1450.00
mean   45230.50      125000000
std    32100.25      89000000
min    1000.00       50000
25%    15000.00      5000000
50%    35000.00      45000000
75%    65000.00      150000000
max    950000.00     500000000000
"""

# 컬럼명 확인
print(df.columns.tolist())
# ['종목명', '현재가', '전일비', '등락률', ...]
```

---

### 3. 결측값(NA) 처리

#### `.isnull()`, `.notnull()`, `.dropna()`
```python
# 결측값 확인
print(df.isnull().sum())    # 컬럼별 결측값 개수
print(df.isnull().any())    # 컬럼별 결측값 존재 여부

# 결측값 제거
df_clean = df.dropna()                    # 결측값이 있는 행 모두 제거
df_clean = df.dropna(subset=['시가총액']) # 특정 컬럼의 결측값만 제거

# 실제 사용 예제
top_5 = df.dropna(subset=['시가총액']).sort_values(
    by='시가총액', ascending=False
).head(5)
```

#### `pd.isna()`, `pd.NA`
```python
# 결측값 판별 및 처리
def clean_change_direction(val):
    if pd.isna(val):        # pandas의 결측값 판별
        return pd.NA        # pandas의 결측값 반환
    # ... 처리 로직
    return processed_val
```

---

### 4. 문자열 처리 (String Methods)

#### `.str.replace()`, `.str.strip()`
```python
# 문자열 치환 및 정제
df['종목명'] = df['종목명'].str.replace('\n', '')      # 줄바꿈 제거
df['종목명'] = df['종목명'].str.replace('\t', '')      # 탭 제거
df['종목명'] = df['종목명'].str.strip()               # 앞뒤 공백 제거

# 숫자 문자열에서 콤마 제거
df['현재가'] = df['현재가'].str.replace(',', '', regex=False)
df['시가총액'] = df['시가총액'].str.replace('%', '', regex=False)
```

#### `.str.extract()`, `.str.contains()`
```python
# 정규표현식으로 패턴 추출
df['숫자만'] = df['혼합텍스트'].str.extract(r'(\d+)')

# 패턴 포함 여부 확인
삼성주 = df[df['종목명'].str.contains('삼성')]
```

---

### 5. 데이터 타입 변환

#### `.astype()`, `pd.to_numeric()`
```python
# 기본 타입 변환
df['종목코드'] = df['종목코드'].astype(str)     # 문자열로
df['가격'] = df['가격'].astype(int)            # 정수로
df['비율'] = df['비율'].astype(float)          # 실수로

# 안전한 숫자 변환 (에러 처리)
df['현재가'] = pd.to_numeric(df['현재가'], errors='coerce')
# errors='coerce': 변환 실패시 NaN으로 처리
# errors='raise': 변환 실패시 에러 발생
# errors='ignore': 변환 실패시 원본 유지
```

---

### 6. 데이터 정렬 및 랭킹

#### `.sort_values()`, `.sort_index()`
```python
# 값으로 정렬
df_sorted = df.sort_values('시가총액')                    # 오름차순
df_sorted = df.sort_values('시가총액', ascending=False)   # 내림차순

# 다중 컬럼 정렬
df_sorted = df.sort_values(['시가총액', '현재가'], 
                          ascending=[False, True])

# 인덱스로 정렬
df_sorted = df.sort_index()
```

#### `.nlargest()`, `.nsmallest()`, `.rank()`
```python
# 상위 N개 선택
top_10 = df.nlargest(10, '시가총액')      # 시가총액 상위 10개
bottom_5 = df.nsmallest(5, '현재가')      # 현재가 하위 5개

# 순위 매기기
df['시가총액_순위'] = df['시가총액'].rank(ascending=False)    # 큰 값이 1위
df['가격_백분위'] = df['현재가'].rank(pct=True) * 100       # 백분위수로 변환
```

---

### 7. 데이터 필터링 및 선택

#### 조건부 필터링
```python
# 단일 조건
고가주 = df[df['현재가'] > 100000]
상승주 = df[df['전일비'] > 0]

# 다중 조건 (AND)
우량주 = df[(df['시가총액'] > 1000000) & (df['PER'] < 15)]

# 다중 조건 (OR)
관심주 = df[(df['현재가'] > 100000) | (df['거래량'] > 1000000)]

# 문자열 조건
삼성계열 = df[df['종목명'].str.contains('삼성')]
```

#### `.loc[]`, `.iloc[]`
```python
# 라벨 기반 선택 (.loc)
df.loc[0:5, '종목명':'현재가']           # 행 0-5, 컬럼 범위 선택
df.loc[df['현재가'] > 50000, '종목명']   # 조건부 행, 특정 컬럼

# 위치 기반 선택 (.iloc)
df.iloc[0:5, 0:3]        # 처음 5행, 처음 3컬럼
df.iloc[:, -1]           # 모든 행, 마지막 컬럼
```

---

### 8. 데이터 그룹화 및 집계

#### `.groupby()`, `.agg()`
```python
# 기본 그룹화
sector_stats = df.groupby('업종')['시가총액'].mean()

# 다중 집계 함수
sector_analysis = df.groupby('업종').agg({
    '시가총액': ['sum', 'mean', 'count'],
    '현재가': ['min', 'max'],
    '거래량': 'mean'
})

# 실제 사용 예제
price_group_analysis = df.groupby('가격대').agg({
    '종목명': 'count',           # 종목 수
    '현재가': 'mean',           # 평균 현재가
    '시가총액': 'mean',         # 평균 시가총액
    '거래량': 'mean'            # 평균 거래량
}).round(2)
```

---

### 9. 데이터 변형 및 계산

#### `.apply()`, `.map()`, `.replace()`
```python
# apply: 함수를 각 요소에 적용
df['전일비'] = df['전일비'].apply(clean_change_direction)
df['로그현재가'] = df['현재가'].apply(lambda x: np.log(x) if x > 0 else np.nan)

# map: 매핑 딕셔너리 사용
업종코드 = {'제조업': 'M', '금융업': 'F', '서비스업': 'S'}
df['업종코드'] = df['업종'].map(업종코드)

# replace: 값 치환
df['등급'] = df['등급'].replace(['', '-', 'N/A'], pd.NA)
```

#### `pd.cut()`, `pd.qcut()`
```python
# 구간 분할 (동일 구간)
df['가격대'] = pd.cut(df['현재가'], 
                    bins=[0, 10000, 50000, 100000, float('inf')],
                    labels=['저가', '중저가', '중고가', '고가'])

# 분위수 분할 (동일 개수)
df['시총분위'] = pd.qcut(df['시가총액'], 
                        q=4, 
                        labels=['하위25%', '중하위25%', '중상위25%', '상위25%'])
```

---

### 10. 시계열 및 날짜 처리

#### `pd.Timestamp`, `pd.to_datetime()`
```python
# 현재 시간
now = pd.Timestamp.now()
print(now.strftime('%Y년 %m월 %d일 %H시 %M분'))

# 문자열을 날짜로 변환
df['날짜'] = pd.to_datetime(df['날짜문자열'])
df['년도'] = df['날짜'].dt.year
df['월'] = df['날짜'].dt.month
```

---

### 11. 결과 합치기 및 연결

#### `pd.concat()`, `.merge()`
```python
# DataFrame 연결
combined_df = pd.concat([df1, df2], ignore_index=True)    # 수직 연결
side_by_side = pd.concat([df1, df2], axis=1)             # 수평 연결

# 청크 처리 결과 합치기
chunks = []
for chunk in pd.read_csv('big_file.csv', chunksize=1000):
    processed_chunk = process(chunk)
    chunks.append(processed_chunk)
final_df = pd.concat(chunks, ignore_index=True)

# 테이블 조인
merged_df = df1.merge(df2, on='종목명', how='inner')  # 내부 조인
```

---

## 🔢 NumPy 함수 가이드

### 1. 배열 생성 및 기본 연산

#### `np.array()`, `np.zeros()`, `np.ones()`
```python
import numpy as np

# 배열 생성
arr = np.array([1, 2, 3, 4, 5])
prices = np.array([10000, 20000, 30000])

# 특수 배열 생성
zeros = np.zeros(10)           # 0으로 채운 배열
ones = np.ones(5)             # 1로 채운 배열
range_arr = np.arange(0, 100, 10)  # 0부터 100까지 10씩 증가
```

#### `np.random` 모듈
```python
# 샘플 데이터 생성용
np.random.seed(42)  # 재현 가능한 랜덤

# 랜덤 정수
stock_prices = np.random.randint(1000, 100000, 100)  # 1000-100000 사이 100개

# 랜덤 선택
categories = np.random.choice(['A', 'B', 'C'], 100)  # A,B,C 중 100개 선택

# 정규분포 랜덤
returns = np.random.normal(0.05, 0.2, 252)  # 평균 5%, 표준편차 20%인 수익률
```

---

### 2. 수학 함수

#### `np.log()`, `np.log1p()`, `np.exp()`
```python
# 로그 변환 (데이터 전처리에 자주 사용)
prices = np.array([1000, 10000, 100000])

# 자연로그
log_prices = np.log(prices)
print(log_prices)  # [6.908 9.210 11.513]

# 0값이 있을 때 안전한 로그
prices_with_zero = np.array([0, 1000, 10000])
safe_log = np.log1p(prices_with_zero)  # log(1+x)
print(safe_log)    # [0.000 6.908 9.211]

# 역변환
original = np.exp(log_prices) - 1  # log1p의 역변환
```

#### `np.sqrt()`, `np.power()`, `np.abs()`
```python
# 제곱근 (변동성 계산 등)
volatility = np.sqrt(np.var(returns))

# 거듭제곱
compound_return = np.power(1.05, 10)  # 1.05의 10제곱

# 절댓값 (등락률의 변동성 계산)
abs_changes = np.abs(daily_changes)
```

---

### 3. 통계 함수

#### `.mean()`, `.std()`, `.var()`, `.min()`, `.max()`
```python
data = np.array([10000, 15000, 12000, 18000, 9000])

# 기본 통계
print(f"평균: {data.mean()}")           # 12800.0
print(f"표준편차: {data.std()}")        # 3563.71
print(f"분산: {data.var()}")           # 12700000.0
print(f"최솟값: {data.min()}")         # 9000
print(f"최댓값: {data.max()}")         # 18000

# 백분위수
print(f"중위수: {np.percentile(data, 50)}")    # 12000.0
print(f"25분위: {np.percentile(data, 25)}")   # 10500.0
print(f"75분위: {np.percentile(data, 75)}")   # 15750.0
```

#### `np.corrcoef()`, `np.cov()`
```python
# 상관계수 (두 주식 간의 상관관계)
stock_a = np.random.normal(0.1, 0.2, 100)
stock_b = np.random.normal(0.08, 0.25, 100)

correlation = np.corrcoef(stock_a, stock_b)
print(f"상관계수: {correlation[0,1]:.3f}")

# 공분산
covariance = np.cov(stock_a, stock_b)
```

---

### 4. 배열 형태 변환

#### `.reshape()`, `.flatten()`, `.T`
```python
# 형태 변환
data = np.arange(12)
print(data.shape)              # (12,)

reshaped = data.reshape(3, 4)  # 3x4 행렬로 변환
print(reshaped.shape)          # (3, 4)

# 1차원으로 평탄화
flattened = reshaped.flatten()
print(flattened.shape)         # (12,)

# 전치 (행과 열 바꾸기)
transposed = reshaped.T
print(transposed.shape)        # (4, 3)
```

---

### 5. 조건부 연산

#### `np.where()`, `np.select()`
```python
prices = np.array([5000, 15000, 25000, 35000, 45000])

# 조건부 값 할당
labels = np.where(prices > 20000, '고가주', '저가주')
print(labels)  # ['저가주' '저가주' '고가주' '고가주' '고가주']

# 다중 조건
conditions = [
    prices < 10000,
    (prices >= 10000) & (prices < 30000),
    prices >= 30000
]
choices = ['저가', '중가', '고가']
categories = np.select(conditions, choices)
print(categories)  # ['저가' '중가' '중가' '고가' '고가']
```

---

### 6. 배열 연산 최적화

#### 벡터화 연산의 장점
```python
import time

# 비효율적인 방법 (반복문)
def slow_calculation(data):
    result = []
    for x in data:
        result.append(x * 2 + 1)
    return np.array(result)

# 효율적인 방법 (벡터화)
def fast_calculation(data):
    return data * 2 + 1

# 성능 비교
large_data = np.random.randn(1000000)

start = time.time()
slow_result = slow_calculation(large_data)
slow_time = time.time() - start

start = time.time()
fast_result = fast_calculation(large_data)
fast_time = time.time() - start

print(f"반복문 방식: {slow_time:.3f}초")
print(f"벡터화 방식: {fast_time:.3f}초")
print(f"속도 개선: {slow_time/fast_time:.1f}배 빠름")
```

---

### 7. 결측값 처리

#### `np.nan`, `np.isnan()`, `np.nanmean()`
```python
# 결측값이 포함된 데이터
data_with_nan = np.array([10.0, 20.0, np.nan, 30.0, 40.0])

# 결측값 확인
print(np.isnan(data_with_nan))  # [False False  True False False]

# 결측값 무시하고 통계 계산
print(f"평균 (NaN 무시): {np.nanmean(data_with_nan)}")    # 25.0
print(f"표준편차 (NaN 무시): {np.nanstd(data_with_nan)}")  # 12.91
print(f"최댓값 (NaN 무시): {np.nanmax(data_with_nan)}")   # 40.0
```

---

## 🔧 실무에서의 조합 활용

### 1. 데이터 전처리 파이프라인

```python
def comprehensive_preprocessing(df):
    """판다스 + 넘파이를 활용한 전처리"""
    
    # 1. 문자열 정제 (pandas)
    df['종목명'] = df['종목명'].str.replace('\n', '').str.strip()
    
    # 2. 숫자 변환 (pandas + numpy)
    numeric_cols = ['현재가', '시가총액', '거래량']
    for col in numeric_cols:
        # 문자열 정제
        df[col] = df[col].str.replace(',', '')
        # 안전한 숫자 변환
        df[col] = pd.to_numeric(df[col], errors='coerce')
    
    # 3. 로그 변환 (numpy)
    df['log_시가총액'] = np.log1p(df['시가총액'].fillna(0))
    
    # 4. 표준화 (numpy)
    price_mean = df['현재가'].mean()
    price_std = df['현재가'].std()
    df['표준화_현재가'] = (df['현재가'] - price_mean) / price_std
    
    # 5. 구간 분할 (pandas)
    df['가격대'] = pd.cut(df['현재가'], 
                        bins=[0, 10000, 50000, float('inf')],
                        labels=['저가', '중가', '고가'])
    
    return df
```

### 2. 고급 분석 예제

```python
def advanced_stock_analysis(df):
    """고급 주식 분석 (pandas + numpy 조합)"""
    
    # 1. 수익률 계산 (numpy)
    if '전일종가' in df.columns:
        returns = np.log(df['현재가'] / df['전일종가'])
        df['일일수익률'] = returns
    
    # 2. 이동평균 계산 (pandas rolling)
    df['MA_5'] = df['현재가'].rolling(window=5).mean()
    df['MA_20'] = df['현재가'].rolling(window=20).mean()
    
    # 3. 변동성 계산 (numpy)
    if '일일수익률' in df.columns:
        rolling_vol = df['일일수익률'].rolling(window=20).std() * np.sqrt(252)
        df['연변동성'] = rolling_vol
    
    # 4. 포트폴리오 가중치 (numpy)
    market_caps = df['시가총액'].fillna(0).values
    total_cap = market_caps.sum()
    df['포트폴리오_가중치'] = market_caps / total_cap * 100
    
    # 5. 순위 계산 (pandas)
    df['시총순위'] = df['시가총액'].rank(ascending=False)
    df['수익률순위'] = df['일일수익률'].rank(ascending=False)
    
    return df
```

---

## 🎯 성능 최적화 팁

### 1. 메모리 효율적인 데이터 타입

```python
# 메모리 사용량 최적화
def optimize_dtypes(df):
    """데이터 타입 최적화로 메모리 절약"""
    
    # 정수형 최적화
    for col in df.select_dtypes(include=['int64']).columns:
        col_min = df[col].min()
        col_max = df[col].max()
        
        if col_min >= 0:  # 양수만 있는 경우
            if col_max < 255:
                df[col] = df[col].astype(np.uint8)
            elif col_max < 65535:
                df[col] = df[col].astype(np.uint16)
            elif col_max < 4294967295:
                df[col] = df[col].astype(np.uint32)
        else:  # 음수가 있는 경우
            if col_min > -128 and col_max < 127:
                df[col] = df[col].astype(np.int8)
            elif col_min > -32768 and col_max < 32767:
                df[col] = df[col].astype(np.int16)
    
    # 실수형 최적화
    for col in df.select_dtypes(include=['float64']).columns:
        df[col] = pd.to_numeric(df[col], downcast='float')
    
    return df
```

### 2. 벡터화 연산 활용

```python
# ❌ 느린 방법 (반복문)
def slow_processing(df):
    results = []
    for idx, row in df.iterrows():
        if row['현재가'] > 50000:
            result = row['현재가'] * 1.1
        else:
            result = row['현재가'] * 0.9
        results.append(result)
    return results

# ✅ 빠른 방법 (벡터화)
def fast_processing(df):
    return np.where(df['현재가'] > 50000, 
                   df['현재가'] * 1.1, 
                   df['현재가'] * 0.9)

# 성능 차이: 100-1000배 빠름!
```

---

## 📚 함수별 요약표

### Pandas 핵심 함수

| 카테고리 | 함수명 | 기능 | 사용 빈도 |
|---------|--------|------|-----------|
| **I/O** | `read_csv()` | CSV 파일 읽기 | ⭐⭐⭐⭐⭐ |
| | `to_csv()` | CSV 파일 저장 | ⭐⭐⭐⭐⭐ |
| | `to_excel()` | Excel 파일 저장 | ⭐⭐⭐⭐ |
| **탐색** | `head()`, `info()` | 데이터 확인 | ⭐⭐⭐⭐⭐ |
| | `describe()` | 통계 요약 | ⭐⭐⭐⭐⭐ |
| **정제** | `.str.replace()` | 문자열 치환 | ⭐⭐⭐⭐⭐ |
| | `dropna()` | 결측값 제거 | ⭐⭐⭐⭐ |
| | `apply()` | 함수 적용 | ⭐⭐⭐⭐⭐ |
| **분석** | `groupby()` | 그룹화 | ⭐⭐⭐⭐ |
| | `sort_values()` | 정렬 | ⭐⭐⭐⭐⭐ |
| | `nlargest()` | 상위 N개 | ⭐⭐⭐⭐ |

### NumPy 핵심 함수

| 카테고리 | 함수명 | 기능 | 사용 빈도 |
|---------|--------|------|-----------|
| **배열** | `array()` | 배열 생성 | ⭐⭐⭐⭐ |
| | `arange()` | 범위 배열 생성 | ⭐⭐⭐ |
| **수학** | `log()`, `log1p()` | 로그 변환 | ⭐⭐⭐⭐ |
| | `sqrt()` | 제곱근 | ⭐⭐⭐ |
| **통계** | `mean()`, `std()` | 평균, 표준편차 | ⭐⭐⭐⭐⭐ |
| | `percentile()` | 백분위수 | ⭐⭐⭐ |
| **조건** | `where()` | 조건부 선택 | ⭐⭐⭐⭐ |
| | `isnan()` | 결측값 확인 | ⭐⭐⭐ |

---

## 💡 실무 활용 체크리스트

### ✅ 데이터 로드 시
- [ ] `pd.read_csv()` 인코딩 확인
- [ ] `dtype=str` 로 안전하게 로드
- [ ] `.shape`, `.info()` 로 구조 파악

### ✅ 데이터 정제 시
- [ ] `.str.replace()` 로 불필요 문자 제거
- [ ] `pd.to_numeric()` 로 안전한 타입 변환
- [ ] `.dropna()` 로 결측값 처리

### ✅ 분석 시
- [ ] `.groupby()` 로 그룹별 분석
- [ ] `.sort_values()`, `.nlargest()` 로 순위 분석
- [ ] `np.log()`, `np.where()` 로 고급 변환

### ✅ 결과 저장 시
- [ ] `.to_excel()` 로 다중 시트 저장
- [ ] `encoding='utf-8-sig'` 로 한글 지원
- [ ] `index=False` 로 불필요한 인덱스 제거

이 가이드를 참고하여 pandas와 numpy를 효과적으로 활용하세요! 🚀