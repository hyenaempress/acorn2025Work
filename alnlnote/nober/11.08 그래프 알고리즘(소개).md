# 🕷️ 그래프 거미 미궁 대모험: 네트워크의 지배자들

## 📜 서막: 거대한 거미줄 네트워크의 전설

정렬 왕국, 탐색 대륙, 기하 요정 왕국을 지나... 이제 우리는 신비로운 거미줄 차원에 발을 들여놓았다.

### 🕸️ 고대 네트워크 예언서

> *"무한히 펼쳐진 거미줄 차원에서  
> 각 교차점(Vertex)은 무한한 가능성이고,  
> 각 실줄(Edge)은 운명의 연결이다.  
>   
> 작은 거미에서 시작하여  
> 미궁의 악몽이 되기까지...  
> 네트워크를 지배하는 자만이  
> 진정한 웹 마스터가 될 수 있으리라."*

---

## 🏛️ 거미 미궁 층별 구조도

### 🏰 거미 미궁의 9층 구조

- **👑 9층** - 웹 마스터의 방 (복합 네트워크 지배)
- **🌌 8층** - 네트워크 플로우의 바다 (최대유량)
- **🔗 7층** - 강연결 요새 (강연결요소)
- **📐 6층** - 위상정렬의 계단 (위상정렬)
- **🌳 5층** - 최소연결의 숲 (MST - 크루스칼/프림)
- **🗺️ 4층** - 최단거리의 미로 (다익스트라/벨만포드)
- **🌊 3층** - 모든 경로의 바다 (플로이드-워셜)
- **🔍 2층** - 기본 탐험의 방 (DFS/BFS)
- **📚 1층** - 거미줄 기초 도서관 (Graph 기본 개념)

---

## 🕷️ 거미 진화 시스템

### 🥚 1층 - 거미줄 기초 도서관

**📚 기본 개념 거미들** *(이름 없는 거미)*

- **🔗 스몰 버텍시(Small Vertexi)** - "교차점을 처음 배우는 거미"
- **🕸️ 스몰 엣지(Small Edgy)** - "연결의 의미를 아는 거미"
- **📊 스몰 매트릭서(Small Matrixer)** - "인접행렬을 기록하는 거미"
- **📝 스몰 리스터(Small Lister)** - "인접 리스트를 만드는 거미"

#### 거미줄 기초 학습 📖

```python
class 스몰_버텍시:
    def __init__(self):
        self.그래프 = {}
        print("🔗 스몰 버텍시: '처음 만나는 거미줄 세계!'")
    
    def 교차점_설명(self):
        """버텍스(정점)의 기본 개념 설명"""
        print("📚 '교차점(Vertex)은 거미줄이 만나는 중요한 지점이야!'")
        print("   - 도시, 사람, 컴퓨터, 웹페이지... 뭐든 될 수 있어!")
        print("   - 각 교차점은 고유한 이름이나 번호를 가져!")
        
    def 연결_설명(self):
        """엣지(간선)의 기본 개념 설명"""
        print("🕸️ '실줄(Edge)은 교차점들을 연결하는 통로야!'")
        print("   - 도로, 관계, 케이블, 링크... 연결의 의미!")
        print("   - 방향이 있을 수도, 없을 수도 있어!")
        
    def 작은_거미줄_만들기(self):
        """첫 번째 그래프 만들기"""
        print("🌟 '내 첫 거미줄을 만들어보자!'")
        
        # 간단한 친구 관계 그래프
        친구들 = ["앨리스", "밥", "찰리", "다이애나"]
        관계들 = [
            ("앨리스", "밥"), ("밥", "찰리"), 
            ("찰리", "다이애나"), ("다이애나", "앨리스")
        ]
        
        for 친구 in 친구들:
            self.그래프[친구] = []
            print(f"   👥 {친구} 추가!")
            
        for 친구1, 친구2 in 관계들:
            self.그래프[친구1].append(친구2)
            self.그래프[친구2].append(친구1)  # 양방향 친구관계
            print(f"   💕 {친구1} ↔ {친구2} 연결!")
            
        print(f"\n🎉 완성된 친구 네트워크:")
        for 친구, 친구목록 in self.그래프.items():
            print(f"   {친구}의 친구들: {친구목록}")

# 1층 체험
print("🏰 1층 - 거미줄 기초 도서관 입장!")
기초거미 = 스몰_버텍시()
기초거미.교차점_설명()
기초거미.연결_설명()
기초거미.작은_거미줄_만들기()
```

---

### 🔍 2층 - 기본 탐험의 방

**초급 탐험 거미들**

- **🚶 뎁스 크롤러(Depth Crawler)** - "깊이우선탐색의 견습생"
- **🌊 브레드스 스카우트(Breadth Scout)** - "너비우선탐색의 정찰병"
- **🔄 서클 디텍터(Circle Detector)** - "순환을 감지하는 거미"

#### DFS/BFS 마스터하기 🔍

```python
from collections import deque

class 뎁스_크롤러:
    def __init__(self):
        print("🚶 뎁스 크롤러: '깊은 곳까지 탐험하는 거미야!'")
    
    def 깊이_탐험(self, 거미줄, 시작점):
        """DFS로 거미줄 탐험"""
        print(f"🔍 '{시작점}에서 시작해서 깊게 탐험해보자!'")
        
        방문기록 = set()
        탐험스택 = [시작점]
        탐험순서 = []
        
        while 탐험스택:
            현재위치 = 탐험스택.pop()
            
            if 현재위치 not in 방문기록:
                방문기록.add(현재위치)
                탐험순서.append(현재위치)
                print(f"   📍 {현재위치} 방문!")
                
                # 연결된 곳들을 스택에 추가 (역순으로)
                for 다음위치 in reversed(거미줄.get(현재위치, [])):
                    if 다음위치 not in 방문기록:
                        탐험스택.append(다음위치)
                        print(f"   📋 {다음위치} 탐험 예정!")
        
        print(f"🎉 DFS 탐험 완료! 순서: {' → '.join(탐험순서)}")
        return 탐험순서

class 브레드스_스카우트:
    def __init__(self):
        print("🌊 브레드스 스카우트: '넓게 보며 탐험하는 거미야!'")
    
    def 너비_탐험(self, 거미줄, 시작점):
        """BFS로 거미줄 탐험"""
        print(f"🔍 '{시작점}에서 시작해서 넓게 탐험해보자!'")
        
        방문기록 = set()
        탐험큐 = deque([시작점])
        탐험순서 = []
        
        방문기록.add(시작점)
        
        while 탐험큐:
            현재위치 = 탐험큐.popleft()
            탐험순서.append(현재위치)
            print(f"   📍 {현재위치} 방문!")
            
            # 연결된 곳들을 큐에 추가
            for 다음위치 in 거미줄.get(현재위치, []):
                if 다음위치 not in 방문기록:
                    방문기록.add(다음위치)
                    탐험큐.append(다음위치)
                    print(f"   📋 {다음위치} 탐험 예정!")
        
        print(f"🎉 BFS 탐험 완료! 순서: {' → '.join(탐험순서)}")
        return 탐험순서

# 2층 체험
print(f"\n🏰 2층 - 기본 탐험의 방 입장!")

# 테스트용 거미줄 네트워크
거미줄_네트워크 = {
    "A": ["B", "C"],
    "B": ["A", "D", "E"], 
    "C": ["A", "F"],
    "D": ["B"],
    "E": ["B", "F"],
    "F": ["C", "E"]
}

print("🕸️ 탐험할 거미줄 네트워크:")
for 지점, 연결들 in 거미줄_네트워크.items():
    print(f"   {지점}: {연결들}")

깊이거미 = 뎁스_크롤러()
dfs_결과 = 깊이거미.깊이_탐험(거미줄_네트워크, "A")

print()
너비거미 = 브레드스_스카우트()  
bfs_결과 = 너비거미.너비_탐험(거미줄_네트워크, "A")

print(f"\n📊 탐험 결과 비교:")
print(f"   DFS: {' → '.join(dfs_결과)}")
print(f"   BFS: {' → '.join(bfs_결과)}")
```

---

### 🌊 3층 - 모든 경로의 바다

**전지적 거미**

- **🌊 플로이드 오라클(Floyd Oracle)** - "모든 길을 아는 현자"

```python
class 플로이드_오라클:
    def __init__(self):
        print("🌊 플로이드 오라클: '모든 경로의 현자가 나타났다!'")
    
    def 모든_최단경로_계산(self, 정점들, 간선들):
        """플로이드-워셜 알고리즘으로 모든 쌍 최단경로"""
        print("🔮 '시공간을 초월하여 모든 길을 계산하겠다!'")
        
        INF = float('inf')
        n = len(정점들)
        
        # 정점 이름을 인덱스로 매핑
        정점_인덱스 = {정점: i for i, 정점 in enumerate(정점들)}
        
        # 거리 행렬 초기화
        거리 = [[INF] * n for _ in range(n)]
        
        # 자기 자신으로의 거리는 0
        for i in range(n):
            거리[i][i] = 0
            
        # 직접 연결된 간선들의 거리 설정
        for 시작, 끝, 가중치 in 간선들:
            i, j = 정점_인덱스[시작], 정점_인덱스[끝]
            거리[i][j] = 가중치
            print(f"   🛤️ {시작} → {끝}: {가중치}")
        
        print(f"\n🔄 플로이드-워셜 마법 시작!")
        
        # 플로이드-워셜 핵심 로직
        for k in range(n):
            중간점 = 정점들[k]
            print(f"   ⚡ {중간점}을(를) 경유지로 고려 중...")
            
            for i in range(n):
                for j in range(n):
                    if 거리[i][k] + 거리[k][j] < 거리[i][j]:
                        이전거리 = 거리[i][j]
                        거리[i][j] = 거리[i][k] + 거리[k][j]
                        시작점 = 정점들[i]
                        끝점 = 정점들[j]
                        print(f"      🌟 {시작점} → {끝점}: {이전거리} → {거리[i][j]} (via {중간점})")
        
        return 거리, 정점_인덱스
    
    def 결과_출력(self, 거리, 정점들, 정점_인덱스):
        """모든 쌍 최단거리 결과 출력"""
        print(f"\n📊 모든 쌍 최단거리 행렬:")
        
        # 헤더 출력
        print("     ", end="")
        for 정점 in 정점들:
            print(f"{정점:>6}", end="")
        print()
        
        # 행렬 출력
        for i, 시작정점 in enumerate(정점들):
            print(f"{시작정점:>4} ", end="")
            for j, 끝정점 in enumerate(정점들):
                if 거리[i][j] == float('inf'):
                    print("   ∞", end="")
                else:
                    print(f"{거리[i][j]:>6}", end="")
            print()

# 3층 체험
print(f"\n🏰 3층 - 모든 경로의 바다 입장!")

현자거미 = 플로이드_오라클()

# 가중치가 있는 방향 그래프
정점들 = ["A", "B", "C", "D"]
간선들 = [
    ("A", "B", 3), ("A", "C", 8), ("A", "D", 7),
    ("B", "A", 2), ("B", "C", 5), ("B", "D", 1),
    ("C", "A", 4), ("C", "B", 1), ("C", "D", 2),
    ("D", "A", 6), ("D", "B", 3), ("D", "C", 1)
]

거리행렬, 인덱스맵 = 현자거미.모든_최단경로_계산(정점들, 간선들)
현자거미.결과_출력(거리행렬, 정점들, 인덱스맵)
```

---

### 🗺️ 4층 - 최단거리의 미로

**길잡이 거미들**

- **🗺️ 다익스트라 웨버(Dijkstra Weaver)** - "최단거리의 직조사"
- **⚡ 벨만 워커(Bellman Walker)** - "음수간선도 무서워하지 않는 용사"

---

### 🌳 5층 - 최소연결의 숲

**건축가 거미들**

- **🌳 크루스칼 빌더(Kruskal Builder)** - "간선 중심 건축가"
- **🌿 프림 가드너(Prim Gardner)** - "정점 중심 정원사"

---

### 📐 6층 - 위상정렬의 계단

**질서의 거미**

- **📐 토포 소터(Topo Sorter)** - "질서정연한 안내자"

---

### 🔗 7층 - 강연결 요새

**연결 마스터**

- **🔗 타잔 링커(Tarjan Linker)** - "강력한 연결의 수호자"

---

### 🌌 8층 - 네트워크 플로우의 바다

**흐름 제어자들**

- **🌊 포드 플로워(Ford Flower)** - "최대유량의 마스터"

---

### 👑 9층 - 웹 마스터의 방

**미궁의 악몽** *(최종 보스들)*

- **🕷️ 그래프 퀸(Graph Queen)** - "모든 알고리즘을 다루는 여왕"
- **🌐 네트워크 로드(Network Lord)** - "복잡한 네트워크의 지배자"
- **👑 웹 마스터(Web Master)** - "거미줄 차원의 절대자"

---

## 🎮 미궁 탐험 시스템

### 📈 거미 성장 시스템

```python
class 거미_성장_시스템:
    def __init__(self):
        self.경험치 = 0
        self.레벨 = 1
        self.습득_기술 = []
        
    def 알고리즘_마스터(self, 알고리즘명):
        """새로운 그래프 알고리즘 습득"""
        경험치_획득 = {
            "DFS/BFS": 100, "다익스트라": 200, "플로이드-워셜": 300,
            "크루스칼": 250, "프림": 250, "위상정렬": 150,
            "강연결요소": 400, "최대유량": 500
        }
        
        if 알고리즘명 in 경험치_획득:
            self.경험치 += 경험치_획득[알고리즘명]
            self.습득_기술.append(알고리즘명)
            print(f"🎉 {알고리즘명} 마스터! (+{경험치_획득[알고리즘명]} EXP)")
            
            # 레벨업 체크
            if self.경험치 >= self.레벨 * 500:
                self.레벨 += 1
                print(f"⭐ 레벨 업! 현재 레벨: {self.레벨}")
```

---

## 🏆 미궁 클리어 조건

1. **각 층별 보스 거미 처치**: 해당 알고리즘 완전 이해
2. **실전 문제 해결**: 코딩 테스트 수준의 응용 문제
3. **시간복잡도 마스터**: Big-O 완벽 이해
4. **최적화 도전**: 더 효율적인 구현 방법 탐구

---


## 🏛️ 전체 거미 캐스트 소개

| 거미 | ⏰ 시간복잡도 | 💾 공간복잡도 | 층수 | 역할 | 특기 |
|------|-------------|--------------|------|------|------|
| 🔗 **스몰 버텍시** | **O(1)** | **O(1)** | **1층** | **기초 교육자** | **정점 개념 교육** |
| 🕸️ **스몰 엣지** | **O(1)** | **O(1)** | **1층** | **연결 설명자** | **간선 개념 교육** |
| 📊 **스몰 매트릭서** | **O(V²)** | **O(V²)** | **1층** | **기록자** | **인접행렬 관리** |
| 📝 **스몰 리스터** | **O(V+E)** | **O(V+E)** | **1층** | **목록 작성자** | **인접리스트 관리** |
| 🚶 **뎁스 크롤러** | **O(V+E)** | **O(V)** | **2층** | **깊이 탐험가** | **DFS 마스터** |
| 🌊 **브레드스 스카우트** | **O(V+E)** | **O(V)** | **2층** | **너비 정찰병** | **BFS 마스터** |
| 🔄 **서클 디텍터** | **O(V+E)** | **O(V)** | **2층** | **순환 감지자** | **사이클 탐지** |
| 🌊 **플로이드 오라클** | **O(V³)** | **O(V²)** | **3층** | **전지적 현자** | **모든 쌍 최단경로** |
| 🗺️ **다익스트라 웨버** | **O(V log V)** | **O(V)** | **4층** | **최단경로 직조사** | **단일 출발 최단경로** |
| ⚡ **벨만 워커** | **O(VE)** | **O(V)** | **4층** | **음수 대응 전사** | **음수 간선 처리** |
| 🌳 **크루스칼 빌더** | **O(E log E)** | **O(V)** | **5층** | **간선 중심 건축가** | **MST 구축 (간선 기준)** |
| 🌿 **프림 가드너** | **O(V log V)** | **O(V)** | **5층** | **정점 중심 정원사** | **MST 구축 (정점 기준)** |
| 📐 **토포 소터** | **O(V+E)** | **O(V)** | **6층** | **질서 정립자** | **위상정렬** |
| 🔗 **타잔 링커** | **O(V+E)** | **O(V)** | **7층** | **강연결 수호자** | **강연결요소 탐지** |
| 🌊 **포드 플로워** | **O(VE²)** | **O(V²)** | **8층** | **유량 제어자** | **최대유량** |
| 🕷️ **그래프 퀸** | **모든 것** | **모든 것** | **9층** | **최종 보스** | **완전 네트워크 지배** |

---

## 📚 1층 - 거미줄 기초 도서관의 교육자들

### 🔗 스몰 버텍시 (Small Vertexi) - "교차점의 첫 번째 친구"

#### 캐릭터 설정 📚
- **클래스**: 기초 거미 (Basic Educator)
- **정체**: 그래프 세계에 첫 발을 들인 이들을 안내하는 친절한 거미
- **별명**: "점점이 선생님"
- **성격**: 매우 친절하고 인내심이 강함, 기초를 소홀히 하지 않음
- **특기**: 복잡한 개념을 쉬운 말로 설명하는 능력
- **철학**: "모든 위대한 네트워크는 하나의 점에서 시작된다"
- **말버릇**: "차근차근, 하나씩 알아가자!"
- **무기**: 개념 설명 칠판 (복잡한 것을 간단하게 그려서 설명)

```python
class 스몰_버텍시:
    def __init__(self):
        print("🔗 스몰 버텍시: '안녕! 그래프 세계 첫 가이드 버텍시야!'")
        self.인내심 = 100
        self.친절도 = 95
        
    def 기초_개념_설명(self):
        """아주 쉽게 정점 개념 설명"""
        print("📚 '정점(Vertex)은 그래프의 가장 기본 요소야!'")
        print("   🏠 집, 👥 사람, 🏙️ 도시, 💻 컴퓨터...")
        print("   🌟 뭐든지 정점이 될 수 있어!")
        
    def 격려_메시지(self):
        print("💪 '처음엔 어려워도 괜찮아! 모든 마스터도 처음엔 초보였거든!'")
```

### 🕸️ 스몰 엣지 (Small Edgy) - "연결의 의미를 가르치는 자"

#### 캐릭터 설정 🕸️
- **클래스**: 연결 전문가 (Connection Specialist)
- **정체**: 점들 사이의 연결과 관계의 중요성을 가르치는 거미
- **별명**: "연결고리 선생님"
- **성격**: 사교적이고 관계 중시, 모든 것의 연결성을 중요하게 생각
- **특기**: 복잡한 관계를 한눈에 파악하고 설명
- **철학**: "연결이 없다면 그래프도 없다. 관계가 모든 것을 만든다"
- **말버릇**: "모든 것은 연결되어 있어!"
- **무기**: 관계 분석 거미줄 (복잡한 연결을 시각화)

```python
class 스몰_엣지:
    def __init__(self):
        print("🕸️ 스몰 엣지: '연결의 마법을 가르치는 엣지야!'")
        self.사교성 = 98
        self.관찰력 = 92
        
    def 연결_중요성_설명(self):
        print("🌐 '간선(Edge)은 정점들을 이어주는 다리야!'")
        print("   ↔️ 양방향: 친구 관계처럼 서로 갈 수 있어")
        print("   → 단방향: 팔로우처럼 한쪽만 갈 수 있어")
        
    def 관계_분석(self, 관계들):
        print(f"🔍 '{len(관계들)}개의 연결을 분석해보자!'")
        for 시작, 끝 in 관계들:
            print(f"   💕 {시작} ↔ {끝}: 강한 유대!")
```

### 📊 스몰 매트릭서 (Small Matrixer) - "표 만들기의 달인"

#### 캐릭터 설정 📊
- **클래스**: 데이터 관리자 (Data Manager)
- **정체**: 복잡한 연결 관계를 깔끔한 표로 정리하는 체계적인 거미
- **별명**: "행렬 박사"
- **성격**: 매우 체계적이고 정확함, 완벽주의 성향
- **특기**: 인접행렬 생성 및 관리, 데이터 시각화
- **철학**: "모든 혼돈은 올바른 표로 정리할 수 있다"
- **말버릇**: "표로 만들면 다 보여!"
- **무기**: 마법 계산기 (복잡한 행렬 연산을 순식간에 처리)

```python
class 스몰_매트릭서:
    def __init__(self):
        print("📊 스몰 매트릭서: '깔끔한 표 만들기 전문가 매트릭서야!'")
        self.정확성 = 99
        self.체계성 = 97
        
    def 인접행렬_생성(self, 정점들, 간선들):
        print("📋 '연결 관계를 표로 만들어보자!'")
        n = len(정점들)
        행렬 = [[0] * n for _ in range(n)]
        
        # 정점 인덱스 매핑
        인덱스 = {정점: i for i, 정점 in enumerate(정점들)}
        
        for 시작, 끝 in 간선들:
            i, j = 인덱스[시작], 인덱스[끝]
            행렬[i][j] = 1
            행렬[j][i] = 1  # 무방향 그래프
            
        self.표_출력(정점들, 행렬)
        return 행렬
    
    def 표_출력(self, 정점들, 행렬):
        print("📊 완성된 인접행렬:")
        print("    ", end="")
        for 정점 in 정점들:
            print(f"{정점:>3}", end="")
        print()
        
        for i, 시작정점 in enumerate(정점들):
            print(f"{시작정점:>3} ", end="")
            for j in range(len(정점들)):
                print(f"{행렬[i][j]:>3}", end="")
            print()
```

### 📝 스몰 리스터 (Small Lister) - "목록의 마에스트로"

#### 캐릭터 설정 📝
- **클래스**: 목록 전문가 (List Specialist)
- **정체**: 효율적인 인접리스트 관리로 메모리를 절약하는 실용적인 거미
- **별명**: "리스트 마스터"
- **성격**: 실용적이고 효율성 중시, 낭비를 싫어함
- **특기**: 메모리 효율적인 그래프 표현, 동적 리스트 관리
- **철학**: "필요한 것만 저장하는 것이 진정한 지혜다"
- **말버릇**: "효율적으로 관리하자!"
- **무기**: 동적 확장 가방 (필요에 따라 크기가 조절되는 마법 가방)

```python
class 스몰_리스터:
    def __init__(self):
        print("📝 스몰 리스터: '효율적인 리스트 관리 전문가 리스터야!'")
        self.효율성 = 96
        self.실용성 = 94
        
    def 인접리스트_생성(self, 정점들, 간선들):
        print("📝 '메모리 효율적인 리스트를 만들어보자!'")
        인접리스트 = {정점: [] for 정점 in 정점들}
        
        for 시작, 끝 in 간선들:
            인접리스트[시작].append(끝)
            인접리스트[끝].append(시작)  # 무방향 그래프
            print(f"   ➕ {시작} ↔ {끝} 연결 추가!")
            
        self.리스트_출력(인접리스트)
        return 인접리스트
    
    def 리스트_출력(self, 인접리스트):
        print("📋 완성된 인접리스트:")
        for 정점, 연결리스트 in 인접리스트.items():
            print(f"   {정점}: {연결리스트}")
            
    def 메모리_효율성_분석(self, 정점수, 간선수):
        행렬_메모리 = 정점수 * 정점수
        리스트_메모리 = 정점수 + (간선수 * 2)  # 무방향 그래프
        
        print(f"💾 메모리 사용량 비교:")
        print(f"   인접행렬: {행렬_메모리} units")
        print(f"   인접리스트: {리스트_메모리} units")
        print(f"   💰 {행렬_메모리 - 리스트_메모리} units 절약!")
```

---

## 🔍 2층 - 기본 탐험의 방의 모험가들

### 🚶 뎁스 크롤러 (Depth Crawler) - "깊이의 탐험가"

#### 캐릭터 설정 🚶
- **클래스**: 깊이 탐험가 (Depth Explorer)
- **정체**: 한 길을 끝까지 파고드는 것을 좋아하는 집요한 거미
- **별명**: "깊이 파는 거미"
- **성격**: 집중력이 강하고 끈기가 있음, 완벽주의적 성향
- **특기**: DFS 구현, 경로 추적, 연결 컴포넌트 찾기
- **철학**: "깊이 파면 반드시 답이 나온다"
- **말버릇**: "끝까지 파보자!"
- **무기**: 깊이 탐지 스택 (무한히 깊이 들어갈 수 있는 마법 스택)

```python
class 뎁스_크롤러:
    def __init__(self):
        print("🚶 뎁스 크롤러: '깊이의 진리를 찾는 탐험가야!'")
        self.집중력 = 98
        self.끈기 = 95
        self.스택_마법 = True
        
    def 깊이우선_탐험(self, 그래프, 시작점):
        """DFS로 그래프의 깊은 곳까지 탐험"""
        print(f"🎯 '{시작점}에서 시작해서 깊~~~이 들어가자!'")
        
        방문기록 = set()
        탐험스택 = [시작점]
        탐험순서 = []
        경로추적 = {시작점: None}
        
        while 탐험스택:
            현재위치 = 탐험스택.pop()
            
            if 현재위치 not in 방문기록:
                방문기록.add(현재위치)
                탐험순서.append(현재위치)
                print(f"   🔍 {현재위치} 도착! (깊이: {len(탐험순서)})")
                
                # 더 깊이 들어갈 곳 찾기
                연결지점들 = sorted(그래프.get(현재위치, []), reverse=True)
                for 다음지점 in 연결지점들:
                    if 다음지점 not in 방문기록:
                        탐험스택.append(다음지점)
                        경로추적[다음지점] = 현재위치
                        print(f"   📋 {다음지점} 탐험 예정 (스택에 추가)")
        
        print(f"🏁 DFS 완료! 탐험 순서: {' → '.join(탐험순서)}")
        return 탐험순서, 경로추적
    
    def 연결컴포넌트_찾기(self, 그래프):
        """DFS로 연결된 구역들 찾기"""
        print("🗺️ '연결된 구역들을 모두 찾아보자!'")
        
        방문완료 = set()
        컴포넌트들 = []
        
        for 시작점 in 그래프:
            if 시작점 not in 방문완료:
                print(f"\n🆕 새로운 구역 발견! {시작점}에서 시작")
                탐험결과, _ = self.깊이우선_탐험(그래프, 시작점)
                컴포넌트들.append(탐험결과)
                방문완료.update(탐험결과)
        
        print(f"\n🎉 총 {len(컴포넌트들)}개의 연결된 구역 발견!")
        return 컴포넌트들
```

### 🌊 브레드스 스카우트 (Breadth Scout) - "너비의 정찰병"

#### 캐릭터 설정 🌊
- **클래스**: 너비 정찰병 (Breadth Scout)
- **정체**: 동시에 여러 방향을 살피며 최단경로를 찾는 전략적 거미
- **별명**: "넓게 보는 거미"
- **성격**: 전략적이고 공정함, 모든 가능성을 동등하게 고려
- **특기**: BFS 구현, 최단경로 탐색, 레벨별 탐색
- **철학**: "모든 길을 공평하게 살피면 최선을 찾을 수 있다"
- **말버릇**: "넓게 보자!"
- **무기**: 공정 탐색 큐 (모든 후보를 공평하게 처리하는 마법 큐)

```python
from collections import deque

class 브레드스_스카우트:
    def __init__(self):
        print("🌊 브레드스 스카우트: '넓은 시야로 최선을 찾는 정찰병이야!'")
        self.전략성 = 96
        self.공정성 = 98
        self.큐_마법 = True
        
    def 너비우선_탐험(self, 그래프, 시작점):
        """BFS로 레벨별 탐험"""
        print(f"🎯 '{시작점}에서 시작해서 넓~게 탐험하자!'")
        
        방문기록 = set([시작점])
        탐험큐 = deque([시작점])
        탐험순서 = []
        레벨별_탐험 = {시작점: 0}
        부모추적 = {시작점: None}
        
        현재레벨 = 0
        
        while 탐험큐:
            현재위치 = 탐험큐.popleft()
            현재레벨 = 레벨별_탐험[현재위치]
            탐험순서.append(현재위치)
            
            print(f"   🌊 {현재위치} 방문! (레벨 {현재레벨})")
            
            # 같은 레벨의 모든 이웃 탐색
            연결지점들 = sorted(그래프.get(현재위치, []))
            for 다음지점 in 연결지점들:
                if 다음지점 not in 방문기록:
                    방문기록.add(다음지점)
                    탐험큐.append(다음지점)
                    레벨별_탐험[다음지점] = 현재레벨 + 1
                    부모추적[다음지점] = 현재위치
                    print(f"   📋 {다음지점} 발견! (레벨 {현재레벨 + 1})")
        
        print(f"🏁 BFS 완료! 탐험 순서: {' → '.join(탐험순서)}")
        return 탐험순서, 레벨별_탐험, 부모추적
    
    def 최단경로_찾기(self, 그래프, 시작점, 목적지):
        """BFS로 최단경로 찾기"""
        print(f"🗺️ '{시작점}에서 {목적지}까지 최단경로 찾기!'")
        
        _, 레벨정보, 부모추적 = self.너비우선_탐험(그래프, 시작점)
        
        if 목적지 not in 부모추적:
            print(f"😞 '{목적지}에 갈 수 없어!'")
            return None
        
        # 경로 역추적
        경로 = []
        현재 = 목적지
        while 현재 is not None:
            경로.append(현재)
            현재 = 부모추적[현재]
        경로.reverse()
        
        print(f"✨ 최단경로 발견! {' → '.join(경로)} (거리: {레벨정보[목적지]})")
        return 경로
```

### 🔄 서클 디텍터 (Circle Detector) - "순환의 감지자"

#### 캐릭터 설정 🔄
- **클래스**: 순환 감지자 (Cycle Detector)
- **정체**: 그래프에서 순환(사이클)을 찾아내는 예리한 감각의 거미
- **별명**: "원형 추적자"
- **성격**: 예민하고 관찰력이 뛰어남, 작은 변화도 놓치지 않음
- **특기**: 사이클 탐지, 무한루프 방지, 트리 판별
- **철학**: "순환은 때로는 축복이지만 때로는 재앙이다"
- **말버릇**: "돌고 도는 게 있네!"
- **무기**: 순환 감지 나침반 (순환 구조를 한눈에 파악)

```python
class 서클_디텍터:
    def __init__(self):
        print("🔄 서클 디텍터: '순환의 비밀을 밝혀내는 감지자야!'")
        self.관찰력 = 99
        self.예민함 = 97
        self.순환감지력 = 100
        
    def 사이클_탐지_DFS(self, 그래프):
        """DFS 기반 사이클 탐지"""
        print("🔍 'DFS로 숨어있는 사이클을 찾아보자!'")
        
        색상 = {}  # 0: 미방문, 1: 방문중(회색), 2: 방문완료(검정)
        사이클들 = []
        
        def dfs(현재, 경로):
            색상[현재] = 1  # 방문 시작
            print(f"   🔍 {현재} 탐색 시작 (경로: {' → '.join(경로)})")
            
            for 다음 in 그래프.get(현재, []):
                if 색상.get(다음, 0) == 1:  # 방문 중인 노드 재방문 = 사이클!
                    사이클_시작 = 경로.index(다음)
                    사이클 = 경로[사이클_시작:] + [다음]
                    사이클들.append(사이클)
                    print(f"   🔄 사이클 발견! {' → '.join(사이클)}")
                elif 색상.get(다음, 0) == 0:
                    dfs(다음, 경로 + [다음])
            
            색상[현재] = 2  # 방문 완료
            print(f"   ✅ {현재} 탐색 완료")
        
        # 모든 정점에서 DFS 시작
        for 시작점 in 그래프:
            if 색상.get(시작점, 0) == 0:
                dfs(시작점, [시작점])
        
        if 사이클들:
            print(f"🎉 총 {len(사이클들)}개의 사이클 발견!")
            return 사이클들
        else:
            print("✨ 사이클이 없는 깔끔한 그래프네!")
            return []
    
    def 트리_판별(self, 그래프):
        """그래프가 트리인지 판별"""
        print("🌳 '이 그래프가 트리인지 확인해보자!'")
        
        정점수 = len(그래프)
        간선수 = sum(len(연결들) for 연결들 in 그래프.values()) // 2
        
        print(f"   📊 정점: {정점수}개, 간선: {간선수}개")
        
        # 트리 조건 1: 간선 수 = 정점 수 - 1
        if 간선수 != 정점수 - 1:
            print(f"   ❌ 트리가 아님! (간선 수가 {정점수-1}개가 아님)")
            return False
        
        # 트리 조건 2: 연결되어 있음
        if len(self.연결컴포넌트_찾기(그래프)) != 1:
            print("   ❌ 트리가 아님! (연결되지 않은 부분이 있음)")
            return False
        
        # 트리 조건 3: 사이클이 없음
        if self.사이클_탐지_DFS(그래프):
            print("   ❌ 트리가 아님! (사이클이 존재함)")
            return False
        
        print("   ✅ 완벽한 트리입니다!")
        return True
```

---

## 🌊 3층 - 모든 경로의 바다의 현자

### 🌊 플로이드 오라클 (Floyd Oracle) - "전지적 현자"

#### 캐릭터 설정 🔮
- **클래스**: 전지적 현자 (Omniscient Sage)
- **정체**: 시공간을 초월하여 모든 정점 간의 최단거리를 한번에 계산하는 신비한 거미
- **별명**: "모든 길의 현자"
- **성격**: 신비롭고 지혜로움, 전체를 조망하는 거시적 시각
- **특기**: 플로이드-워셜 알고리즘, 모든 쌍 최단경로 계산
- **철학**: "모든 길은 연결되어 있고, 모든 연결에는 최적이 있다"
- **말버릇**: "시공간을 초월하여 모든 것을 보노라!"
- **무기**: 전지적 수정구 (모든 경로를 동시에 계산하는 신비한 구슬)

```python
class 플로이드_오라클:
    def __init__(self):
        print("🌊 플로이드 오라클: '시공간을 초월한 현자가 강림하였다!'")
        self.지혜 = 100
        self.전지력 = 99
        self.신비함 = 98
        self.수정구_마법 = True
        
    def 전지적_최단경로_계산(self, 정점들, 간선들):
        """플로이드-워셜로 모든 쌍 최단경로 계산"""
        print("🔮 '시공간의 모든 길을 한눈에 보겠노라!'")
        
        INF = float('inf')
        n = len(정점들)
        정점_인덱스 = {정점: i for i, 정점 in enumerate(정점들)}
        
        # 거리 행렬 초기화
        거리 = [[INF] * n for _ in range(n)]
        경로 = [[None] * n for _ in range(n)]
        
        # 자기 자신으로의 거리는 0
        for i in range(n):
            거리[i][i] = 0
            
        # 직접 간선들 설정
        for 시작, 끝, 가중치 in 간선들:
            i, j = 정점_인덱스[시작], 정점_인덱스[끝]
            거리[i][j] = 가중치
            경로[i][j] = 끝
            print(f"   🛤️ {시작} → {끝}: {가중치} (직접 연결)")
        
        print(f"\n⚡ 플로이드-워셜 전지적 마법 발동!")
        
        # 플로이드-워셜 핵심 - 3중 루프
        for k in range(n):
            중간점 = 정점들[k]
            print(f"\n   🌟 {중간점}을(를) 경유지로 고려하는 차원...")
            
            개선된_경로들 = []
            for i in range(n):
                for j in range(n):
                    if 거리[i][k] + 거리[k][j] < 거리[i][j]:
                        이전거리 = 거리[i][j]
                        거리[i][j] = 거리[i][k] + 거리[k][j]
                        경로[i][j] = 경로[i][k]
                        
                        시작점 = 정점들[i]
                        끝점 = 정점들[j]
                        개선된_경로들.append((시작점, 끝점, 이전거리, 거리[i][j]))
            
            for 시작, 끝, 이전, 새로운 in 개선된_경로들:
                print(f"      ✨ {시작} → {끝}: {이전} → {새로운} (via {중간점})")
        
        print(f"\n🎉 전지적 계산 완료! 모든 경로의 비밀이 밝혀짐!")
        return 거리, 경로, 정점_인덱스
    
    def 경로_재구성(self, 시작, 끝, 경로, 정점들, 정점_인덱스):
        """실제 경로 재구성"""
        if 시작 == 끝:
            return [시작]
        
        i, j = 정점_인덱스[시작], 정점_인덱스[끝]
        if 경로[i][j] is None:
            return None  # 경로 없음
        
        실제경로 = [시작]
        현재 = 시작
        
        while 현재 != 끝:
            i = 정점_인덱스[현재]
            j = 정점_인덱스[끝]
            현재 = 경로[i][j]
            실제경로.append(현재)
        
        return 실제경로
    
    def 전지적_예언(self, 거리행렬, 정점들):
        """전지적 관점에서 그래프 분석"""
        print("🔮 전지적 예언:")
        
        # 가장 먼 거리 찾기
        최대거리 = 0
        최원거리쌍 = None
        
        # 가장 가까운 거리 찾기 (0 제외)
        최소거리 = float('inf')
        최근거리쌍 = None
        
        n = len(정점들)
        for i in range(n):
            for j in range(i+1, n):
                if 거리행렬[i][j] != float('inf'):
                    if 거리행렬[i][j] > 최대거리:
                        최대거리 = 거리행렬[i][j]
                        최원거리쌍 = (정점들[i], 정점들[j])
                    
                    if 거리행렬[i][j] > 0 and 거리행렬[i][j] < 최소거리:
                        최소거리 = 거리행렬[i][j]
                        최근거리쌍 = (정점들[i], 정점들[j])
        
        print(f"   🔥 가장 가까운 연결: {최근거리쌍[0]} ↔ {최근거리쌍[1]} (거리: {최소거리})")
        print(f"   🌌 가장 먼 연결: {최원거리쌍[0]} ↔ {최원거리쌍[1]} (거리: {최대거리})")
        print(f"   📊 네트워크 지름: {최대거리} (가장 먼 두 점 사이의 거리)")
```

---

## 🗺️ 4층 - 최단거리의 미로의 길잡이들

### 🗺️ 다익스트라 웨버 (Dijkstra Weaver) - "최단경로의 직조사"

#### 캐릭터 설정 🗺️
- **클래스**: 경로 직조사 (Path Weaver)
- **정체**: 한 점에서 시작하여 모든 점까지의 최단경로를 실로 엮어내는 예술가 거미
- **별명**: "길의 직조사"
- **성격**: 예술적이고 섬세함, 완벽한 경로를 만들어내는 장인 정신
- **특기**: 다익스트라 알고리즘, 단일 출발점 최단경로
- **철학**: "모든 길은 아름다운 실로 엮을 수 있다"
- **말버릇**: "가장 아름다운 길을 직조하겠다!"
- **무기**: 경로 직조 베틀 (최단경로를 실로 엮어내는 마법 도구)

```python
import heapq

class 다익스트라_웨버:
    def __init__(self):
        print("🗺️ 다익스트라 웨버: '최단경로의 예술가가 등장했다!'")
        self.예술성 = 97
        self.정밀성 = 99
        self.장인정신 = 98
        self.우선순위큐_마법 = True
        
    def 경로_직조_시작(self, 그래프, 시작점):
        """다익스트라 알고리즘으로 최단경로 직조"""
        print(f"🎨 '{시작점}에서 시작하여 모든 점까지의 아름다운 길을 직조하겠다!'")
        
        거리 = {정점: float('inf') for 정점 in 그래프}
        거리[시작점] = 0
        이전정점 = {정점: None for 정점 in 그래프}
        방문완료 = set()
        
        # 우선순위 큐 (거리, 정점)
        미방문큐 = [(0, 시작점)]
        
        print(f"🧵 직조 시작! 시작점 {시작점}에서 실을 뽑아낸다...")
        
        while 미방문큐:
            현재거리, 현재정점 = heapq.heappop(미방문큐)
            
            if 현재정점 in 방문완료:
                continue
                
            방문완료.add(현재정점)
            print(f"   🎯 {현재정점} 도달! (총 거리: {현재거리})")
            
            # 인접한 정점들로 실 확장
            for 다음정점, 가중치 in 그래프.get(현재정점, []):
                if 다음정점 not in 방문완료:
                    새로운거리 = 현재거리 + 가중치
                    
                    if 새로운거리 < 거리[다음정점]:
                        거리[다음정점] = 새로운거리
                        이전정점[다음정점] = 현재정점
                        heapq.heappush(미방문큐, (새로운거리, 다음정점))
                        print(f"      ✨ {다음정점}까지의 실 업데이트: {새로운거리} (via {현재정점})")
        
        print(f"🎉 모든 경로 직조 완료!")
        return 거리, 이전정점
    
    def 경로_추출(self, 목적지, 이전정점):
        """완성된 실에서 특정 경로 추출"""
        print(f"🎨 '{목적지}까지의 아름다운 실 경로를 추출하겠다!'")
        
        경로 = []
        현재 = 목적지
        
        while 현재 is not None:
            경로.append(현재)
            현재 = 이전정점[현재]
        
        경로.reverse()
        print(f"   🧵 완성된 경로: {' → '.join(경로)}")
        return 경로
    
    def 직조_작품_전시(self, 시작점, 거리, 이전정점):
        """완성된 최단경로 작품 전시"""
        print(f"🖼️ '{시작점}에서 출발하는 최단경로 직조 작품 전시!'")
        
        for 목적지, 총거리 in sorted(거리.items()):
            if 총거리 == float('inf'):
                print(f"   🚫 {시작점} → {목적지}: 연결 불가")
            elif 목적지 == 시작점:
                print(f"   🎯 {시작점} → {목적지}: 0 (출발점)")
            else:
                경로 = self.경로_추출(목적지, 이전정점)
                print(f"   🎨 {시작점} → {목적지}: {총거리} 경로: {' → '.join(경로)}")
```

### ⚡ 벨만 워커 (Bellman Walker) - "음수 간선의 전사"

#### 캐릭터 설정 ⚡
- **클래스**: 음수 대응 전사 (Negative Edge Warrior)
- **정체**: 음수 가중치가 있는 험난한 그래프에서도 굴복하지 않는 용감한 거미
- **별명**: "음수의 정복자"
- **성격**: 용감하고 끈질김, 어려운 상황을 두려워하지 않음
- **특기**: 벨만-포드 알고리즘, 음수 사이클 탐지
- **철학**: "음수라도 포기하지 않는다. 불가능도 가능으로 만든다"
- **말버릇**: "음수든 뭐든 상관없어!"
- **무기**: 음수 저항 갑옷 (음수 가중치를 견뎌내는 특수 장비)

```python
class 벨만_워커:
    def __init__(self):
        print("⚡ 벨만 워커: '음수 간선도 두렵지 않는 전사다!'")
        self.용기 = 99
        self.끈기 = 98
        self.음수저항력 = 100
        self.사이클탐지력 = 97
        
    def 음수_간선_정복(self, 그래프, 시작점):
        """벨만-포드 알고리즘으로 음수 간선 정복"""
        print(f"⚔️ '{시작점}에서 시작하여 음수 간선의 세계를 정복하겠다!'")
        
        # 모든 정점과 간선 수집
        모든정점 = set()
        모든간선 = []
        
        for 출발점, 연결들 in 그래프.items():
            모든정점.add(출발점)
            for 도착점, 가중치 in 연결들:
                모든정점.add(도착점)
                모든간선.append((출발점, 도착점, 가중치))
        
        # 거리 초기화
        거리 = {정점: float('inf') for 정점 in 모든정점}
        거리[시작점] = 0
        이전정점 = {정점: None for 정점 in 모든정점}
        
        print(f"🛡️ 음수 저항 갑옷 착용! 총 {len(모든간선)}개의 간선과 맞서겠다!")
        
        # V-1번 반복하여 최단거리 계산
        정점수 = len(모든정점)
        for 라운드 in range(정점수 - 1):
            print(f"\n⚔️ 제{라운드+1}라운드 음수 간선 도전!")
            
            업데이트_발생 = False
            for 출발, 도착, 가중치 in 모든간선:
                if 거리[출발] != float('inf'):
                    새로운거리 = 거리[출발] + 가중치
                    
                    if 새로운거리 < 거리[도착]:
                        거리[도착] = 새로운거리
                        이전정점[도착] = 출발
                        업데이트_발생 = True
                        print(f"   ⚡ {출발} → {도착}: {거리[도착]} 업데이트! (가중치: {가중치})")
            
            if not 업데이트_발생:
                print(f"   ✅ 제{라운드+1}라운드에서 더 이상 개선 없음. 조기 종료!")
                break
        
        # 음수 사이클 탐지
        print(f"\n🔍 음수 사이클 탐지 중...")
        음수사이클 = self.음수_사이클_탐지(모든간선, 거리)
        
        if 음수사이클:
            print(f"⚠️ 음수 사이클 발견! 최단거리 계산 불가!")
            return None, None, 음수사이클
        else:
            print(f"✅ 음수 사이클 없음! 안전한 그래프!")
            return 거리, 이전정점, None
    
    def 음수_사이클_탐지(self, 모든간선, 거리):
        """음수 사이클 탐지"""
        for 출발, 도착, 가중치 in 모든간선:
            if 거리[출발] != float('inf'):
                새로운거리 = 거리[출발] + 가중치
                
                if 새로운거리 < 거리[도착]:
                    print(f"   💥 음수 사이클 발견: {출발} → {도착} (가중치: {가중치})")
                    return True
        return False
    
    def 전사의_보고서(self, 시작점, 거리, 이전정점):
        """벨만-포드 결과 보고"""
        print(f"📋 전사의 정복 보고서 ({시작점}에서 출발):")
        
        for 목적지, 총거리 in sorted(거리.items()):
            if 총거리 == float('inf'):
                print(f"   🚫 {시작점} → {목적지}: 도달 불가")
            elif 목적지 == 시작점:
                print(f"   🎯 {시작점} → {목적지}: 0 (출발점)")
            else:
                print(f"   ⚔️ {시작점} → {목적지}: {총거리}")
```

---

## 🌳 5층 - 최소연결의 숲의 건축가들

### 🌳 크루스칼 빌더 (Kruskal Builder) - "간선 중심 건축가"

#### 캐릭터 설정 🌳
- **클래스**: 간선 중심 건축가 (Edge-Focused Architect)
- **정체**: 모든 간선을 비용 순으로 정렬하여 최적의 네트워크를 건설하는 체계적인 거미
- **별명**: "간선의 건축가"
- **성격**: 매우 체계적이고 논리적, 전체를 조망하는 시각
- **특기**: 크루스칼 알고리즘, Union-Find 자료구조 활용
- **철학**: "가장 저렴한 재료부터 사용하되, 순환은 만들지 않는다"
- **말버릇**: "가장 싼 것부터 골라보자!"
- **무기**: 비용 정렬 도구 (모든 간선을 비용순으로 자동 정렬)

```python
class 크루스칼_빌더:
    def __init__(self):
        print("🌳 크루스칼 빌더: '간선 중심의 체계적 건축가다!'")
        self.체계성 = 99
        self.논리성 = 98
        self.경제성 = 97
        self.정렬_마법 = True
        
    def 최소신장트리_건설(self, 정점들, 간선들):
        """크루스칼 알고리즘으로 MST 건설"""
        print(f"🏗️ '총 {len(간선들)}개의 간선으로 최소 비용 네트워크를 건설하겠다!'")
        
        # Union-Find 자료구조 초기화
        부모 = {정점: 정점 for 정점 in 정점들}
        랭크 = {정점: 0 for 정점 in 정점들}
        
        def find(x):
            if 부모[x] != x:
                부모[x] = find(부모[x])  # 경로 압축
            return 부모[x]
        
        def union(x, y):
            루트x = find(x)
            루트y = find(y)
            
            if 루트x == 루트y:
                return False  # 이미 같은 집합
            
            # 랭크에 따른 union
            if 랭크[루트x] < 랭크[루트y]:
                부모[루트x] = 루트y
            elif 랭크[루트x] > 랭크[루트y]:
                부모[루트y] = 루트x
            else:
                부모[루트y] = 루트x
                랭크[루트x] += 1
            
            return True
        
        # 1단계: 간선들을 비용 순으로 정렬
        정렬된_간선들 = sorted(간선들, key=lambda x: x[2])
        print(f"📊 간선들을 비용 순으로 정렬:")
        for 시작, 끝, 비용 in 정렬된_간선들:
            print(f"   💰 {시작} ↔ {끝}: {비용}")
        
        print(f"\n🔨 건설 시작! 가장 저렴한 간선부터 검토...")
        
        선택된_간선들 = []
        총_비용 = 0
        
        for 시작, 끝, 비용 in 정렬된_간선들:
            print(f"\n   🔍 {시작} ↔ {끝} (비용: {비용}) 검토 중...")
            
            if find(시작) != find(끝):
                # 사이클을 만들지 않음 -> 채택!
                union(시작, 끝)
                선택된_간선들.append((시작, 끝, 비용))
                총_비용 += 비용
                print(f"   ✅ 채택! 누적 비용: {총_비용}")
                
                # MST 완성 조건: 간선 수 = 정점 수 - 1
                if len(선택된_간선들) == len(정점들) - 1:
                    print(f"   🎉 MST 완성! (간선 {len(선택된_간선들)}개)")
                    break
            else:
                print(f"   ❌ 거절! (사이클 생성 위험)")
        
        print(f"\n🏗️ 건설 완료!")
        print(f"   📊 선택된 간선: {len(선택된_간선들)}개")
        print(f"   💰 총 건설 비용: {총_비용}")
        
        return 선택된_간선들, 총_비용
    
    def 건설_결과_분석(self, 정점들, 선택된_간선들, 총_비용):
        """건설 결과 상세 분석"""
        print(f"📋 크루스칼 건축가의 건설 보고서:")
        print(f"   🏘️ 연결된 정점: {len(정점들)}개")
        print(f"   🛤️ 사용된 간선: {len(선택된_간선들)}개")
        print(f"   💰 총 건설 비용: {총_비용}")
        print(f"   📊 평균 간선 비용: {총_비용/len(선택된_간선들):.2f}")
        
        print(f"\n🛤️ 선택된 간선 목록:")
        for i, (시작, 끝, 비용) in enumerate(선택된_간선들, 1):
            print(f"   {i}. {시작} ↔ {끝}: {비용}")
        
        # 연결성 확인
        if len(선택된_간선들) == len(정점들) - 1:
            print(f"   ✅ 완벽한 신장트리! 모든 정점이 연결됨")
        else:
            print(f"   ⚠️ 불완전한 연결 (일부 정점이 분리되어 있음)")
```

### 🌿 프림 가드너 (Prim Gardner) - "정점 중심 정원사"

#### 캐릭터 설정 🌿
- **클래스**: 정점 중심 정원사 (Vertex-Focused Gardener)
- **정체**: 하나의 씨앗에서 시작하여 점진적으로 아름다운 네트워크 정원을 가꾸는 거미
- **별명**: "정원의 가드너"
- **성격**: 인내심 있고 섬세함, 점진적 성장을 중시
- **특기**: 프림 알고리즘, 우선순위 큐 활용한 점진적 확장
- **철학**: "좋은 정원은 하나의 씨앗에서 천천히 자란다"
- **말버릇**: "한 뿌리씩 정성스럽게 키워보자!"
- **무기**: 성장 우선순위 호수 (가장 가까운 정점부터 키우는 마법 도구)

```python
import heapq

class 프림_가드너:
    def __init__(self):
        print("🌿 프림 가드너: '정점 중심의 정성스러운 정원사다!'")
        self.인내심 = 98
        self.섬세함 = 97
        self.정성 = 99
        self.우선순위큐_마법 = True
        
    def 정원_가꾸기_시작(self, 그래프, 시작정점=None):
        """프림 알고리즘으로 MST 정원 가꾸기"""
        모든정점 = set()
        간선정보 = {}
        
        # 그래프 정보 수집
        for 정점, 연결들 in 그래프.items():
            모든정점.add(정점)
            간선정보[정점] = 연결들
            for 다음정점, _ in 연결들:
                모든정점.add(다음정점)
        
        if not 시작정점:
            시작정점 = next(iter(모든정점))
        
        print(f"🌱 '{시작정점}'에서 시작하여 아름다운 정원을 가꾸겠다!")
        
        # 프림 알고리즘 초기화
        정원에_포함됨 = set([시작정점])
        선택된_간선들 = []
        총_비용 = 0
        
        # 우선순위 큐: (비용, 시작정점, 끝정점)
        후보_간선들 = []
        
        # 시작 정점의 모든 간선을 후보에 추가
        for 다음정점, 비용 in 간선정보.get(시작정점, []):
            if 다음정점 not in 정원에_포함됨:
                heapq.heappush(후보_간선들, (비용, 시작정점, 다음정점))
        
        print(f"🌿 정원 가꾸기 시작! 첫 씨앗 {시작정점} 식재 완료")
        
        while 후보_간선들 and len(정원에_포함됨) < len(모든정점):
            비용, 시작, 끝 = heapq.heappop(후보_간선들)
            
            # 이미 정원에 포함된 정점이면 스킵
            if 끝 in 정원에_포함됨:
                print(f"   ⏭️ {시작} ↔ {끝} (비용: {비용}) 스킵 (이미 정원에 있음)")
                continue
            
            # 새로운 정점을 정원에 추가
            정원에_포함됨.add(끝)
            선택된_간선들.append((시작, 끝, 비용))
            총_비용 += 비용
            
            print(f"   🌸 {끝} 정점 추가! (via {시작}, 비용: {비용}) 정원 크기: {len(정원에_포함됨)}")
            
            # 새로 추가된 정점에서 뻗어나가는 간선들을 후보에 추가
            for 다음정점, 간선비용 in 간선정보.get(끝, []):
                if 다음정점 not in 정원에_포함됨:
                    heapq.heappush(후보_간선들, (간선비용, 끝





                        def 최소컷_분석(self, 용량그래프, 유량그래프, 소스):
        """최대유량-최소컷 정리 검증"""
        print(f"\n🔪 최소컷 분석 (최대유량-최소컷 정리 검증)")
        
        # 잔여 그래프에서 소스에서 도달 가능한 정점들 찾기
        도달가능한_정점들 = set()
        방문큐 = deque([소스])
        도달가능한_정점들.add(소스)
        
        while 방문큐:
            현재 = 방문큐.popleft()
            
            for 다음정점, 용량 in 용량그래프.get(현재, {}).items():
                잔여용량 = 용량 - 유량그래프[현재][다음정점]
                
                if 다음정점 not in 도달가능한_정점들 and 잔여용량 > 0:
                    도달가능한_정점들.add(다음정점)
                    방문큐.append(다음정점)
        
        # 최소컷 간선들과 용량 계산
        최소컷_간선들 = []
        최소컷_용량 = 0
        
        for 시작 in 도달가능한_정점들:
            for 끝, 용량 in 용량그래프.get(시작, {}).items():
                if 끝 not in 도달가능한_정점들:
                    최소컷_간선들.append((시작, 끝, 용량))
                    최소컷_용량 += 용량
        
        print(f"   🎯 소스측 정점들: {sorted(도달가능한_정점들)}")
        print(f"   🎯 싱크측 정점들: {sorted(set(용량그래프.keys()) - 도달가능한_정점들)}")
        print(f"\n   🔪 최소컷 간선들:")
        for 시작, 끝, 용량 in 최소컷_간선들:
            print(f"      {시작} → {끝}: 용량 {용량}")
        print(f"   📊 최소컷 용량: {최소컷_용량}")
        
        return 최소컷_용량, 최소컷_간선들
    
    def 유량_분석_보고서(self, 최대유량, 경로들, 최소컷_용량):
        """포드 플로워의 유량 분석 보고서"""
        print(f"\n📋 포드 플로워의 유량 분석 보고서:")
        print(f"   🌊 최대유량: {최대유량}")
        print(f"   🔪 최소컷 용량: {최소컷_용량}")
        
        if 최대유량 == 최소컷_용량:
            print(f"   ✅ 최대유량-최소컷 정리 검증 성공!")
        else:
            print(f"   ❌ 계산 오류 발생!")
        
        print(f"\n🛤️ 사용된 증강 경로들:")
        총_흐름 = 0
        for i, (경로, 용량) in enumerate(경로들, 1):
            print(f"   {i}. {' → '.join(경로)}: 유량 {용량}")
            총_흐름 += 용량
        
        print(f"   📊 총 흐름량: {총_흐름} (최대유량과 일치: {'✅' if 총_흐름 == 최대유량 else '❌'})")
    
    def 실용적_응용_사례(self):
        """최대유량 문제의 실용적 응용 사례"""
        print(f"\n🌟 최대유량 문제의 실용적 응용:")
        
        응용사례들 = [
            "🚰 상수도 시스템: 최대 물 공급량 계산",
            "🛣️ 교통 네트워크: 최대 교통량 분석",
            "📡 통신 네트워크: 최대 데이터 전송량",
            "⚡ 전력 그리드: 최대 전력 공급 용량",
            "🏭 생산 라인: 최대 생산 능력 분석",
            "💰 자금 흐름: 최대 투자 가능 금액",
            "🎮 게임 AI: 최적 자원 분배 전략",
            "🧬 생물학: 최대 물질 전달 속도"
        ]
        
        for 사례 in 응용사례들:
            print(f"   • {사례}")
        
        print(f"\n💡 최대유량 알고리즘의 가치:")
        print(f"   ✅ 네트워크 용량의 한계 파악")
        print(f"   ✅ 병목 구간(최소컷) 식별")
        print(f"   ✅ 효율적인 자원 배분")
        print(f"   ✅ 시스템 최적화 방안 도출")
```
       print(f"      🌱 후보 추가: {끝} ↔ {다음정점} (비용: {간선비용})")
        
        print(f"\n🎉 아름다운 MST 정원 완성!")
        return 선택된_간선들, 총_비용, 정원에_포함됨
    
    def 정원_감상_시간(self, 선택된_간선들, 총_비용, 정원정점들):
        """완성된 정원 감상 및 분석"""
        print(f"🌺 프림 가드너의 정원 감상 시간:")
        print(f"   🌿 정원 규모: {len(정원정점들)}개 정점")
        print(f"   🌸 연결 간선: {len(선택된_간선들)}개")
        print(f"   💰 총 조성 비용: {총_비용}")
        
        if 선택된_간선들:
            평균비용 = 총_비용 / len(선택된_간선들)
            print(f"   📊 평균 간선 비용: {평균비용:.2f}")
            
            최저비용간선 = min(선택된_간선들, key=lambda x: x[2])
            최고비용간선 = max(선택된_간선들, key=lambda x: x[2])
            
            print(f"   🌱 가장 저렴한 연결: {최저비용간선[0]} ↔ {최저비용간선[1]} (비용: {최저비용간선[2]})")
            print(f"   🌺 가장 비싼 연결: {최고비용간선[0]} ↔ {최고비용간선[1]} (비용: {최고비용간선[2]})")
        
        print(f"\n🌿 정원 구성 상세:")
        for i, (시작, 끝, 비용) in enumerate(선택된_간선들, 1):
            print(f"   {i}. {시작} ↔ {끝}: {비용} (성장 순서 {i})")
    
    def 크루스칼과_비교분석(self, 크루스칼_결과, 프림_결과):
        """크루스칼 방식과 비교 분석"""
        크루스칼_간선들, 크루스칼_비용 = 크루스칼_결과
        프림_간선들, 프림_비용, _ = 프림_결과
        
        print(f"\n📊 건축가 vs 정원사 비교 분석:")
        print(f"   🌳 크루스칼 (간선 중심): 비용 {크루스칼_비용}")
        print(f"   🌿 프림 (정점 중심): 비용 {프림_비용}")
        
        if 크루스칼_비용 == 프림_비용:
            print(f"   ✅ 동일한 최적 비용! 두 방법 모두 완벽!")
        else:
            print(f"   ⚠️ 비용 차이 발생 (구현 확인 필요)")
        
        # 선택된 간선들 비교
        크루스칼_간선집합 = set(크루스칼_간선들)
        프림_간선집합 = set(프림_간선들)
        
        공통_간선들 = 크루스칼_간선집합.intersection(프림_간선집합)
        print(f"   🤝 공통으로 선택된 간선: {len(공통_간선들)}개")
        
        if len(공통_간선들) == len(크루스칼_간선들):
            print(f"   🎯 완전히 동일한 MST 선택!")
        else:
            print(f"   🔀 다른 MST 선택 (여러 최적해 존재)")
```

---

## 📐 6층 - 위상정렬의 계단의 질서 관리자

### 📐 토포 소터 (Topo Sorter) - "질서정연한 안내자"

#### 캐릭터 설정 📐
- **클래스**: 질서 정립자 (Order Establisher)
- **정체**: 복잡한 의존성 관계를 명확한 순서로 정리하는 완벽주의 거미
- **별명**: "순서의 마에스트로"
- **성격**: 매우 질서정연하고 체계적, 혼돈을 참지 못함
- **특기**: 위상정렬, 의존성 해결, 순서 정립
- **철학**: "모든 혼돈에는 올바른 순서가 있다"
- **말버릇**: "차례차례 정리해보자!"
- **무기**: 의존성 분석 나침반 (복잡한 관계를 순서대로 정리)

```python
from collections import deque, defaultdict

class 토포_소터:
    def __init__(self):
        print("📐 토포 소터: '질서와 체계를 사랑하는 안내자다!'")
        self.질서성 = 100
        self.체계성 = 99
        self.완벽주의 = 98
        self.의존성분석력 = 97
        
    def 의존성_분석_시작(self, 그래프):
        """방향 그래프의 의존성 분석"""
        print("🔍 '복잡한 의존성 관계를 분석해보자!'")
        
        # 진입차수(in-degree) 계산
        진입차수 = defaultdict(int)
        모든정점 = set()
        
        # 모든 정점 수집
        for 시작점, 연결들 in 그래프.items():
            모든정점.add(시작점)
            for 끝점 in 연결들:
                모든정점.add(끝점)
        
        # 진입차수 초기화
        for 정점 in 모든정점:
            진입차수[정점] = 0
        
        # 진입차수 계산
        for 시작점, 연결들 in 그래프.items():
            for 끝점 in 연결들:
                진입차수[끝점] += 1
        
        print("📊 의존성 분석 결과:")
        for 정점, 차수 in sorted(진입차수.items()):
            if 차수 == 0:
                print(f"   🌟 {정점}: 진입차수 {차수} (독립적, 선수조건 없음)")
            else:
                print(f"   📋 {정점}: 진입차수 {차수} (의존성 {차수}개)")
        
        return 진입차수, 모든정점
    
    def 위상정렬_실행(self, 그래프):
        """칸의 알고리즘으로 위상정렬"""
        print("\n📐 '위상정렬을 시작하겠다! 질서 있는 순서를 만들어보자!'")
        
        진입차수, 모든정점 = self.의존성_분석_시작(그래프)
        
        # 진입차수가 0인 정점들부터 시작
        시작가능한_정점들 = deque()
        for 정점, 차수 in 진입차수.items():
            if 차수 == 0:
                시작가능한_정점들.append(정점)
        
        정렬된_순서 = []
        처리단계 = 0
        
        print(f"\n🎯 위상정렬 과정:")
        
        while 시작가능한_정점들:
            처리단계 += 1
            현재단계_처리 = []
            
            # 현재 단계에서 처리할 수 있는 모든 정점 처리
            다음단계_큐 = deque()
            
            while 시작가능한_정점들:
                현재정점 = 시작가능한_정점들.popleft()
                정렬된_순서.append(현재정점)
                현재단계_처리.append(현재정점)
                
                print(f"   {처리단계}단계: {현재정점} 처리")
                
                # 현재 정점에 의존하던 정점들의 진입차수 감소
                for 다음정점 in 그래프.get(현재정점, []):
                    진입차수[다음정점] -= 1
                    print(f"      📉 {다음정점}의 의존성 감소: {진입차수[다음정점]+1} → {진입차수[다음정점]}")
                    
                    if 진입차수[다음정점] == 0:
                        다음단계_큐.append(다음정점)
                        print(f"      🌟 {다음정점} 다음 단계 처리 가능!")
            
            시작가능한_정점들 = 다음단계_큐
            print(f"   ✅ {처리단계}단계 완료: {현재단계_처리}")
        
        # 사이클 검증
        if len(정렬된_순서) != len(모든정점):
            남은정점들 = 모든정점 - set(정렬된_순서)
            print(f"\n❌ 위상정렬 실패! 순환 의존성 발견!")
            print(f"   🔄 순환에 연루된 정점들: {남은정점들}")
            return None
        
        print(f"\n🎉 위상정렬 성공!")
        print(f"   📋 정렬된 순서: {' → '.join(정렬된_순서)}")
        return 정렬된_순서
    
    def 실생활_예시_분석(self):
        """실생활 의존성 문제 해결 예시"""
        print(f"\n📚 실생활 예시: 대학교 수강신청 문제")
        
        과목_의존성 = {
            "수학1": ["수학2", "물리1"],
            "수학2": ["자료구조", "알고리즘"],
            "물리1": ["물리2"],
            "컴개론": ["자료구조"],
            "자료구조": ["알고리즘", "데이터베이스"],
            "알고리즘": [],
            "물리2": [],
            "데이터베이스": []
        }
        
        print("🎓 과목별 선수과목 관계:")
        for 과목, 후수과목들 in 과목_의존성.items():
            if 후수과목들:
                print(f"   📖 {과목} → {후수과목들}")
            else:
                print(f"   🎯 {과목} (최종 과목)")
        
        수강순서 = self.위상정렬_실행(과목_의존성)
        
        if 수강순서:
            print(f"\n📅 추천 수강 순서:")
            for 학기, 과목 in enumerate(수강순서, 1):
                print(f"   {학기}학기: {과목}")
        
        return 수강순서
    
    def 순서_유효성_검증(self, 그래프, 제안된_순서):
        """제안된 순서가 올바른 위상정렬인지 검증"""
        print(f"\n🔍 순서 유효성 검증: {' → '.join(제안된_순서)}")
        
        위치 = {정점: i for i, 정점 in enumerate(제안된_순서)}
        
        for 시작점, 연결들 in 그래프.items():
            for 끝점 in 연결들:
                if 시작점 in 위치 and 끝점 in 위치:
                    if 위치[시작점] >= 위치[끝점]:
                        print(f"   ❌ 순서 오류: {시작점} → {끝점} (역순 배치)")
                        return False
                    else:
                        print(f"   ✅ 올바른 순서: {시작점} → {끝점}")
        
        print(f"   🎉 완벽한 위상정렬!")
        return True
```

---

## 🔗 7층 - 강연결 요새의 연결 마스터

### 🔗 타잔 링커 (Tarjan Linker) - "강연결의 수호자"

#### 캐릭터 설정 🔗
- **클래스**: 강연결 수호자 (Strong Connection Guardian)
- **정체**: 그래프에서 진정으로 강하게 연결된 구성요소를 찾아내는 전문가 거미
- **별명**: "강력한 유대의 수호자"
- **성격**: 깊이 있고 철학적, 진정한 연결의 의미를 추구
- **특기**: 타잔 알고리즘, 강연결요소 분해
- **철학**: "진정한 연결은 서로에게 도달할 수 있을 때만 완성된다"
- **말버릇**: "강한 연결을 찾아보자!"
- **무기**: 강연결 탐지 레이더 (상호 연결된 구조를 감지)

```python
class 타잔_링커:
    def __init__(self):
        print("🔗 타잔 링커: '강연결의 비밀을 밝혀내는 수호자다!'")
        self.철학성 = 99
        self.깊이 = 98
        self.연결감지력 = 100
        self.탐지레이더 = True
        
        # 타잔 알고리즘용 변수들
        self.시간 = 0
        self.스택 = []
        self.스택에있음 = set()
        self.방문시간 = {}
        self.낮은연결 = {}
        self.강연결요소들 = []
    
    def 강연결요소_탐지_시작(self, 그래프):
        """타잔 알고리즘으로 강연결요소 탐지"""
        print("🔍 '진정한 강연결 구조를 찾아보자!'")
        
        # 초기화
        self.시간 = 0
        self.스택 = []
        self.스택에있음 = set()
        self.방문시간 = {}
        self.낮은연결 = {}
        self.강연결요소들 = []
        
        # 모든 정점에 대해 DFS 실행
        for 정점 in 그래프:
            if 정점 not in self.방문시간:
                print(f"\n🎯 {정점}에서 새로운 탐지 시작!")
                self.타잔_DFS(정점, 그래프)
        
        print(f"\n🎉 강연결요소 탐지 완료!")
        print(f"   📊 발견된 강연결요소: {len(self.강연결요소들)}개")
        
        return self.강연결요소들
    
    def 타잔_DFS(self, 현재정점, 그래프):
        """타잔 알고리즘의 DFS 구현"""
        # 현재 정점 초기화
        self.방문시간[현재정점] = self.시간
        self.낮은연결[현재정점] = self.시간
        self.시간 += 1
        self.스택.append(현재정점)
        self.스택에있음.add(현재정점)
        
        print(f"   🔍 {현재정점} 방문 (시간: {self.방문시간[현재정점]})")
        
        # 인접 정점들 탐색
        for 다음정점 in 그래프.get(현재정점, []):
            if 다음정점 not in self.방문시간:
                # 아직 방문하지 않은 정점
                print(f"      ➡️ {다음정점} 새로 탐색")
                self.타잔_DFS(다음정점, 그래프)
                self.낮은연결[현재정점] = min(self.낮은연결[현재정점], 
                                           self.낮은연결[다음정점])
            elif 다음정점 in self.스택에있음:
                # 스택에 있는 정점 (같은 SCC)
                print(f"      🔄 {다음정점} 역방향 간선 (강연결 가능성)")
                self.낮은연결[현재정점] = min(self.낮은연결[현재정점], 
                                           self.방문시간[다음정점])
        
        # 강연결요소의 루트인지 확인
        if self.낮은연결[현재정점] == self.방문시간[현재정점]:
            # 새로운 강연결요소 발견!
            새로운_SCC = []
            
            print(f"      🎯 {현재정점}: 강연결요소 루트 발견!")
            
            while True:
                정점 = self.스택.pop()
                self.스택에있음.remove(정점)
                새로운_SCC.append(정점)
                
                if 정점 == 현재정점:
                    break
            
            self.강연결요소들.append(새로운_SCC)
            print(f"      ✨ 강연결요소 #{len(self.강연결요소들)}: {새로운_SCC}")
    
    def 강연결_분석_보고서(self, 그래프, 강연결요소들):
        """강연결요소 분석 결과 보고"""
        print(f"\n📋 타잔 링커의 강연결 분석 보고서:")
        
        전체정점수 = len([정점 for 정점 in 그래프])
        SCC수 = len(강연결요소들)
        
        print(f"   🏗️ 전체 정점 수: {전체정점수}개")
        print(f"   🔗 강연결요소 수: {SCC수}개")
        
        if SCC수 == 1:
            print(f"   🎉 단일 강연결 그래프! (모든 정점이 서로 도달 가능)")
        elif SCC수 == 전체정점수:
            print(f"   📊 완전 분리 그래프 (강연결 구조 없음)")
        else:
            print(f"   🔀 혼합 구조 그래프 (부분적 강연결)")
        
        print(f"\n🔗 강연결요소 상세 분석:")
        for i, SCC in enumerate(강연결요소들, 1):
            크기 = len(SCC)
            if 크기 == 1:
                print(f"   {i}. 단일 정점: {SCC[0]}")
            else:
                print(f"   {i}. 강연결 그룹 (크기 {크기}): {SCC}")
                print(f"      💪 상호 도달 가능한 {크기}개 정점들")
        
        # 가장 큰 강연결요소 찾기
        최대_SCC = max(강연결요소들, key=len)
        if len(최대_SCC) > 1:
            print(f"\n👑 가장 강력한 연결 그룹: {최대_SCC} (크기: {len(최대_SCC)})")
    
    def 실용적_응용_예시(self):
        """강연결요소의 실용적 응용 예시"""
        print(f"\n🌟 강연결요소의 실용적 응용:")
        
        응용예시들 = [
            "📱 소셜 네트워크: 서로 팔로우하는 강한 커뮤니티 발견",
            "🌐 웹 페이지: 서로 링크하는 웹사이트 클러스터 탐지",
            "💰 금융 네트워크: 상호 거래 관계가 강한 기업 그룹 분석",
            "🚗 교통 시스템: 양방향 이동 가능한 도로 구간 파악",
            "🧬 생물학: 상호 작용하는 단백질 복합체 식별",
            "🔄 의존성 분석: 순환 의존성이 있는 모듈 그룹 발견"
        ]
        
        print("   실제 활용 분야:")
        for 응용 in 응용예시들:
            print(f"   • {응용}")
        
        print(f"\n💡 강연결요소를 알면:")
        print(f"   ✅ 네트워크의 핵심 구조 파악")
        print(f"   ✅ 영향력이 강한 그룹 식별")
        print(f"   ✅ 시스템의 취약점 분석")
        print(f"   ✅ 효율적인 분할 전략 수립")
```

---

## 🌌 8층 - 네트워크 플로우의 바다의 흐름 제어자

### 🌊 포드 플로워 (Ford Flower) - "최대유량의 마스터"

#### 캐릭터 설정 🌊
- **클래스**: 유량 제어자 (Flow Controller)
- **정체**: 네트워크를 통해 흐르는 최대 유량을 계산하고 제어하는 수력학 전문가 거미
- **별명**: "흐름의 마스터"
- **성격**: 유연하고 적응력이 강함, 물처럼 흘러가는 성격
- **특기**: 포드-풀커슨 알고리즘, 최대유량-최소컷 정리
- **철학**: "막힌 길이 있으면 다른 길을 찾는다. 흐름은 항상 길을 만든다"
- **말버릇**: "흐름을 따라가보자!"
- **무기**: 유량 제어 수문 (네트워크의 흐름을 자유자재로 조절)

```python
from collections import defaultdict, deque

class 포드_플로워:
    def __init__(self):
        print("🌊 포드 플로워: '유량과 흐름의 마스터가 등장했다!'")
        self.유연성 = 98
        self.적응력 = 99
        self.흐름감지력 = 100
        self.수문제어력 = 97
        
    def 네트워크_유량_분석(self, 용량그래프, 소스, 싱크):
        """포드-풀커슨 알고리즘으로 최대유량 계산"""
        print(f"🌊 '{소스}에서 {싱크}로의 최대 유량을 분석하겠다!'")
        
        # 유량 그래프 초기화 (모든 유량을 0으로)
        유량그래프 = defaultdict(lambda: defaultdict(int))
        최대유량 = 0
        경로들 = []
        
        print(f"💧 네트워크 용량 정보:")
        for 시작, 연결들 in 용량그래프.items():
            for 끝, 용량 in 연결들.items():
                print(f"   {시작} → {끝}: 용량 {용량}")
        
        라운드 = 0
        while True:
            라운드 += 1
            print(f"\n🔄 제{라운드}라운드: 증강 경로 탐색")
            
            # BFS로 증강 경로 찾기
            증강경로, 경로용량 = self.증강경로_찾기(용량그래프, 유량그래프, 소스, 싱크)
            
            if not 증강경로:
                print(f"   ❌ 더 이상 증강 경로 없음. 최대유량 달성!")
                break
            
            print(f"   ✅ 증강 경로 발견: {' → '.join(증강경로)}")
            print(f"   💧 경로 용량: {경로용량}")
            
            # 증강 경로를 따라 유량 증가
            for i in range(len(증강경로) - 1):
                시작 = 증강경로[i]
                끝 = 증강경로[i + 1]
                유량그래프[시작][끝] += 경로용량
                유량그래프[끝][시작] -= 경로용량  # 역방향 유량
            
            최대유량 += 경로용량
            경로들.append((증강경로.copy(), 경로용량))
            
            print(f"   📈 누적 최대유량: {최대유량}")
        
        print(f"\n🎉 최대유량 계산 완료!")
        print(f"   🌊 최대유량: {최대유량}")
        print(f"   📊 사용된 증강 경로: {len(경로들)}개")
        
        return 최대유량, 유량그래프, 경로들
    
    def 증강경로_찾기(self, 용량그래프, 유량그래프, 소스, 싱크):
        """BFS로 소스에서 싱크까지의 증강 경로 찾기"""
        부모 = {소스: None}
        방문큐 = deque([소스])
        
        while 방문큐:
            현재 = 방문큐.popleft()
            
            # 인접 정점들 탐색
            for 다음정점, 용량 in 용량그래프.get(현재, {}).items():
                # 잔여 용량이 있고 아직 방문하지 않은 정점
                잔여용량 = 용량 - 유량그래프[현재][다음정점]
                
                if 다음정점 not in 부모 and 잔여용량 > 0:
                    부모[다음정점] = 현재
                    방문큐.append(다음정점)
                    
                    if 다음정점 == 싱크:
                        # 싱크에 도달! 경로 재구성
                        경로 = []
                        현재점 = 싱크
                        경로용량 = float('inf')
                        
                        while 현재점 is not None:
                            경로.append(현재점)
                            if 부모[현재점] is not None:
                                이전점 = 부모[현재점]
                                간선용량 = 용량그래프[이전점][현재점]
                                현재유량 = 유량그래프[이전점][현재점]
                                잔여 = 간선용량 - 현재유량
                                경로용량 = min(경로용량, 잔여)
                            현재점 = 부모[현재점]
                        
                        경로.reverse()
                        return 경로, 경로용량
        
        return None, 0  # 증강 경로 없음
    
    def 최소컷_분석(self, 용량그래프, 유량그래프, 소스):
        """최대유량-최소컷 정리 검증"""
        print(f"\n🔪 최소컷# 🕷️ 그래프 거미 미궁 캐릭터 대도감: 네트워크의 지배자들

---
## 👑 9층 - 웹 마스터의 방의 최종 보스들

### 🕷️ 그래프 퀸 (Graph Queen) - "모든 알고리즘의 여왕"

#### 캐릭터 설정 👑
- **클래스**: 최종 보스 (Final Boss)
- **정체**: 모든 그래프 알고리즘을 완벽하게 마스터한 거미 미궁의 절대 지배자
- **별명**: "네트워크의 여제"
- **성격**: 우아하고 지적이지만 압도적, 모든 것을 꿰뚫어 보는 통찰력
- **특기**: 모든 그래프 알고리즘 통합 운용, 복합 문제 해결
- **철학**: "모든 연결은 하나의 거대한 그림의 일부다"
- **말버릇**: "모든 길이 나에게 통한다!"
- **무기**: 전지전능 네트워크 크라운 (모든 알고리즘을 동시에 구사)

```python
class 그래프_퀸:
    def __init__(self):
        print("👑 그래프 퀸: '모든 네트워크를 지배하는 여왕이 강림했다!'")
        self.지배력 = 100
        self.통찰력 = 100
        self.우아함 = 99
        self.압도적_존재감 = 100
        
        # 모든 하위 알고리즘 마스터들을 휘하에 둠
        self.휘하_알고리즘들 = {
            "기본_탐색": ["DFS", "BFS", "사이클_탐지"],
            "최단경로": ["다익스트라", "벨만포드", "플로이드워셜"],
            "신장트리": ["크루스칼", "프림"],
            "위상정렬": ["칸", "DFS_기반"],
            "강연결": ["타잔", "코사라주"],
            "네트워크플로우": ["포드풀커슨", "에드몬드카프", "디닉"]
        }
    
    def 여왕의_종합_분석(self, 그래프, 분석_요청들):
        """그래프 퀸의 종합적인 네트워크 분석"""
        print("👑 '짐이 직접 이 네트워크를 분석해주겠다!'")
        print("   '모든 관점에서 완벽한 분석을 제공하리라!'")
        
        분석결과 = {
            "기본_구조": self.기본_구조_분석(그래프),
            "연결성_분석": self.연결성_분석(그래프),
            "경로_분석": None,
            "효율성_분석": None,
            "안정성_분석": None,
            "최적화_제안": []
        }
        
        print("\n👑 여왕의 종합 분석 보고서:")
        
        # 기본 구조 분석
        print(f"📊 기본 구조:")
        기본정보 = 분석결과["기본_구조"]
        print(f"   • 정점 수: {기본정보['정점수']}개")
        print(f"   • 간선 수: {기본정보['간선수']}개")
        print(f"   • 밀도: {기본정보['밀도']:.3f}")
        print(f"   • 그래프 타입: {기본정보['타입']}")
        
        # 연결성 분석
        print(f"\n🔗 연결성 분석:")
        연결정보 = 분석결과["연결성_분석"]
        print(f"   • 연결 컴포넌트: {연결정보['컴포넌트수']}개")
        if 연결정보["강연결요소수"]:
            print(f"   • 강연결요소: {연결정보['강연결요소수']}개")
        
        return 분석결과
    
    def 기본_구조_분석(self, 그래프):
        """기본적인 그래프 구조 분석"""
        정점들 = set()
        간선수 = 0
        방향성 = False
        
        for 시작, 연결들 in 그래프.items():
            정점들.add(시작)
            if isinstance(연결들, list):
                간선수 += len(연결들)
                정점들.update(연결들)
            elif isinstance(연결들, dict):
                간선수 += len(연결들)
                정점들.update(연결들.keys())
                방향성 = True
        
        정점수 = len(정점들)
        최대간선수 = 정점수 * (정점수 - 1)
        if not 방향성:
            간선수 //= 2  # 무방향 그래프는 중복 계산 제거
            최대간선수 //= 2
        
        밀도 = 간선수 / 최대간선수 if 최대간선수 > 0 else 0
        
        그래프타입 = "방향 그래프" if 방향성 else "무방향 그래프"
        if 밀도 > 0.7:
            그래프타입 += " (조밀한)"
        elif 밀도 < 0.3:
            그래프타입 += " (희소한)"
        else:
            그래프타입 += " (중간 밀도)"
        
        return {
            "정점수": 정점수,
            "간선수": 간선수,
            "밀도": 밀도,
            "타입": 그래프타입,
            "방향성": 방향성
        }
    
    def 연결성_분석(self, 그래프):
        """연결성 관련 종합 분석"""
        # 연결 컴포넌트 수 계산 (간단한 DFS)
        방문됨 = set()
        컴포넌트수 = 0
        
        def dfs(정점):
            if 정점 in 방문됨:
                return
            방문됨.add(정점)
            연결들 = 그래프.get(정점, [])
            if isinstance(연결들, dict):
                연결들 = 연결들.keys()
            for 다음정점 in 연결들:
                dfs(다음정점)
        
        for 정점 in 그래프:
            if 정점 not in 방문됨:
                컴포넌트수 += 1
                dfs(정점)
        
        결과 = {"컴포넌트수": 컴포넌트수}
        
        # 방향 그래프라면 강연결요소 분석도 추가
        if self.기본_구조_분석(그래프)["방향성"]:
            # 간단한 강연결요소 추정 (실제로는 타잔 알고리즘 필요)
            결과["강연결요소수"] = "타잔 분석 필요"
        else:
            결과["강연결요소수"] = None
        
        return 결과
    
    def 여왕의_최종_판결(self, 분석결과):
        """그래프 퀸의 최종 판결 및 조언"""
        print("\n👑 여왕의 최종 판결:")
        
        기본정보 = 분석결과["기본_구조"]
        연결정보 = 분석결과["연결성_분석"]
        
        # 그래프 등급 판정
        if 기본정보["밀도"] > 0.8 and 연결정보["컴포넌트수"] == 1:
            등급 = "SSS급 - 완벽한 네트워크"
            print(f"   🏆 {등급}")
            print(f"   💎 '이는 완벽에 가까운 네트워크구나. 짐도 감탄을 금할 수 없다!'")
        elif 기본정보["밀도"] > 0.5 and 연결정보["컴포넌트수"] <= 2:
            등급 = "S급 - 우수한 네트워크"
            print(f"   🥇 {등급}")
            print(f"   ✨ '훌륭한 구조다. 약간의 최적화만 있다면 완벽하리라!'")
        elif 연결정보["컴포넌트수"] > 5:
            등급 = "C급 - 개선 필요"
            print(f"   📈 {등급}")
            print(f"   ⚠️ '연결성이 부족하다. 더 많은 간선이 필요하도다!'")
        else:
            등급 = "B급 - 양호한 네트워크"
            print(f"   👍 {등급}")
            print(f"   💫 '나쁘지 않은 구조다. 용도에 따라 충분히 활용 가능하리라!'")
        
        # 여왕의 조언
        print(f"\n💎 여왕의 조언:")
        조언들 = []
        
        if 기본정보["밀도"] < 0.3:
            조언들.append("🔗 '더 많은 연결을 추가하여 밀도를 높이는 것이 좋겠다'")
        
        if 연결정보["컴포넌트수"] > 1:
            조언들.append("🌉 '분리된 컴포넌트들을 연결하는 브릿지가 필요하다'")
        
        if 기본정보["정점수"] > 100:
            조언들.append("📊 '대규모 네트워크이니 효율적인 알고리즘 선택이 중요하다'")
        
        if not 조언들:
            조언들.append("👑 '현재 구조가 목적에 잘 맞는 것 같다. 유지하도록!'")
        
        for 조언 in 조언들:
            print(f"   {조언}")
        
        print(f"\n👑 '짐의 분석이 도움이 되었기를 바란다. 훌륭한 네트워크를 구축하라!'")
        
        return 등급
```

### 🌐 네트워크 로드 (Network Lord) - "복합 네트워크의 지배자"

#### 캐릭터 설정 🌐
- **클래스**: 네트워크 지배자 (Network Overlord)
- **정체**: 여러 종류의 네트워크를 동시에 관리하고 최적화하는 거미 미궁의 두 번째 보스
- **별명**: "네트워크의 군주"
- **성격**: 냉철하고 계산적, 효율성을 최우선으로 추구
- **특기**: 복합 네트워크 관리, 다중 알고리즘 최적화
- **철학**: "모든 네트워크는 최적화될 수 있다"
- **말버릇**: "효율성이 곧 생존이다!"
- **무기**: 다중 네트워크 제어판 (여러 네트워크를 동시에 조작)

### 👑 웹 마스터 (Web Master) - "거미줄 차원의 절대자"

#### 캐릭터 설정 👑
- **클래스**: 차원 지배자 (Dimensional Ruler)
- **정체**: 거미줄 차원 전체를 창조하고 지배하는 궁극의 존재
- **별명**: "거미줄 차원의 창조주"
- **성격**: 초월적이고 신비로움, 모든 것을 아우르는 절대적 존재
- **특기**: 차원 조작, 무한 네트워크 생성
- **철학**: "모든 연결은 내가 만들었고, 모든 길은 내게서 시작된다"
- **말버릇**: "이 모든 것이 나의 작품이다!"
- **무기**: 창조의 거미줄 (현실 자체를 네트워크로 변환)

```python
class 웹_마스터:
    def __init__(self):
        print("👑 웹 마스터: '거미줄 차원의 창조주가 모습을 드러내노라!'")
        self.창조력 = float('inf')
        self.초월성 = float('inf')
        self.절대성 = float('inf')
        self.차원지배력 = float('inf')
        
    def 차원_창조_선언(self):
        """웹 마스터의 차원 창조 선언"""
        print("\n✨ 웹 마스터의 창조 선언:")
        print("   '이 거미줄 차원의 모든 것은 나의 작품이다!'")
        print("   '모든 정점은 내가 찍은 점이고,'")
        print("   '모든 간선은 내가 그은 선이며,'")
        print("   '모든 알고리즘은 내가 부여한 법칙이다!'")
        print()
        print("   '너희가 지금까지 배운 모든 것:'")
        print("   '🔗 기초 개념들, 🔍 탐색 알고리즘들,'")
        print("   '🌊 경로 찾기, 🌳 트리 구성,'")
        print("   '📐 위상 정렬, 🔗 강연결,'")
        print("   '🌊 유량 제어... 모든 것이 내 의도대로다!'")
        print()
        print("   '이제 너희는 진정한 네트워크 마스터가 되었다!'")
        print("   '나의 차원에서 자유롭게 창조하고 탐험하라!'")
    
    def 최종_축복(self, 도전자):
        """웹 마스터의 최종 축복"""
        print(f"\n🌟 웹 마스터 → {도전자}:")
        print("   '훌륭하다! 너는 모든 층을 정복했구나!'")
        print("   '이제 너 역시 거미줄 차원의 마스터다!'")
        print()
        print("   💎 웹 마스터의 축복:")
        print("   ✨ 모든 그래프 알고리즘 완전 습득")
        print("   ✨ 네트워크 직관력 최대 강화")  
        print("   ✨ 복잡한 문제 해결 능력 획득")
        print("   ✨ 알고리즘 최적화 센스 부여")
        print("   ✨ 실무 적용 노하우 전수")
        print()
        print("   '이제 현실 세계로 돌아가서'")
        print("   '네트워크와 그래프의 힘으로'")
        print("   '더 나은 세상을 만들어가라!'")
        print()
        print("   👑 '웰컴 투 더 웹 마스터스!'")
```

---

## 🎊 에필로그: 거미 미궁 마스터들의 졸업식

```python
def 거미_미궁_졸업식():
    print("🎓 거미 미궁 마스터들의 졸업식")
    print("=" * 60)
    
    졸업생들 = [
        "🔗 스몰 버텍시 - 기초 교육 명예 교수",
        "🕸️ 스몰 엣지 - 연결 이론 박사",
        "🚶 뎁스 크롤러 - 깊이 탐험 석사",
        "🌊 브레드스 스카우트 - 너비 정찰 석사",
        "🌊 플로이드 오라클 - 전지적 경로 박사",
        "🗺️ 다익스트라 웨버 - 최단경로 예술가",
        "⚡ 벨만 워커 - 음수 정복 전사",
        "🌳 크루스칼 빌더 - 건축 마이스터",
        "🌿 프림 가드너 - 정원 마이스터",
        "📐 토포 소터 - 질서 정립 박사",
        "🔗 타잔 링커 - 강연결 마스터",
        "🌊 포드 플로워 - 유량 제어 마스터",
        "👑 그래프 퀸 - 네트워크 여제",
        "👑 웹 마스터 - 차원 창조주"
    ]
    
    print("🎖️ 모든 거미들이 자신만의 전문성을 완성했습니다!")
    
    for 졸업생 in 졸업생들:
        print(f"   {졸업생}")
    
    print()
    print("🌟 이제 여러분도 거미 미궁의 마스터가 되셨습니다!")
    print("   그래프와 네트워크의 모든 비밀을 알게 되었고,")
    print("   실제 문제에 이를 적용할 수 있는 능력을 얻었습니다!")
    print()
    print("🎊 축하합니다! 웰컴 투 더 네트워크 마스터스!")

# 졸업식 개최!
거미_미궁_졸업식()
```

---

**🕷️ 그래프 거미 미궁 캐릭터 대도감 완성! 🌟**

*총 14명의 개성 넘치는 거미 캐릭터들이 각자의 층에서*
*그래프 알고리즘의 모든 것을 가르쳐드립니다!*

**🎯 특징:**
- 각 캐릭터마다 고유한 성격과 철학
- 실제 알고리즘과 연결된 특기와 능력
- 단계별 난이도 상승 구조
- 실용적인 코드 예제 포함
- 교육적 효과와 재미 모두 추구, 다음정점
             


