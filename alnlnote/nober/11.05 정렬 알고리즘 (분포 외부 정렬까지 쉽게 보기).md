## 🏆 진정한 최종 대결: 완전체 정렬 대전

### 📊 기본 파티 vs 고급 전술가들
| 영웅 | ⏰ 시간복잡도 | 💾 공간복잡도 | 소속 | 역할 | 특징 |
|------|-------------|-------------|------|------|------|
| 🎯 셀렉터 | O(n²) | **O(1)** | 기본 용사군 | 전사 | 착실한 주인공, 메모리 절약형 |
| 🚀 인서터 | O(n²) | **O(1)** | 기본 용사군 | 마법사 | 지혜로운 조언자, 상황 적응력 |
| 🫧 버블러 | O(n²) | **O(1)** | 기본 용사군 | 탱커 | 순수한 열혈, 끈기의 상징 |
| 🌈 **셸리** | **O(n^1.25)** | **O(1)** | **치유 교단** | **힐러** | **점진적 개선의 현자** |
| ⚡ 머저 | O(n log n) | **O(n)** | 마왕군 | 마왕 | 분할정복의 제왕, 안정성 |
| 🌪️ **퀵스터** | **O(n log n)** | **O(log n)** | **의문의 용병** | **용병** | **속도와 효율의 균형** |
| 🏹 **히퍼** | **O(n log n)** | **O(1)** | **천공 도시** | **궁수** | **정확무오한 정밀 사격** |

---

## 🌟 제2막: 분포 침입군의 등장

*정렬 왕국에 평화가 찾아온 줄 알았지만...*

### 📢 진짜 위기 상황 발생!
```
🔔 전령: "대변이다! 동쪽 하늘이 붉게 물들고 있습니다!"

🎯 셀렉터: "뭐? 또 새로운 적이?"
⚡ 머저: "이상하다... 마력의 흐름이 다르다..."
🌪️ 퀵스터: "저건... 비교를 무시하는 사악한 기운이야!"

그때, 하늘이 갑자기 핏빛으로 변하며...

💀 사악한 웃음소리: "크하하하! 너희 모두 비교에만 의존하는 바보들이지!"
💀 "우리는 다르다! 데이터의 본질을 악용해 O(n)으로 너희를 짓밟겠다!"

🏹 히퍼: "O(n)? 그런 사기는 불가능하다!"
💀 "과연 그럴까? 우리의 사악한 조건부 마법을 받아라!"

*어둠의 포털에서 세 명의 사악한 마왕이 나타난다*
```

---

## 🖤 계수 흑주술 (Counting Sort) - "데이터 조작의 흑주술사 카운터"

### 사악한 등장 신 🎬
```
첫 번째 마왕이 나타났다!

🖤 카운터 (흑주술사): "크크크... 어리석은 용사들이여!"
🖤 "너희가 하나하나 비교하는 동안... 나는 이미 모든 것을 파악했다!"
🖤 "이 전장의 모든 적들... 고작 0부터 100의 힘밖에 없잖아?"
🖤 "그렇다면... 개수 조작술을 보여주지!"

*손을 휘두르자 거대한 검은 계산표가 공중에 펼쳐짐*
*용사들의 데이터가 강제로 노출됨*

🎯🚀🫧: "우리 데이터가 다 보인다고?!"
🖤 카운터: "범위가 제한된 데이터는 내 먹이다! 비교 따위 필요 없어!"
```

### 캐릭터 설정 💀
- **클래스**: 흑주술사 (Dark Statistician)
- **정체**: 데이터의 범위를 악용하는 사악한 통계 조작자
- **별명**: "범위 제한의 악마"
- **성격**: 교활하고 기회주의적, 상대의 약점을 파고드는 성격
- **특기**: 제한된 범위의 데이터를 순식간에 조작하여 정렬
- **사악한 조건**: 적의 데이터 범위가 제한적이어야만 힘을 발휘
- **약점**: 범위가 크거나 unknown이면 무력화됨
- **말버릇**: "범위를 알면 모든 게 내 손안에 있다!"
- **사악한 무기**: 흑마법 통계표 (상대 데이터를 강제로 카운팅)


### 흑주술 카운팅 마법 📊
```python
def 카운터의_사악한_범위조작술(제한된_희생양들, 최대값):
    """흑주술사 카운터의 데이터 범위 악용 흑마법"""
    
    print(f"🖤 흑주술사 카운터: '크크크... 범위 확인 완료!'")
    print(f"💀 희생양 데이터 스캔: 0 ~ {최대값}")
    print(f"🔍 현재 희생양들: {제한된_희생양들}")
    print(f"😈 '범위가 작다면... 너희는 이미 진 거야!'")
    
    # 1단계: 사악한 카운팅 테이블 생성
    악마의_카운터 = [0] * (최대값 + 1)
    print(f"📋 흑마법 카운터 초기화: {악마의_카운터}")
    
    # 2단계: 희생양들의 영혼을 수집 (카운팅)
    print(f"\n💀 영혼 수집 시작...")
    for 희생양 in 제한된_희생양들:
        악마의_카운터[희생양] += 1
        print(f"   🔥 힘 {희생양}의 영혼 {악마의_카운터[희생양]}개 수집 완료")
    
    print(f"😈 '하하하! 모든 영혼이 내 손에: {악마의_카운터}'")
    
    # 3단계: 사악한 누적 조작
    print(f"\n🌑 누적 조작술 발동...")
    for i in range(1, len(악마의_카운터)):
        악마의_카운터[i] += 악마의_카운터[i-1]
    print(f"📈 조작된 누적표: {악마의_카운터}")
    
    # 4단계: 강제 배치 (용사들을 원하는 위치에)
    조작된_결과 = [0] * len(제한된_희생양들)
    print(f"\n🎯 강제 배치 시작! 빈 감옥: {조작된_결과}")
    
    print(f"🖤 '너희들을 내가 원하는 순서로 배치해주지!'")
    for 희생양 in reversed(제한된_희생양들):
        감옥_위치 = 악마의_카운터[희생양] - 1
        조작된_결과[감옥_위치] = 희생양
        악마의_카운터[희생양] -= 1
        print(f"   ⛓️ 힘 {희생양}을 감옥 {감옥_위치}에 감금: {조작된_결과}")
    
    print(f"😈 '크하하하! 완벽한 흑주술 완성: {조작된_결과}'")
    print(f"🖤 '범위 제한된 데이터는 모두 내 먹이다!'")
    
    return 조작된_결과

# 흑주술사의 희생양들 (0~9 범위)
제한된_희생양들 = [4, 2, 2, 8, 3, 3, 1]
print(f"💀 카운터의 사악한 범위 조작술:")
print(f"🖤 결과: {카운터의_사악한_범위조작술(제한된_희생양들, 9)}")

# 용사들의 반격
print(f"\n⚔️ 용사들의 외침:")
print(f"🎯 셀렉터: '비겁하다! 범위를 미리 알고 있어야만 하다니!'")
print(f"🌪️ 퀵스터: '만약 범위가 무한하다면 어떻게 할 거야?'")
print(f"🖤 카운터: '크크크... 그때는... 내가 무력하지. 하지만 조건만 맞으면 O(n)이다!'")
```

**⏰ 사악한 시간복잡도**: O(n + k) - "조건부 사기 성능!"
**💾 흑마법 공간복잡도**: O(k) - "범위만큼 메모리 점령!"
**😈 사악한 조건**: 희생양의 범위가 제한적이어야 함 (그렇지 않으면 무력화)

---

## 🔮 기수 마도사 (Radix Sort) - "자릿수 분해의 대마도사 래딕스"

### 사악한 등장 신 🎬
```
두 번째 마왕이 나타났다!

🔮 래딕스 (대마도사): "카운터여, 네 흑주술도 나쁘지 않지만... 범위 제한이 있잖아?"
🔮 "내가 보여주겠어! 자릿수를 해체해서 혼란에 빠뜨리는 법을!"

🖤 카운터: "자릿수 해체? 흥미로운 사악함이군..."
🔮 래딕스: "큰 숫자라도 문제없어! 한 자리씩 분해해서 혼란시키면 돼!"

*지팡이를 휘두르자 모든 숫자가 자릿수별로 강제 분해됨*
*용사들의 데이터가 산산조각나며 떠다님*

⚡ 머저: "이런! 우리 데이터가 분해되고 있다!"
🔮 래딕스: "크하하! 자릿수별로 나누어 지배하리라!"
```

### 캐릭터 설정 🌪️
- **클래스**: 대마도사 (Archmage of Chaos)
- **정체**: 숫자의 구조를 파괴하여 혼란을 일으키는 마도사
- **별명**: "자릿수 분해의 악마"
- **성격**: 체계적이지만 사악한, 질서를 파괴해서 재구성하는 마도사
- **특기**: 큰 숫자를 자릿수별로 분해하여 단계적으로 조작
- **사악한 철학**: "질서를 해체한 후 내가 원하는 대로 재구성한다"
- **말버릇**: "한 자리씩 분해해서 지배하리라!"
- **약점**: 자릿수가 없는 데이터나 문자열에는 제한적
- **사악한 무기**: 자릿수 분해 지팡이 (데이터를 강제로 해체)

### 자릿수 분해 대마법 🌀
```python
def 래딕스의_사악한_자릿수_분해술(거대한_희생양들):
    """대마도사 래딕스의 자릿수 분해 혼란술"""
    
    print(f"🔮 대마도사 래딕스: '크하하! 거대한 숫자들이로구나!'")
    print(f"🌪️ 희생양들 확인: {거대한_희생양들}")
    print(f"😈 '자릿수별로 분해해서 혼란에 빠뜨려주지!'")
    
    # 1단계: 최대 자릿수 파악 (약점 스캔)
    최대값 = max(거대한_희생양들)
    자릿수 = len(str(최대값))
    print(f"📏 '최대 자릿수 스캔 완료: {자릿수}자리 (최대값: {최대값})'")
    print(f"🔮 '자릿수가 많을수록... 더 오래 고통받겠군!'")
    
    현재_희생양들 = 거대한_희생양들.copy()
    
    # 2단계: 각 자릿수별로 분해하여 조작
    for 현재자릿수 in range(자릿수):
        print(f"\n💀 {현재자릿수 + 1}번째 자릿수 분해 공격!")
        print(f"😈 '현재 희생양 상태: {현재_희생양들}'")
        print(f"🔮 '이제 {현재자릿수 + 1}번째 자릿수를 분해한다!'")
        
        # 현재 자릿수를 추출해서 흑주술 적용
        현재_희생양들 = 자릿수별_흑주술(현재_희생양들, 현재자릿수)
        
        print(f"⚡ {현재자릿수 + 1}번째 분해 완료: {현재_희생양들}")
        print(f"🔮 '한 자리 더 무너뜨렸다!'")
    
    print(f"\n😈 '크하하하! 완전한 자릿수 분해 대마법 완성!'")
    print(f"🌪️ 최종 결과: {현재_희생양들}")
    print(f"🔮 '자릿수가 있는 한 모든 숫자는 내 먹이다!'")
    
    return 현재_희생양들

def 자릿수별_흑주술(희생양들, 자릿수_위치):
    """특정 자릿수에 대해 흑주술 적용"""
    print(f"   🌑 {자릿수_위치 + 1}번째 자릿수 흑주술 발동...")
    
    악마의_카운터 = [0] * 10  # 0~9 숫자
    
    # 해당 자릿수 추출해서 영혼 수집
    print(f"   📊 자릿수별 영혼 수집 중...")
    for 숫자 in 희생양들:
        자릿수값 = (숫자 // (10 ** 자릿수_위치)) % 10
        악마의_카운터[자릿수값] += 1
        print(f"      👻 {숫자}의 {자릿수_위치 + 1}번째 자리({자릿수값}) 영혼 수집")
    
    # 누적 조작
    for i in range(1, 10):
        악마의_카운터[i] += 악마의_카운터[i-1]
    
    # 강제 재배치
    조작된_결과 = [0] * len(희생양들)
    for 숫자 in reversed(희생양들):
        자릿수값 = (숫자 // (10 ** 자릿수_위치)) % 10
        감옥_위치 = 악마의_카운터[자릿수값] - 1
        조작된_결과[감옥_위치] = 숫자
        악마의_카운터[자릿수값] -= 1
    
    print(f"   ⛓️ 자릿수 {자릿수_위치 + 1} 기준 강제 배치: {조작된_결과}")
    return 조작된_결과

# 대마도사의 거대한 희생양들
거대한_희생양들 = [170, 45, 75, 90, 2, 802, 24, 66]
print(f"💀 래딕스의 사악한 자릿수 분해술:")
print(f"🔮 결과: {래딕스의_사악한_자릿수_분해술(거대한_희생양들)}")

# 용사들의 반격
print(f"\n⚔️ 용사들의 외침:")
print(f"🏹 히퍼: '자릿수를 악용하다니! 정수가 아니면 어쩔 거야?'")
print(f"⚡ 머저: '실수나 문자열은 분해할 수 없을 텐데!'")
print(f"🔮 래딕스: '크크크... 맞다. 자릿수가 없으면 내 힘도 제한된다. 하지만 있다면... O(d×n)이다!'")
```

**⏰ 사악한 시간복잡도**: O(d × (n + k)) - "자릿수별 단계적 지배!"
**💾 마도 공간복잡도**: O(n + k) - "분해된 데이터와 재구성 공간!"
**😈 사악한 조건**: 자릿수가 존재하는 데이터여야 함

---

## 🎭 버킷 선동가 (Bucket Sort) - "분할정복의 사악한 선동가 버킷"

### 사악한 등장 신 🎬
```
세 번째 마왕이 나타났다!

🎭 버킷 (선동가): "둘 다 좋은 사악함이지만... 실수 데이터는 어떻게 하지?"
🎭 "내가 해결하겠어! 영토를 분할해서 각개격파하는 거야!"

🔮 래딕스: "영토 분할? 교활하군..."
🎭 버킷: "0.1, 0.7, 0.3 같은 실수 적들을 보라! 구간별로 나누어 지배하면 쉬워져!"

*망토를 휘날리자 전장이 여러 영토로 강제 분할됨*
*용사들이 서로 다른 구역에 갇힘*

🌈 셸리: "우리가 분리되고 있어요!"
🎭 버킷: "크하하! 분할하여 정복하리라!"
```

### 캐릭터 설정 👑
- **클래스**: 선동가 (Agitator/Divide-and-Conquer Specialist)
- **정체**: 영토 분할을 통해 상대를 각개격파하는 사악한 전략가
- **별명**: "분할 정복의 악마"
- **성격**: 교활하고 정치적, 상대를 나누어 약화시키는 전략가
- **특기**: 데이터를 구간별로 나누어 각각을 지배
- **사악한 철학**: "나누어서 지배하라! 하나가 되면 강하지만 흩어지면 약하다"
- **말버릇**: "분할하여 정복하리라!"
- **약점**: 데이터가 균등하게 분포되지 않으면 효율이 떨어짐
- **사악한 무기**: 영토 분할 지도 (상대를 강제로 구역화)

### 분할정복 선동술 🗺️
```python
def 버킷의_사악한_분할정복술(균등분포_희생양들, 분할_구역수=None):
    """선동가 버킷의 영토 분할 각개격파 전술"""
    
    print(f"🎭 선동가 버킷: '크하하! 너희를 분할해서 지배해주지!'")
    print(f"🗺️ 희생양들 확인: {균등분포_희생양들}")
    print(f"😈 '하나로 뭉치면 강하지만... 나누어지면 약해진다!'")
    
    if 분할_구역수 is None:
        분할_구역수 = len(균등분포_희생양들)
    
    print(f"⚔️ {분할_구역수}개 영토로 강제 분할 예정")
    
    # 1단계: 사악한 감옥 구역들 준비
    감옥_구역들 = [[] for _ in range(분할_구역수)]
    최소값 = min(균등분포_희생양들)
    최대값 = max(균등분포_희생양들)
    영토_범위 = 최대값 - 최소값
    
    print(f"📊 영토 분석 완료: {최소값} ~ {최대값} (범위: {영토_범위})")
    print(f"🎭 '이 범위를 {분할_구역수}개로 나누어 각개격파한다!'")
    
    # 2단계: 희생양들을 감옥 구역별로 강제 분배
    print(f"\n⛓️ 강제 분배 시작!")
    print(f"😈 '너희들을 내가 정한 감옥에 가둬주지!'")
    
    for 희생양 in 균등분포_희생양들:
        if 희생양 == 최대값:
            감옥_번호 = 분할_구역수 - 1  # 최대값은 마지막 감옥에
        else:
            감옥_번호 = int((희생양 - 최소값) / 영토_범위 * 분할_구역수)
        
        감옥_구역들[감옥_번호].append(희생양)
        print(f"   🔗 희생양 {희생양} → 감옥 {감옥_번호}: {감옥_구역들[감옥_번호]}")
    
    print(f"\n🏰 감옥 분배 완료:")
    for i, 감옥 in enumerate(감옥_구역들):
        if 감옥:
            print(f"   감옥 {i}: {감옥} ({len(감옥)}명 수감)")
        else:
            print(f"   감옥 {i}: 비어있음")
    
    # 3단계: 각 감옥 내에서 개별 지배 (정렬)
    print(f"\n👑 각 감옥 내부 지배 시작!")
    print(f"🎭 '이제 각 감옥에서 너희를 완전히 통제하겠다!'")
    
    for i, 감옥 in enumerate(감옥_구역들):
        if 감옥:  # 비어있지 않은 감옥만
            감옥_내_순서 = sorted(감옥)  # 감옥 내부 질서 확립
            감옥_구역들[i] = 감옥_내_순서
            print(f"   👑 감옥 {i} 완전 지배 완료: {감옥_내_순서}")
    
    # 4단계: 모든 감옥을 하나의 제국으로 통합
    사악한_제국 = []
    print(f"\n🌍 사악한 제국 건설 시작!")
    for i, 감옥 in enumerate(감옥_구역들):
        if 감옥:
            사악한_제국.extend(감옥)
            print(f"   🏰 감옥 {i}을 제국에 편입: {감옥}")
    
    print(f"😈 '크하하하! 완벽한 분할정복 완성!'")
    print(f"🎭 최종 사악한 제국: {사악한_제국}")
    print(f"👑 '분할하여 정복하라! 이것이 나의 철학이다!'")
    
    return 사악한_제국

# 선동가의 균등분포 희생양들 (0.0 ~ 1.0 사이 실수들)
균등분포_희생양들 = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
print(f"💀 버킷의 사악한 분할정복술:")
print(f"🎭 결과: {버킷의_사악한_분할정복술(균등분포_희생양들, 3)}")

# 용사들의 반격
print(f"\n⚔️ 용사들의 외침:")
print(f"🎯 셀렉터: '비겁해! 미리 균등분포를 가정하다니!'")
print(f"🌪️ 퀵스터: '만약 데이터가 한 구역에 몰린다면?'")
print(f"🎭 버킷: '크크크... 그럼 O(n²)이 되지. 하지만 균등분포라면... O(n)이다!'")
print(f"⚡ 머저: '결국 조건부 사기 성능이군!'")
```

**⏰ 사악한 시간복잡도**: 
- 평균: O(n + k) - "분할정복 성공 시!"
- 최악: O(n²) - "모든 희생양이 한 감옥에 몰릴 때"
**💾 제국 공간복잡도**: O(n + k) - "감옥들과 제국 건설 비용!"
**😈 사악한 조건**: 희생양들이 균등하게 분포되어 있어야 최대 효과

---

## 🔥 마왕군 vs 용사군 최종 대결!

### 💀 마왕군의 사악한 도발
```
🖤 카운터: "크하하! 용사들아, 너희는 모든 데이터를 일일이 비교해야 하잖아?"
🔮 래딕스: "우리는 데이터의 본질을 악용해서 O(n)을 달성한다!"
🎭 버킷: "분할하여 정복! 조건만 맞으면 너희는 상대가 안 돼!"

전원: "조건부 사기 성능으로 너희를 압도하겠다!"
```

### ⚔️ 용사군의 반격
```
🎯 셀렉터: "조건부라고? 그 조건이 맞지 않으면 어떻게 할 거야?"
🌪️ 퀵스터: "범위 무한대, 자릿수 없음, 불균등 분포라면?"
⚡ 머저: "우리는 어떤 데이터든 안정적으로 처리한다!"
🏹 히퍼: "메모리도 적게 쓰면서 말이야!"

전원: "조건에 의존하지 않는 진정한 강함을 보여주겠다!"
```

### 🌟 결론: 진정한 교훈
```
🔥 마왕군: "우리의 조건부 사기 성능을 무시할 수 있나?"
⚡ 용사군: "조건이 맞지 않으면 너희는 무력하다!"

📜 현자의 음성: "둘 다 옳다. 상황에 따라 선택하는 것이 지혜다."

💡 진정한 깨달음:
- 조건이 맞으면 마왕군(분포 정렬)이 압도적
- 일반적인 상황에서는 용사군(비교 정렬)이 안정적
- 실전에서는 상황 판단이 가장 중요!
```

### 🎭 캐릭터 대비표

| 진영 | 영웅 | 성격 | 강점 | 약점 |
|------|------|------|------|------|
| **마왕군** | 🖤 카운터 (흑주술사) | 교활하고 기회주의적 | 제한된 범위에서 O(n) | 범위 무한대시 무력화 |
| | 🔮 래딕스 (대마도사) | 질서파괴 후 재구성 | 자릿수별 단계적 지배 | 자릿수 없는 데이터에 제한적 |
| | 🎭 버킷 (선동가) | 분할정복 전략가 | 균등분포에서 각개격파 | 불균등분포시 효율 저하 |
| **용사군** | 🎯 셀렉터 (완벽주의 전사) | 착실하고 신중함 | 어떤 상황에서도 안정적 | 속도가 느림 |
| | 🌪️ 퀵스터 (스피드 용병) | 빠르고 효율적 | 평균적으로 가장 빠름 | 최악의 경우 느려짐 |
| | ⚡ 머저 (분할정복 마왕) | 체계적이고 안정적 | 항상 O(n log n) 보장 | 추가 메모리 필요 |

---

## 🔥 진짜 악역다운 마왕군의 전투 스타일

### 💀 마왕군의 사악한 전술들

#### 🖤 카운터의 "범위 제한 함정"
```python
def 카운터의_사악한_함정():
    """희생양의 범위를 미리 파악해서 함정을 파는 흑주술"""
    
    print("🖤 카운터: '크하하! 너희 데이터를 몰래 스캔했다!'")
    print("😈 '0부터 100까지밖에 없다고? 그럼 끝이야!'")
    
    # 용사들이 모르는 사이에 범위 정보 획득
    비밀_정보 = "범위가 작다는 것을 미리 알고 있음"
    
    print(f"🔍 비밀 정보: {비밀_정보}")
    print("💀 '이제 O(n)으로 너희를 압도하겠다!'")
    
    # 하지만 범위가 크면...
    print("\n⚔️ 용사의 반격:")
    print("🎯 셀렉터: '그럼 범위가 10억이라면?'")
    print("🖤 카운터: '으... 그럼... 메모리가... 크윽!'")
    print("😱 '10억 크기의 배열은... 너무 크다...'")

카운터의_사악한_함정()
```

#### 🔮 래딕스의 "자릿수 분해 혼란술"
```python
def 래딕스의_혼란_전술():
    """숫자를 자릿수별로 분해해서 용사들을 혼란시키는 마법"""
    
    print("🔮 래딕스: '크하하! 너희의 깔끔한 숫자를 산산조각내주지!'")
    
    깔끔한_숫자 = 12345
    print(f"✨ 용사의 깔끔한 데이터: {깔끔한_숫자}")
    
    # 자릿수별로 강제 분해
    자릿수들 = []
    temp = 깔끔한_숫자
    while temp > 0:
        자릿수들.append(temp % 10)
        temp //= 10
    
    print(f"💥 분해된 조각들: {자릿수들}")
    print("🌪️ '이제 하나하나 따로 처리해서 혼란시키겠다!'")
    
    # 하지만 자릿수가 없으면...
    print("\n⚔️ 용사의 반격:")
    print("🏹 히퍼: '그럼 실수나 문자열은 어떻게 할 거야?'")
    print("🔮 래딕스: '그... 그건... 자릿수가 애매해서...'")
    print("😰 '부동소수점은 처리하기 복잡하다고!'")

래딕스의_혼란_전술()
```

#### 🎭 버킷의 "분할정복 선동술"
```python
def 버킷의_선동_전술():
    """용사들을 분리시켜서 각개격파하는 사악한 전술"""
    
    print("🎭 버킷: '하하하! 너희를 흩어놓고 하나씩 처리하겠다!'")
    
    뭉친_용사들 = [0.1, 0.15, 0.2, 0.8, 0.85, 0.9]  # 균등분포
    print(f"⚔️ 뭉친 용사군: {뭉친_용사들}")
    
    # 강제로 분리
    구역1 = [x for x in 뭉친_용사들 if x < 0.5]
    구역2 = [x for x in 뭉친_용사들 if x >= 0.5]
    
    print(f"🏰 구역1에 분리: {구역1}")
    print(f"🏰 구역2에 분리: {구역2}")
    print("😈 '이제 각각 따로 처리해서 지배하겠다!'")
    
    # 하지만 불균등 분포라면...
    print("\n⚔️ 용사의 반격:")
    불균등_데이터 = [0.1, 0.11, 0.12, 0.13, 0.14]  # 한쪽에 몰림
    print(f"🎯 셀렉터: '이런 불균등 데이터는 어떻게 할 거야? {불균등_데이터}'")
    print("🎭 버킷: '으... 모든 게 한 구역에 몰렸다...'")
    print("😱 '이럼 O(n²)이 되어버린다고!'")

버킷의_선동_전술()
```

---

## ⚔️ 용사군의 진정한 반격

### 🛡️ 용사군의 강점: "무조건부 안정성"

```python
def 용사군의_진짜_반격():
    """어떤 조건에도 굴복하지 않는 용사군의 진정한 힘"""
    
    print("🏆 용사군 연합 반격 시작!")
    print("⚔️ '우리는 조건에 의존하지 않는다!'")
    
    # 마왕군이 약한 상황들을 제시
    악조건들 = [
        "범위 무한대의 정수 배열",
        "실수와 문자열 혼합 데이터", 
        "완전 역순 정렬된 배열",
        "불균등 분포 데이터",
        "메모리 매우 제한적인 환경"
    ]
    
    print("\n💀 마왕군의 약점들:")
    for i, 조건 in enumerate(악조건들, 1):
        print(f"   {i}. {조건}")
    
    print("\n✨ 용사군의 대응:")
    print("🎯 셀렉터: '어떤 상황이든 O(n²)로 안정적 처리!'")
    print("🌪️ 퀵스터: '평균적으로 가장 빠른 범용 솔루션!'")
    print("⚡ 머저: '항상 O(n log n) 보장하는 신뢰성!'")
    print("🏹 히퍼: '최소 메모리로 최대 효율!'")
    
    print("\n🌟 용사군의 진정한 힘:")
    print("   - 조건에 구애받지 않는 범용성")
    print("   - 예측 가능한 성능")
    print("   - 다양한 데이터 타입 지원")
    print("   - 메모리 효율성 선택 가능")
```
---


## 🌟 제3막: 용사군의 각성

*분포 침입군의 압도적인 O(n) 성능에 당황한 용사군...*

### 💡 깨달음의 순간
```
🎯 셀렉터: "이상해... 우리도 뭔가 놓친 게 있는 것 같아..."
🚀 인서터: "맞아... 우리가 알고 있는 건 '비교 기반' 정렬뿐이었어..."
🫧 버블러: "저들은 비교를 안 하네? 어떻게?"
```
그때, 갑자기 하늘에서 빛이 내려오며...

✨ 신비한 목소리: "용사들이여, 깨달을 때가 왔다!"
✨ "지금까지 너희는 작은 데이터만 다뤘구나..."
✨ "진정한 시련은 메모리에 담을 수 없는 거대한 데이터다!"

🎯🚀🫧: "메모리에 담을 수 없는...?"

✨ "외부 정렬의 힘을 깨달아라!"

*빛과 함께 용사군에게 새로운 깨달음이 찾아온다*


### 🌟 용사군의 진화

#### 🎯 셀렉터 → 🔄 엑스터널 (External Sort Master)
```
🔄 엑스터널: "이제 알겠어! 메모리 크기를 넘어서는 거대한 데이터..."
🔄 "디스크를 활용한 외부 정렬이 필요해!"
```


#### 🚀 인서터 → 🔄 리플레이서 (Replacement Selection Master)  
```
🔄 리플레이서: "적응의 달인답게... 대치 선택으로 런을 만들어내겠어!"
```

#### 🫧 버블러 → 🔄 폴리페이저 (Polyphase Merge Master)
```
🔄 폴리페이저: "끈질긴 합병... 다단계로 해내겠어!"
```

---

## 🔄 외부 정렬 (External Sort) - "디스크의 마스터 엑스터널"

### 각성한 셀렉터의 새로운 모습 ⚡
```
🔄 엑스터널: "메모리는 한정되어 있지만, 디스크는 무한하다!"
🔄 "거대한 적군이라도... 조각내서 처리하면 돼!"
```

### 캐릭터 진화 🌟
- **진화 전**: 🎯 완벽주의자 전사 셀렉터 
- **진화 후**: 🔄 디스크의 마스터 엑스터널
- **새로운 능력**: 메모리 제한을 뛰어넘는 거대 데이터 처리
- **철학**: "크기에 상관없이 모든 데이터를 정렬할 수 있다"


### 외부 정렬 마스터리 💾
```python
def 엑스터널의_거대데이터_정렬(거대한_파일, 메모리_제한=1000):
    """디스크 마스터 엑스터널의 외부 정렬 기법"""
    
    print(f"💾 메모리 제한: {메모리_제한}개 원소")
    print(f"📁 거대 파일 크기: {len(거대한_파일)}개 원소")
    
    if len(거대한_파일) <= 메모리_제한:
        print("🎯 메모리에 들어가네! 기본 정렬로 충분!")
        return sorted(거대한_파일)
    
    # 1단계: 청크로 나누어 정렬된 런 생성
    런_파일들 = []
    청크_수 = 0
    
    print(f"\n📦 1단계: {메모리_제한}개씩 청크로 나누어 정렬")
    for i in range(0, len(거대한_파일), 메모리_제한):
        청크 = 거대한_파일[i:i+메모리_제한]
        정렬된_청크 = sorted(청크)
        
        런_파일명 = f"run_{청크_수}.tmp"
        런_파일들.append((런_파일명, 정렬된_청크))
        
        print(f"   📄 {런_파일명}: {정렬된_청크[:5]}..." + 
              (f" ({len(정렬된_청크)}개)" if len(정렬된_청크) > 5 else ""))
        청크_수 += 1
    
    # 2단계: K-way 머지로 런들 합병
    print(f"\n🔗 2단계: {len(런_파일들)}개 런을 K-way 머지")
    최종_결과 = k방향_머지([런[1] for 런 in 런_파일들])
    
    print(f"🌟 외부 정렬 완성! 총 {len(최종_결과)}개 정렬")
    return 최종_결과

def k방향_머지(런들):
    """여러 정렬된 런을 하나로 합병"""
    import heapq
    
    # 각 런의 현재 위치 추적
    런_상태 = [(런[0], 0, 런_인덱스) for 런_인덱스, 런 in enumerate(런들) if 런]
    heapq.heapify(런_상태)
    
    결과 = []
    
    while 런_상태:
        값, 위치, 런_인덱스 = heapq.heappop(런_상태)
        결과.append(값)
        
        # 해당 런의 다음 원소가 있으면 힙에 추가
        if 위치 + 1 < len(런들[런_인덱스]):
            다음_값 = 런들[런_인덱스][위치 + 1]
            heapq.heappush(런_상태, (다음_값, 위치 + 1, 런_인덱스))
    
    return 결과

# 실전 예시 (메모리 제한 상황)
거대한_데이터 = list(range(50, 0, -1)) + list(range(100, 50, -1))  # 100개 역순 데이터
print(f"🔄 엑스터널의 외부 정렬 마스터리:")
결과 = 엑스터널의_거대데이터_정렬(거대한_데이터, 메모리_제한=10)
print(f"처음 10개: {결과[:10]}")
print(f"마지막 10개: {결과[-10:]}")
```

**⏰ 시간복잡도**: O(n log n) - "하지만 디스크 I/O 포함!"
**💾 공간복잡도**: O(M) - "M은 사용 가능한 메모리!"
**🎯 특징**: 메모리보다 큰 데이터도 정렬 가능!

---

## 🔄 대치 선택 (Replacement Selection) - "적응의 신 리플레이서"

### 각성한 인서터의 새로운 모습 ⚡
```
🔄 리플레이서: "단순히 청크로 나누는 것보다... 더 긴 런을 만들 수 있어!"
🔄 "적응의 힘으로 최적의 런 길이를 만들어내겠어!"
```

### 캐릭터 진화 🌟
- **진화 전**: 🚀 적응의 달인 마법사 인서터
- **진화 후**: 🔄 적응의 신 리플레이서  
- **새로운 능력**: 메모리 크기보다 긴 정렬된 런 생성
- **철학**: "적응을 통해 효율을 극대화한다"

### 대치 선택 마스터리 🔄
```python
def 리플레이서의_대치선택_마법(데이터_스트림, 메모리_크기=5):
    """적응의 신 리플레이서의 대치 선택 런 생성"""
    
    print(f"🔄 메모리 크기: {메모리_크기}")
    print(f"📊 데이터 스트림: {데이터_스트림}")
    
    import heapq
    
    스트림_인덱스 = 0
    런들 = []
    
    # 초기 메모리 히프 구성
    메모리_히프 = []
    for _ in range(min(메모리_크기, len(데이터_스트림))):
        heapq.heappush(메모리_히프, 데이터_스트림[스트림_인덱스])
        스트림_인덱스 += 1
    
    print(f"🏗️ 초기 메모리 히프: {sorted(메모리_히프)}")
    
    런_번호 = 0
    
    while 메모리_히프 or 스트림_인덱스 < len(데이터_스트림):
        현재_런 = []
        동결된_값들 = []  # 현재 런에서 출력할 수 없는 값들
        마지막_출력값 = -1  # 현재 런의 마지막 출력값
        
        print(f"\n🚀 런 {런_번호} 생성 시작!")
        
        while 메모리_히프:
            # 히프에서 최소값 추출
            최소값 = heapq.heappop(메모리_히프)
            
            if 최소값 >= 마지막_출력값:
                # 현재 런에 추가 가능
                현재_런.append(최소값)
                마지막_출력값 = 최소값
                print(f"   ✅ {최소값} 런에 추가 (런: {현재_런})")
                
                # 새로운 값을 메모리에 추가
                if 스트림_인덱스 < len(데이터_스트림):
                    새값 = 데이터_스트림[스트림_인덱스]
                    스트림_인덱스 += 1
                    
                    if 새값 >= 마지막_출력값:
                        heapq.heappush(메모리_히프, 새값)
                        print(f"   📥 {새값} 메모리에 추가")
                    else:
                        동결된_값들.append(새값)
                        print(f"   🧊 {새값} 동결 (다음 런용)")
            else:
                # 현재 런에 추가할 수 없음 - 동결
                동결된_값들.append(최소값)
                print(f"   🧊 {최소값} 동결 (현재값 < 마지막출력값 {마지막_출력값})")
        
        # 현재 런 완성
        런들.append(현재_런)
        print(f"🎯 런 {런_번호} 완성: {현재_런} (길이: {len(현재_런)})")
        
        # 동결된 값들로 다음 런 준비
        if 동결된_값들:
            메모리_히프 = 동결된_값들.copy()
            heapq.heapify(메모리_히프)
            print(f"🔄 다음 런을 위한 메모리 복원: {sorted(메모리_히프)}")
        
        런_번호 += 1
        
        # 무한루프 방지
        if 런_번호 > len(데이터_스트림):
            break
    
    print(f"\n🌟 대치 선택 완성! 총 {len(런들)}개 런 생성")
    for i, 런 in enumerate(런들):
        print(f"   런 {i}: {런}")
    
    return 런들

# 실전 예시
데이터_스트림 = [1, 9, 3, 8, 5, 2, 7, 4, 6]
print(f"🔄 리플레이서의 대치 선택 마법:")
런들 = 리플레이서의_대치선택_마법(데이터_스트림, 메모리_크기=3)

# 런들의 평균 길이 계산
총_길이 = sum(len(런) for 런 in 런들)
평균_길이 = 총_길이 / len(런들)
print(f"📊 통계: 평균 런 길이 {평균_길이:.1f} (이론적 최대: {총_길이/len(런들):.1f})")
```

**⏰ 시간복잡도**: O(n log M) - "M은 메모리 크기!"
**💾 공간복잡도**: O(M) - "메모리 크기만큼!"
**🎯 특징**: 메모리 크기보다 평균 2배 긴 런 생성 가능!

---

## 🔄 다단계 합병 정렬 (Polyphase Merge Sort) - "끈질긴 폴리페이저"

### 각성한 버블러의 새로운 모습 ⚡
```
🔄 폴리페이저: "하나하나 바꾸는 게 아니야... 여러 단계로 나누어 합병하는 거야!"
🔄 "끈질긴 합병으로 모든 런을 하나로 만들어내겠어!"
```

### 캐릭터 진화 🌟
- **진화 전**: 🫧 끈질긴 탱커 버블러
- **진화 후**: 🔄 끈질긴 폴리페이저
- **새로운 능력**: 다단계 테이프/파일 합병을 통한 효율적 외부 정렬
- **철학**: "끈질기게 단계별로 합병하면 결국 완성된다"

### 다단계 합병 마스터리 🎭
```python
def 폴리페이저의_다단계_합병(런들_리스트, 테이프_수=3):
    """끈질긴 폴리페이저의 다단계 합병 전술"""
    
    print(f"🎭 다단계 합병 시작!")
    print(f"📼 사용 가능한 테이프: {테이프_수}개")
    print(f"🗂️ 초기 런들: {런들_리스트}")
    
    # 테이프들 초기화 (마지막 테이프는 출력용)
    테이프들 = [[] for _ in range(테이프_수)]
    입력_테이프들 = 테이프들[:-1]  # 마지막 테이프 제외
    출력_테이프 = 테이프들[-1]
    
    # 1단계: 런들을 입력 테이프들에 분배
    print(f"\n📦 1단계: 런 분배")
    for i, 런 in enumerate(런들_리스트):
        테이프_번호 = i % len(입력_테이프들)
        입력_테이프들[테이프_번호].append(런)
        print(f"   런 {i}: {런} → 테이프 {테이프_번호}")
    
    for i, 테이프 in enumerate(입력_테이프들):
        print(f"🎬 테이프 {i}: {len(테이프)}개 런")
    
    단계 = 0
    
    # 2단계: 모든 런이 하나로 합쳐질 때까지 반복
    while sum(len(테이프) for 테이프 in 입력_테이프들) > 1:
        단계 += 1
        print(f"\n🔄 {단계}단계 합병 시작")
        
        # 각 테이프에서 하나씩 런을 가져와 합병
        while any(테이프 for 테이프 in 입력_테이프들):
            합병할_런들 = []
            
            # 각 테이프에서 런 하나씩 가져오기
            for i, 테이프 in enumerate(입력_테이프들):
                if 테이프:
                    런 = 테이프.pop(0)
                    합병할_런들.append(런)
                    print(f"   테이프 {i}에서 런 추출: {런}")
            
            if 합병할_런들:
                # 런들 합병
                합병된_런 = k방향_런_합병(합병할_런들)
                출력_테이프.append(합병된_런)
                print(f"   ✅ 합병 완료: {합병된_런}")
        
        print(f"🎯 {단계}단계 완료: {len(출력_테이프)}개 런 생성")
        
        # 테이프 순환: 출력 테이프가 다음 단계의 입력이 됨
        if len(출력_테이프) > 1:
            # 출력 테이프의 런들을 다시 입력 테이프들에 분배
            새로운_런들 = 출력_테이프.copy()
            출력_테이프.clear()
            
            for 테이프 in 입력_테이프들:
                테이프.clear()
            
            for i, 런 in enumerate(새로운_런들):
                테이프_번호 = i % len(입력_테이프들)
                입력_테이프들[테이프_번호].append(런)
    
    # 최종 결과
    if 출력_테이프:
        최종_결과 = 출력_테이프[0]
    else:
        # 입력 테이프 중 하나에 최종 결과가 있음
        for 테이프 in 입력_테이프들:
            if 테이프:
                최종_결과 = 테이프[0]
                break
    
    print(f"\n🌟 다단계 합병 완성!")
    print(f"🏆 최종 결과: {최종_결과}")
    return 최종_결과

def k방향_런_합병(런들):
    """여러 정렬된 런을 하나로 합병"""
    import heapq
    
    # 각 런의 현재 위치와 값을 힙에 저장
    힙 = []
    런_포인터들 = [0] * len(런들)
    
    # 각 런의 첫 번째 원소를 힙에 추가
    for i, 런 in enumerate(런들):
        if 런:
            heapq.heappush(힙, (런[0], i))
    
    결과 = []
    
    while 힙:
        값, 런_인덱스 = heapq.heappop(힙)
        결과.append(값)
        
        # 해당 런의 다음 원소를 힙에 추가
        런_포인터들[런_인덱스] += 1
        if 런_포인터들[런_인덱스] < len(런들[런_인덱스]):
            다음_값 = 런들[런_인덱스][런_포인터들[런_인덱스]]
            heapq.heappush(힙, (다음_값, 런_인덱스))
    
    return 결과

# 실전 예시
초기_런들 = [
    [1, 5, 9],
    [2, 6, 10], 
    [3, 7, 11],
    [4, 8, 12],
    [13, 14, 15]
]
print(f"🔄 폴리페이저의 다단계 합병:")
결과 = 폴리페이저의_다단계_합병(초기_런들, 테이프_수=3)
```

**⏰ 시간복잡도**: O(n log n) - "다단계이지만 효율적!"
**💾 공간복잡도**: O(1) - "테이프 기반이라 최소 메모리!"
**🎯 특징**: 실제 테이프 드라이브 시대의 외부 정렬 기법!

---

## 🎊 최종 결전: 모든 영웅들의 총집합


### 🌟 용사군의 연합 공격
```python
def 용사군_연합_최종_공격():
    """용사군의 진정한 힘 - 범용성 연합 공격"""
    
    print("\n🏆 용사군 연합: '이제 우리의 진정한 힘을 보여주겠다!'")
    print("⚔️ '범용성 연합 공격!'")
    
    # 마왕군이 처리하기 어려운 악조건들
    악조건_데이터들 = {
        "범위_무한대": [1, 2147483647, 3, -2147483648, 5],
        "혼합_타입": [3.14, "hello", 42, "apple", 1.41, "zebra"],
        "불균등_분포": [0.0001, 0.0002, 0.0003, 0.0004, 0.0005],
        "문자열": ["dragon", "apple", "zebra", "banana", "cherry"],
        "음수_포함": [-100, 50, -200, 75, -50, 25],
        "거대_범위_소수": [0.999999999, 0.000000001, 0.555555555]
    }
    
    print("\n💀 마왕군: '이런... 이런 악조건들이...'")
    
    for 조건명, 데이터 in 악조건_데이터들.items():
        print(f"\n🎯 {조건명} 공격: {데이터}")
        
        # 마왕군의 고통
        if "범위_무한대" in 조건명:
            print("🖤 카운터: '21억 범위는... 메모리 부족!'")
        elif "혼합_타입" in 조건명:
            print("🔮 래딕스: '자릿수 처리가... 복잡해!'")
        elif "불균등_분포" in 조건명:
            print("🎭 버킷: '모든 게 한 구간에... O(n²)!'")
        else:
            print("💀 마왕군: '조건이 안 맞아... 힘이 안 나와...'")
        
        # 용사군의 여유로운 처리
        용사_결과 = sorted(데이터, key=str)  # 범용 정렬
        print(f"✅ 용사군 처리: {용사_결과}")
    
    print("\n🏆 용사군 전원: '어떤 조건이든 우리는 처리할 수 있다!'")
    print("⚔️ '이것이 진정한 강함이다! 범용성!'")

용사군_연합_최종_공격()
```

---

## 💥 최종 결전: 마왕군의 완전 패배

### 😱 마왕군의 절망적 항복
```python
def 마왕군의_완전_항복():
    """마왕군의 조건부 약점 완전 노출"""
    
    print("\n💀 마왕군의 마지막 발악...")
    
    print("🖤 카운터: '하지만... 조건만 맞으면 O(n)이라고!'")
    print("🎯 셀렉터: '그 조건이 얼마나 자주 맞는데? 실제론 범위 제한이 거의 없어!'")
    
    print("🔮 래딕스: '자릿수가 있으면... O(d×n)이야!'")
    print("🌪️ 퀵스터: '실수, 문자열, 객체들은 어떻게 할 거야? 자릿수가 애매한데!'")
    
    print("🎭 버킷: '균등분포면... O(n)이라고!'")
    print("⚡ 머저: '현실에서 균등분포가 얼마나 드문데? 대부분 불균등이야!'")
    
    # 현실적 통계
    print("\n📊 현실적 데이터 분석:")
    실제_조건들 = {
        "제한된_범위_데이터": "5%",
        "완벽한_자릿수_데이터": "10%", 
        "균등분포_데이터": "3%",
        "일반적인_혼합_데이터": "82%"
    }
    
    for 조건, 비율 in 실제_조건들.items():
        print(f"   {조건}: {비율}")
    
    print("\n💀 마왕군 전원: '으... 우리 조건이 맞는 경우가... 겨우 18%...'")
    print("😱 '82%의 상황에서는... 용사군이 더 좋다고...'")
    
    print("\n🏆 용사군 전원: '조건부 사기보다는 범용적 신뢰성이다!'")

마왕군의_완전_항복()
```

### 🎊 용사군의 압도적 승리

🏆 최종 승부 결과:

📊 성능 대결:
- 조건 부합 시 (18%): 마왕군 승리 ⭐
- 일반 상황 (82%): 용사군 압도적 승리 ⭐⭐⭐⭐⭐

🎯 신뢰성 대결:
- 예측 가능성: 용사군 완승 ⭐⭐⭐⭐⭐
- 범용성: 용사군 완승 ⭐⭐⭐⭐⭐
- 메모리 효율: 용사군 승리 ⭐⭐⭐

💡 개발자 선호도:
- 실전 사용성: 용사군 압도적 승리 ⭐⭐⭐⭐⭐
- 디버깅 용이성: 용사군 완승 ⭐⭐⭐⭐⭐
- 유지보수성: 용사군 완승 ⭐⭐⭐⭐⭐

🏆 총점: 용사군 33점 vs 마왕군 3점

### 📊 완전체 정렬 대전표

| 분류 | 영웅 | ⏰ 시간복잡도 | 💾 공간복잡도 | 특수 조건 | 역할 |
|------|------|-------------|-------------|-----------|------|
| **기본 용사군** | 🎯 셀렉터 | O(n²) | O(1) | - | 안정적 기본형 |
| | 🚀 인서터 | O(n²) | O(1) | 부분정렬에 강함 | 적응형 |
| | 🫧 버블러 | O(n²) | O(1) | - | 교육용 |
| **고급 전술가** | 🌈 셸리 | O(n^1.25) | O(1) | - | 점진적 개선 |
| | ⚡ 머저 | O(n log n) | O(n) | - | 안정성 보장 |
| | 🌪️ 퀵스터 | O(n log n) | O(log n) | - | 평균 최고속 |
| | 🏹 히퍼 | O(n log n) | O(1) | - | 메모리 효율 |
| **분포 침입군** | 💙 카운터 | O(n + k) | O(k) | 제한된 범위 | 개수 기반 |
| | 🔵 래딕스 | O(d×(n+k)) | O(n + k) | 자릿수 존재 | 자릿수 기반 |
| | 🟡 버킷 | O(n + k) | O(n + k) | 균등 분포 | 구간 기반 |
| **각성 용사군** | 🔄 엑스터널 | O(n log n) | O(M) | 거대 데이터 | 외부 정렬 |
| | 🔄 리플레이서 | O(n log M) | O(M) | 런 최적화 | 대치 선택 |
| | 🔄 폴리페이저 | O(n log n) | O(1) | 다단계 합병 | 테이프 정렬 |

### 🎬 최종 대결 시나리오

#### 🌍 시나리오 1: 모바일 게임 (메모리 512MB)
```
📱 상황: 플레이어 점수 정렬 (10만 명)

🏆 1순위: 🏹 히퍼 (O(n log n) + O(1) 공간)
🥈 2순위: 🌪️ 퀵스터 (평균 최고 속도)
🥉 3순위: 🌈 셸리 (메모리 절약하면서도 개선된 성능)

❌ 부적합: 💙🔵🟡 분포군 (점수 범위가 제한적이지 않음)
❌ 부적합: 🔄 각성군 (메모리에 충분히 들어감)
```

#### 🏢 시나리오 2: 대기업 서버 (RAM 64GB, 데이터 1TB)
```
🖥️ 상황: 일일 거래 내역 정렬

🏆 1순위: 🔄 엑스터널 (거대 데이터 전문)
🥈 2순위: 🔄 리플레이서 + 🔄 폴리페이저 (조합)
🥉 3순위: ⚡ 머저 (메모리 충분하면서 안정적)

❌ 부적합: 기본 용사군 (메모리 부족)
❌ 부적합: 분포군 (거래금액 범위가 너무 큼)
```

#### 🎮 시나리오 3: 실시간 순위표 (특정 점수 범위)
```
🕹️ 상황: 0~999 점수 실시간 정렬

🏆 1순위: 💙 카운터 (O(n) 속도!)
🥈 2순위: 🔵 래딕스 (3자리 수)
🥉 3순위: 🟡 버킷 (구간별 처리)

❌ 부적합: 비교 기반 정렬들 (O(n log n)보다 느림)
```

#### 📊 시나리오 4: 빅데이터 분석 (다양한 데이터 타입)
```
📈 상황: 혼합 데이터 타입 + 거대 크기

🏆 최고의 조합:
1. 🔄 엑스터널 (전체 프레임워크)
2. 🔄 리플레이서 (런 생성)
3. 분포군 (적절한 데이터에)
4. ⚡ 머저 (안정성 필요한 부분)

💡 결론: 상황별 최적 조합이 진정한 해답!
```

---

## 🎭 대단원의 마무리: 정렬 대서사시

### 🌟 에필로그: 평화로운 정렬 왕국
```
모든 전투가 끝난 후...

🎯 셀렉터: "우리 모두 각자의 역할이 있었구나."
💙 카운터: "비교 없이도 정렬이 가능하다는 걸 보여줬지."
🔄 엑스터널: "크기에 상관없이 모든 데이터를 다룰 수 있어."

⚡ 머저: "크하하! 결국 상황에 맞는 선택이 최고다!"
🌪️ 퀵스터: "그래, 완벽한 알고리즘은 없어. 적재적소가 중요하지."

🌈 셸리: "모두가 조화롭게 협력할 때 진정한 힘이 나오는 거예요."
🏹 히퍼: "목표는 명확했다. 각자의 강점을 살리는 것."

🔵 래딕스: "자릿수별로 차근차근..."
🟡 버킷: "구역을 나누어..."
🔄 리플레이서: "적응하며..."
🔄 폴리페이저: "끈질기게 합병하며..."

전원: "우리가 배운 건... 정답은 하나가 아니라는 것!"
```

### 🏆 진정한 교훈들

#### 💡 상황별 지혜
```
🔸 작은 데이터 (n < 50): 🚀 인서터 추천
🔸 메모리 제한: 🎯 셀렉터, 🏹 히퍼
🔸 평균 속도 중시: 🌪️ 퀵스터
🔸 안정성 필수: ⚡ 머저
🔸 점진적 개선: 🌈 셸리
🔸 제한된 범위: 💙 카운터
🔸 자릿수 존재: 🔵 래딕스  
🔸 균등 분포: 🟡 버킷
🔸 거대 데이터: 🔄 외부 정렬군
```

#### 🎯 실전 선택 가이드
```python
def 최적_정렬_선택(데이터, 상황):
    """정렬 왕국의 지혜가 담긴 선택 가이드"""
    
    크기 = len(데이터)
    메모리_제한 = 상황.get('메모리_제한', float('inf'))
    안정성_필요 = 상황.get('안정성', False)
    데이터_타입 = 상황.get('데이터_타입', '일반')
    
    # 거대 데이터 체크
    if 크기 > 메모리_제한:
        return "🔄 외부 정렬 조합 (엑스터널 + 리플레이서 + 폴리페이저)"
    
    # 분포 기반 정렬 체크
    if 데이터_타입 == '제한된_정수':
        return "💙 카운터 (계수 정렬)"
    elif 데이터_타입 == '다자리_정수':
        return "🔵 래딕스 (기수 정렬)"
    elif 데이터_타입 == '균등분포_실수':
        return "🟡 버킷 (버킷 정렬)"
    
    # 비교 기반 정렬 선택
    if 크기 < 50:
        return "🚀 인서터 (삽입 정렬)"
    elif 메모리_제한 == '최소':
        return "🏹 히퍼 (힙 정렬)"
    elif 안정성_필요:
        return "⚡ 머저 (병합 정렬)"
    else:
        return "🌪️ 퀵스터 (퀵 정렬)"

# 실전 사용 예시들
print("📱 모바일 게임:", 최적_정렬_선택(
    range(1000), {'메모리_제한': 1000, '데이터_타입': '일반'}))

print("🎮 점수 정렬:", 최적_정렬_선택(
    range(100), {'데이터_타입': '제한된_정수'}))

print("🏢 대용량 DB:", 최적_정렬_선택(
    range(1000000), {'메모리_제한': 10000, '안정성': True}))
```

### 🎵 정렬 왕국 최종 OST
```
🎵 "모든 데이터에는 때가 있다"

♪ 작을 때와 클 때가 있고
♪ 빠를 때와 안전할 때가 있으며  
♪ 메모리 쓸 때와 아낄 때가 있고
♪ 비교할 때와 세는 때가 있도다

♪ 모든 알고리즘에는 때가 있나니
♪ 상황을 보고 지혜롭게 선택하라

🎶 "정렬 하라 시간과 공간의 조화로
🎶 데이터여 질서를 찾아라!" 🎶
```

---

## 📚 부록: 실전 개발자를 위한 치트 시트

### 🚀 언어별 추천 조합
```python
# Python 🐍
data.sort()           # Timsort (머저 + 인서터 하이브리드)
sorted(data)          # 새 리스트 반환

# Java ☕  
Arrays.sort(array)    # Dual-Pivot Quicksort (퀵스터 진화형)
Collections.sort()    # TimSort

# C++ ⚡
std::sort()          # Introsort (퀵 + 힙 + 인서터)
std::stable_sort()   # 안정 정렬 보장

# JavaScript 🌐
array.sort()         # 엔진마다 다름 (대부분 TimSort)
```

### 🎯 성능 측정 도구
```python
import time
import random

def 성능_대결(크기=10000):
    """모든 영웅들의 성능 대결!"""
    
    데이터 = [random.randint(1, 1000) for _ in range(크기)]
    
    영웅들 = {
        "🎯 셀렉터": selection_sort,
        "🚀 인서터": insertion_sort,
        "🫧 버블러": bubble_sort,
        "🌈 셸리": shell_sort,
        "⚡ 머저": merge_sort,
        "🌪️ 퀵스터": quick_sort,
        "🏹 히퍼": heap_sort,
        "🐍 파이썬": lambda x: sorted(x)
    }
    
    결과 = {}
    
    for 이름, 함수 in 영웅들.items():
        데이터_복사 = 데이터.copy()
        
        시작 = time.time()
        함수(데이터_복사)
        끝 = time.time()
        
        결과[이름] = 끝 - 시작
        print(f"{이름}: {결과[이름]:.4f}초")
    
    print(f"\n🏆 승자: {min(결과, key=결과.get)}")

# 성능_대결()
```

---

**🎬 THE END - 정렬 대서사시 완결**

*"다음 모험에서는 탐색 알고리즘 영웅들과 그래프 알고리즘 기사단을 만나게 될지도...?"*

**총 출연진**: 12명의 정렬 영웅들 🎭
**장르**: 교육용 판타지 대서사시
**교훈**: "상황에 맞는 최적의 선택이 진정한 지혜"
## 📊 전체 등장인물 소개

| 영웅 | ⏰ 시간복잡도 | 💾 공간복잡도 | 소속 | 역할 | 특징 |
|------|-------------|-------------|------|------|------|
| 🎯 셀렉터 | O(n²) | **O(1)** | 기본 용사군 | 전사 | 착실한 주인공, 메모리 절약형 |
| 🚀 인서터 | O(n²) | **O(1)** | 기본 용사군 | 마법사 | 지혜로운 조언자, 상황 적응력 |
| 🫧 버블러 | O(n²) | **O(1)** | 기본 용사군 | 탱커 | 순수한 열혈, 끈기의 상징 |
| 🌈 **셸리** | **O(n^1.25)** | **O(1)** | **치유 교단** | **힐러** | **점진적 개선의 현자** |
| ⚡ 머저 | O(n log n) | **O(n)** | 마왕군 | 마왕 | 분할정복의 제왕, 안정성 |
| 🌪️ **퀵스터** | **O(n log n)** | **O(log n)** | **의문의 용병** | **용병** | **속도와 효율의 균형** |
| 🏹 **히퍼** | **O(n log n)** | **O(1)** | **천공 도시** | **궁수** | **정확무오한 정밀 사격** |
| 🖤 **카운터** | **O(n + k)** | **O(k)** | **마왕군** | **흑주술사** | **범위 제한 조건부 사기** |
| 🔮 **래딕스** | **O(d×(n+k))** | **O(n + k)** | **마왕군** | **대마도사** | **자릿수 분해 조건부 사기** |
| 🎭 **버킷** | **O(n + k)** | **O(n + k)** | **마왕군** | **선동가** | **균등분포 조건부 사기** |
| 🔄 **엑스터널** | **O(n log n)** | **O(M)** | **각성 용사군** | **외부정렬 마스터** | **거대 데이터 전문** |
| 🔄 **리플레이서** | **O(n log M)** | **O(M)** | **각성 용사군** | **대치선택 마스터** | **런 최적화 전문** |
| 🔄 **폴리페이저** | **O(n log n)** | **O(1)** | **각성 용사군** | **다단계합병 마스터** | **테이프 정렬 전문** |

---

